<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Board Game Collection Manager</title>
    <link rel="icon" href="https://wallpapers.com/images/hd/red-d20-dice-icon-4xdi6uhmnfam2pvj.jpg" type="image/jpeg">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-...your_sha512_hash..." crossorigin="anonymous" referrerpolicy="no-referrer">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.4.5/swiper-bundle.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f7fa;
            color: #333;
            line-height: 1.6;
            transition: background-color 0.3s ease;
        }

        body.edit-mode {
            background: #ffffff;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            margin-bottom: 1rem;
            text-align: center;
        }

        .controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }

        .hamburger {
            display: none;
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
        }

        .mobile-menu {
            position: fixed;
            top: 0;
            left: -100%;
            width: 250px;
            height: 100vh;
            background: rgba(102, 126, 234, 0.95);
            backdrop-filter: blur(10px);
            transition: left 0.3s ease;
            z-index: 1000;
            padding: 2rem 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .mobile-menu.show {
            left: 0;
        }

        .mobile-menu .btn {
            width: 100%;
            justify-content: center;
        }

.search-box {
            flex: 1;
            min-width: 200px;
            max-width: 400px;
            position: relative;
        }

        .controls .search-box {
            max-width: 300px;
        }

        .clear-thumbs-btn {
            background: #af834c !important;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .clear-thumbs-btn:hover {
            background: #9a7043 !important;
        }

        .search-box input {
            width: 100%;
            padding: 0.75rem;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            outline: none;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 25px;
            background: rgba(255,255,255,0.2);
            color: white;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }

        .btn-primary {
            background: #4CAF50;
        }

        .btn-primary:hover {
            background: #45a049;
        }

        .columns-btn {
            background: rgba(255,255,255,0.8);
            color: #333;
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .columns-btn:hover {
            background: rgba(255,255,255,0.9);
            transform: translateY(-2px);
        }

        .edit-mode-controls {
            display: none;
            gap: 1rem;
        }

        .edit-mode-controls.show {
            display: flex;
        }

        .btn-save {
            background: #4CAF50;
        }

        .btn-discard {
            background: #e74c3c;
        }

        .filters {
            background: white;
            padding: 1rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 1rem;
            display: none;
        }

        .filters.show {
            display: block;
        }

        .filter-row {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .filter-group label {
            font-weight: 600;
            color: #555;
            font-size: 0.9rem;
        }

        .filter-group input, .filter-group select {
            padding: 0.5rem;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 0.9rem;
            min-width: 120px;
        }

        .filter-group .btn {
            background: #667eea;
            color: white;
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
        }

button#clear-filters {
    background: #667eea;
    color: white;
    padding: 0.5rem 1rem;
    font-size: 0.8rem;
}

        .sort-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .container {
            max-width: 98%;
            margin: 0 auto;
            padding: 1rem;
        }

        .game-grid {
            display: grid;
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .game-grid.cols-1 { grid-template-columns: 1fr; }
        .game-grid.cols-2 { grid-template-columns: repeat(2, 1fr); }
        .game-grid.cols-3 { grid-template-columns: repeat(3, 1fr); }
        .game-grid.cols-4 { grid-template-columns: repeat(4, 1fr); }
        .game-grid.cols-5 { grid-template-columns: repeat(5, 1fr); }

        .game-card {
            background: white;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            overflow: hidden;
            transition: all 0.3s ease;
            position: relative;
        }

        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.15);
        }

        .game-card.edit-mode {
            background: #fff3cd;
            border: 2px solid #ffc107;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.3);
        }

        .image-carousel {
            position: relative;
            height: 200px;
            overflow: hidden;
        }

        .swiper {
            width: 100%;
            height: 100%;
        }

        .swiper-slide {
            display: flex;
            justify-content: center;
            align-items: center;
            background: #f8f9fa;
        }

        .swiper-slide img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .swiper-button-next,
        .swiper-button-prev {
            color: white;
            background: rgba(0,0,0,0.5);
            width: 35px;
            height: 35px;
            margin-top: -17px;
            border-radius: 50%;
            z-index: 10;
        }

        .swiper-button-next:after,
        .swiper-button-prev:after {
            font-size: 14px;
        }

        .swiper-pagination-bullet {
            background: white;
            opacity: 0.7;
        }

        .swiper-pagination-bullet-active {
            opacity: 1;
        }

        .game-info {
            padding: 1.5rem;
        }

        .game-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 0.5rem;
            line-height: 1.3;
        }

        .game-meta {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #666;
        }

        .meta-label {
            font-weight: 600;
            min-width: 60px;
        }

.thumb-buttons {
    position: absolute;
    bottom: 10px;
    left: 10px;
    right: 10px;
    display: flex;
    justify-content: space-between;
    pointer-events: none;
}

.thumb-btn {
    width: 24px;
    height: 24px;
    border: none;
    border-radius: 50%;
    font-size: 12px;
    cursor: pointer;
    pointer-events: auto;
    opacity: 0.7;
    transition: opacity 0.3s ease;
    z-index: 5;
}

.thumb-btn:hover {
    opacity: 1;
}

.thumb-up {
    background: #144d16b0;
    color: white;
}

.thumb-down {
    background: #ac1900e6;
    color: white;
}

.thumb-btn.active {
    opacity: 1;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

.modal-thumbs {
    position: absolute;
    top: 10px;
    left: 10px;
    display: flex;
    gap: 10px;
    z-index: 10;
}

.game-card {
    position: relative;
}

        .edit-field {
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            font-size: 0.9rem;
            width: 100%;
            margin: 0.25rem 0;
        }

        .edit-field:focus {
            border-color: #667eea;
            outline: none;
        }

        .edit-images {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin: 0.5rem 0;
        }

        .edit-image-item {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .edit-image-item input {
            flex: 1;
        }

        .edit-image-item button {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
        }

        .add-image-btn {
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            margin-top: 0.5rem;
        }

        .delete-game-btn {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            margin-top: 1rem;
            width: 100%;
            font-weight: 600;
        }

        .delete-game-btn:hover {
            background: #c0392b;
        }

        .edit-expanded {
            padding: 1.5rem;
        }

        .edit-section {
            margin-bottom: 1.5rem;
        }

        .edit-section h4 {
            color: #2c3e50;
            margin-bottom: 0.75rem;
            font-size: 1rem;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.25rem;
        }

        .edit-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .edit-group {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .edit-group label {
            font-weight: 600;
            color: #555;
            font-size: 0.85rem;
        }

        .details-toggle {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-weight: 600;
            padding: 0.5rem 0;
            width: 100%;
            text-align: left;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .details-content {
            display: none;
            padding-top: 1rem;
            border-top: 1px solid #eee;
            margin-top: 1rem;
        }

        .details-content.show {
            display: block;
        }

        .detail-section {
            margin-bottom: 1rem;
        }

        .detail-section h4 {
            color: #2c3e50;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .detail-section p {
            color: #666;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .notes {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            font-style: italic;
        }

        .add-game-form {
            display: none;
            background: white;
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            margin-bottom: 2rem;
            position: relative;
        }

        .add-game-form.show {
            display: block;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-group label {
            font-weight: 600;
            color: #2c3e50;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            padding: 0.75rem;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .form-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
        }

        .close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #999;
        }

        .empty-state {
            text-align: center;
            padding: 3rem;
            color: #666;
        }

        .empty-state h3 {
            margin-bottom: 1rem;
            color: #2c3e50;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #667eea;
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .success {
            background: #efe;
            color: #363;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .modal {
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background-color: white;
            margin: 2% auto;
            padding: 2rem;
            border-radius: 15px;
            width: 95%;
            max-width: 1200px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }

        .close-modal {
            position: absolute;
            top: 1rem;
            right: 1.5rem;
            font-size: 2rem;
            cursor: pointer;
            color: #999;
        }

        .lightbox {
            position: fixed;
            z-index: 3000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
        }

        .lightbox-content {
            position: relative;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-lightbox {
            position: absolute;
            top: 2rem;
            right: 2rem;
            font-size: 3rem;
            cursor: pointer;
            color: white;
            z-index: 3001;
        }

        /* Mobile Controls Layout */
        .mobile-controls {
            display: none;
        }

/* Responsive Design */
        @media (max-width: 768px) {
    .modal-content div[style*="grid-template-columns: 1fr 1fr"] {
        grid-template-columns: 1fr !important;
    }
    
    .modal-content div[style*="display: flex"] {
        flex-direction: column !important;
        align-items: flex-start !important;
    }

            .game-meta {
                grid-template-columns: 1fr;
            }

            .form-row {
                grid-template-columns: 1fr;
            }

            .filter-row {
                flex-direction: column;
                gap: 1rem;
            }

            .sort-controls {
                width: 100%;
                justify-content: center;
            }

            .hamburger {
                display: block;
            }
            
            .controls {
                display: none;
            }

            .github-controls {
                display: none !important;
            }

.mobile-controls {
                display: flex;
                gap: 0.5rem;
                align-items: center;
                margin-top: 0.5rem;
            }

            .mobile-controls .search-box {
                flex: 1;
                min-width: 150px;
                max-width: 200px;
            }
            
            .header h1 {
                font-size: 1.2rem;
                margin-bottom: 0.5rem;
                display: flex;
                align-items: center;
                justify-content: space-between;
            }
            
            .header {
                padding: 0.5rem 1rem;
            }

            .modal-content {
                margin: 1% auto;
                width: 98%;
                max-height: 95vh;
            }
        }

        /* Custom filter delete confirmation */
        .custom-filter-delete {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            font-size: 0.8rem;
        }

.complexity-tooltip {
    position: relative;
    display: inline-block;
    cursor: help;
    margin-left: 0.25rem;
}

.complexity-tooltip .tooltiptext {
    visibility: hidden;
    width: 200px;
    background-color: rgba(0,0,0,0.9);
    color: #fff;
    text-align: left;
    border-radius: 6px;
    padding: 8px;
    position: absolute;
    z-index: 1;
    bottom: 125%;
    left: 50%;
    margin-left: -100px;
    opacity: 0;
    transition: opacity 0.3s;
    font-size: 0.8rem;
    line-height: 1.4;
}

.complexity-tooltip:hover .tooltiptext {
    visibility: visible;
    opacity: 1;
}

    </style>
</head>
<body>
    <div class="header">
        <h1 id="page-title">
            Board Game Collection Manager
            <button class="hamburger" id="hamburger-btn" style="display: none;">☰</button>
        </h1>
        
 <div class="controls">
            <div class="search-box">
                <input type="text" id="search" placeholder="Search games...">
            </div>
<button class="btn clear-thumbs-btn" id="clear-thumbs-btn" style="display: none;">Reset Pins/Hidden</button>
            <button class="btn" id="toggle-filters">Filters</button>
            <button class="btn btn-primary" id="add-game-btn">Add Game</button>
            <button class="btn" id="edit-mode-btn">Edit Mode</button>
            <div class="edit-mode-controls" id="edit-mode-controls">
                <button class="btn btn-discard" id="discard-changes-btn">Discard Changes</button>
                <button class="btn btn-save" id="save-changes-btn">Save Changes</button>
            </div>
            <button class="btn" id="share-btn">Share Collection</button>
            <button class="btn" id="export-btn">Export Data</button>
            <button class="btn" id="import-btn">Import Data</button>
            <button class="columns-btn" id="columns-btn">5 Columns</button>
        </div>

        <div class="github-controls" style="position: absolute; top: 1rem; right: 1rem; display: flex; align-items: center; gap: 1rem;">
            <span id="google-drive-status" style="font-size: 0.9rem;">Loading GitHub...</span>
            <button class="btn" id="google-drive-signin" style="display: none;">Connect GitHub</button>
            <button class="btn" id="google-drive-signout" style="display: none;">Disconnect GitHub</button>
        </div>

<div class="mobile-controls">
            <div class="search-box">
                <input type="text" id="mobile-search" placeholder="Search games...">
            </div>
<button class="btn clear-thumbs-btn" id="mobile-clear-thumbs-btn" style="display: none;">Reset Pins/Hidden</button>
            <button class="btn" id="mobile-toggle-filters">Filters</button>
        </div>

<div class="mobile-menu" id="mobile-menu">
            <button class="btn" id="mobile-filters-btn">Filters</button>
            <button class="btn btn-primary" id="mobile-add-game-btn">Add Game</button>
            <button class="btn" id="mobile-edit-mode-btn">Edit Mode</button>
            <div class="edit-mode-controls" id="mobile-edit-mode-controls">
                <button class="btn btn-discard" id="mobile-discard-changes-btn">Discard Changes</button>
                <button class="btn btn-save" id="mobile-save-changes-btn">Save Changes</button>
            </div>
            <button class="btn" id="mobile-share-btn">Share Collection</button>
            <button class="btn" id="mobile-export-btn">Export Data</button>
            <button class="btn" id="mobile-import-btn">Import Data</button>
            <button class="columns-btn" id="mobile-columns-btn">2 Columns</button>
            <button class="btn" id="mobile-google-drive-signin" style="display: none;">Connect GitHub</button>
            <button class="btn" id="mobile-google-drive-signout" style="display: none;">Disconnect GitHub</button>
            <div id="mobile-google-drive-status" style="font-size: 0.9rem; padding: 0.5rem; text-align: center;">Loading GitHub...</div>
        </div>
    </div>

    <div class="filters" id="filters">
        <div class="filter-row">
            <div class="sort-controls">
                <label>Sort by:</label>
<select id="sort-field">
                    <option value="name">Name</option>
                    <option value="year">Year Published</option>
                    <option value="dateAcquired">Date Acquired</option>
                    <option value="players.min">Min Players</option>
                    <option value="players.max">Max Players</option>
                    <option value="playtime.min">Playtime</option>
                    <option value="weight">Complexity</option>
                </select>
                <select id="sort-order">
                    <option value="asc">Ascending</option>
                    <option value="desc">Descending</option>
                </select>
            </div>
            <button class="btn" id="clear-filters">Clear All</button>
        </div>
        <div class="filter-row">
<div class="filter-group">
    <label>Best Player Count</label>
    <input type="text" id="best-player-count-filter" placeholder="2,3,4 (comma separated)">
</div>
            <div class="filter-group">
                <label>Min Players</label>
                <div style="display: flex; gap: 0.5rem;">
                    <select id="min-players-type">
                        <option value="greater">Greater than</option>
                        <option value="exact">Exactly</option>
                        <option value="less">Less than</option>
                    </select>
                    <input type="number" id="min-players" min="1" placeholder="1">
                </div>
            </div>
            <div class="filter-group">
                <label>Max Players</label>
                <div style="display: flex; gap: 0.5rem;">
                    <select id="max-players-type">
                        <option value="less">Less than</option>
                        <option value="exact">Exactly</option>
                        <option value="greater">Greater than</option>
                    </select>
                    <input type="number" id="max-players" min="1" placeholder="10">
                </div>
            </div>
            <div class="filter-group">
                <label>Min Playtime</label>
                <div style="display: flex; gap: 0.5rem;">
                    <select id="min-playtime-type">
                        <option value="greater">Greater than</option>
                        <option value="exact">Exactly</option>
                        <option value="less">Less than</option>
                    </select>
                    <input type="number" id="min-playtime" min="0" placeholder="30">
                </div>
            </div>
            <div class="filter-group">
                <label>Max Playtime</label>
                <div style="display: flex; gap: 0.5rem;">
                    <select id="max-playtime-type">
                        <option value="less">Less than</option>
                        <option value="exact">Exactly</option>
                        <option value="greater">Greater than</option>
                    </select>
                    <input type="number" id="max-playtime" min="0" placeholder="120">
                </div>
            </div>
<div class="filter-group">
                <label>Year Published</label>
                <div style="display: flex; gap: 0.5rem;">
                    <select id="year-filter-type">
                        <option value="exact">Exactly</option>
                        <option value="greater">After</option>
                        <option value="less">Before</option>
                    </select>
                    <input type="number" id="year-filter" min="1900" max="2030" placeholder="2020">
                </div>
</div>
<div class="filter-group">
                <label>Date Acquired</label>
                <div style="display: flex; gap: 0.5rem;">
                    <select id="date-acquired-filter-type">
                        <option value="exact">Same Year As...</option>
                        <option value="greater">After</option>
                        <option value="less">Before</option>
                    </select>
                    <input type="date" id="date-acquired-filter">
                </div>
            </div>
            <div class="filter-group">
                <label>Weight Range</label>
                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                    <div style="display: flex; gap: 0.25rem; align-items: center;">
                        <span style="font-size: 0.8rem;">Min:</span>
                        <select id="min-weight-type" style="width: auto;">
                            <option value="greater">></option>
                            <option value="exact">=</option>
                        </select>
                        <input type="number" id="min-weight" min="1" max="5" step="0.1" placeholder="1.0" style="width: 70px;">
                    </div>
                    <div style="display: flex; gap: 0.25rem; align-items: center;">
                        <span style="font-size: 0.8rem;">Max:</span>
                        <select id="max-weight-type" style="width: auto;">
                            <option value="less"><</option>
                            <option value="exact">=</option>
                        </select>
                        <input type="number" id="max-weight" min="1" max="5" step="0.1" placeholder="5.0" style="width: 70px;">
                    </div>
                </div>
            </div>
<div class="filter-group">
    <label>Designer</label>
    <select id="designer-filter">
        <option value="">All Designers</option>
    </select>
</div>
            <div class="filter-group">
                <label>Designer Contains</label>
                <div style="display: flex; gap: 0.5rem;">
                    <select id="designer-contains-filter-type">
                        <option value="contains">Contains</option>
                        <option value="exact">Exact</option>
                        <option value="not-contains">Does not contain</option>
                    </select>
                    <input type="text" id="designer-contains-filter" placeholder="Designer name">
                </div>
            </div>
            <div class="filter-group">
                <label>Designer Nationality</label>
                <select id="designer-nationality-filter">
                    <option value="">All Nationalities</option>
                </select>
            </div>
<div class="filter-group">
                <label>Designer Nationality Contains</label>
                <div style="display: flex; gap: 0.5rem;">
                    <select id="designer-nationality-contains-filter-type">
                        <option value="contains">Contains</option>
                        <option value="exact">Exact</option>
                        <option value="not-contains">Does not contain</option>
                    </select>
                    <input type="text" id="designer-nationality-contains-filter" placeholder="Nationality">
                </div>
            </div>
            <div class="filter-group">
                <label>Artist</label>
                <select id="artist-filter">
                    <option value="">All Artists</option>
                </select>
            </div>
            <div class="filter-group">
                <label>Artist Contains</label>
                <div style="display: flex; gap: 0.5rem;">
                    <select id="artist-contains-filter-type">
                        <option value="contains">Contains</option>
                        <option value="exact">Exact</option>
                        <option value="not-contains">Does not contain</option>
                    </select>
                    <input type="text" id="artist-contains-filter" placeholder="Artist name">
                </div>
            </div>
            <div class="filter-group">
                <label>Publisher</label>
    <select id="publisher-dropdown-filter">
        <option value="">All Publishers</option>
    </select>
</div>
<div class="filter-group">
                <label>Publisher Contains</label>
                <div style="display: flex; gap: 0.5rem;">
                    <select id="publisher-filter-type">
                        <option value="contains">Contains</option>
                        <option value="exact">Exact</option>
                        <option value="not-contains">Does not contain</option>
                    </select>
                    <input type="text" id="publisher-filter" placeholder="Publisher name">
</div>
            </div>
            <div class="filter-group">
                <label>Publisher Country</label>
                <div style="display: flex; gap: 0.5rem;">
                    <select id="publisher-country-filter-type">
                        <option value="contains">Contains</option>
                        <option value="exact">Exact</option>
                        <option value="not-contains">Does not contain</option>
                    </select>
                    <input type="text" id="publisher-country-filter" placeholder="Country">
                </div>
            </div>
<div class="filter-group">
    <label>Notes</label>
    <div style="display: flex; gap: 0.5rem;">
        <select id="notes-filter-type">
            <option value="contains">Contains</option>
            <option value="exact">Exact</option>
            <option value="not-contains">Does not contain</option>
        </select>
        <input type="text" id="notes-filter" placeholder="Search notes">
    </div>
</div>
<div class="filter-group">
    <label>Description</label>
    <div style="display: flex; gap: 0.5rem;">
        <select id="description-filter-type">
            <option value="contains">Contains</option>
            <option value="exact">Exact</option>
            <option value="not-contains">Does not contain</option>
        </select>
        <input type="text" id="description-filter" placeholder="Search descriptions">
    </div>
</div>
<div class="filter-group">
    <label>Category</label>
    <select id="category-filter">
        <option value="">All Categories</option>
    </select>
</div>
<div class="filter-group">
    <label>Category Contains</label>
    <div style="display: flex; gap: 0.5rem;">
        <select id="category-contains-filter-type">
            <option value="contains">Contains</option>
            <option value="exact">Exact</option>
            <option value="not-contains">Does not contain</option>
        </select>
        <input type="text" id="category-contains-filter" placeholder="Category name">
    </div>
</div>
<div class="filter-group">
    <label>Mechanisms</label>
    <select id="mechanisms-filter">
        <option value="">All Mechanisms</option>
    </select>
</div>
<div class="filter-group">
    <label>Mechanisms Contains</label>
    <div style="display: flex; gap: 0.5rem;">
        <select id="mechanisms-contains-filter-type">
            <option value="contains">Contains</option>
            <option value="exact">Exact</option>
            <option value="not-contains">Does not contain</option>
        </select>
        <input type="text" id="mechanisms-contains-filter" placeholder="Mechanism name">
    </div>
</div>

        </div>
       <div class="filter-row">
           <div class="filter-group">
               <label>Custom Filters</label>
               <button class="btn" id="add-custom-filter">Add Custom Filter</button>
           </div>
           <div id="custom-filters-container"></div>
       </div>
   </div>

   <div class="container">
       <div class="add-game-form" id="add-game-form">
           <button class="close-btn" id="close-form">&times;</button>
           <h2>Add New Game</h2>
           
           <div class="form-row">
               <div class="form-group">
                   <label>BoardGameGeek URL</label>
                   <input type="url" id="bgg-url" placeholder="https://boardgamegeek.com/boardgame/...">
                   <button class="btn btn-primary" id="fetch-bgg-data">Fetch Game Data</button>
               </div>
           </div>

           <div id="loading-indicator" class="loading" style="display: none;">
               Fetching game data from BoardGameGeek...
           </div>

           <div id="error-message" class="error" style="display: none;"></div>

           <div class="form-row">
               <div class="form-group">
                   <label>Game Name</label>
                   <input type="text" id="game-name" required>
               </div>
<div class="form-group">
                   <label>Year Published</label>
                   <input type="number" id="game-year" min="1900" max="2030">
               </div>
<div class="form-group">
                   <label>Date Acquired</label>
                   <input type="date" id="game-date-acquired" value="1991-11-19">
               </div>
           </div>

           <div class="form-row">
               <div class="form-group">
                   <label>Min Players</label>
                   <input type="number" id="game-min-players" min="1" max="20">
               </div>
               <div class="form-group">
                   <label>Max Players</label>
                   <input type="number" id="game-max-players" min="1" max="20">
               </div>
               <div class="form-group">
                   <label>Playtime (minutes)</label>
                   <input type="number" id="game-playtime" min="0" max="600">
               </div>
<div class="form-group">
                   <label>Complexity (1-5)</label>
                   <div style="display: flex; gap: 0.5rem;">
                       <input type="number" id="game-weight" step="0.1" min="0" max="5" style="flex: 1;">
<select id="game-weight-color" style="width: 100px;">
    <option value="#008000">Green</option>
    <option value="#cfa200">Yellow</option>
    <option value="#ff0000">Red</option>
</select>
                   </div>
               </div>
           </div>

           <div class="form-row">
               <div class="form-group">
                   <label>Best Player Count</label>
                   <input type="text" id="game-best-players" placeholder="2,3,4 (comma separated)">
               </div>
               <div class="form-group">
                   <label>Designers</label>
                   <input type="text" id="game-designers" placeholder="Comma separated">
               </div>
               <div class="form-group">
                   <label>Artists</label>
                   <input type="text" id="game-artists" placeholder="Comma separated">
               </div>
<div class="form-group">
                   <label>Publishers</label>
                   <input type="text" id="game-publishers" placeholder="Comma separated">
               </div>
<div class="form-group">
                   <label>Designer Nationality</label>
                   <input type="text" id="game-designer-nationality" placeholder="Comma separated">
               </div>
               <div class="form-group">
                   <label>Publisher Country</label>
                   <input type="text" id="game-publisher-country" placeholder="Comma separated">
               </div>
           </div>

<div class="form-row">
    <div class="form-group">
        <label>Images (URLs, one per line)</label>
        <textarea id="game-images" placeholder="https://image1.jpg&#10;https://image2.jpg"></textarea>
    </div>
    <div class="form-group">
        <label>Notes</label>
        <textarea id="game-notes" placeholder="Your thoughts about this game..."></textarea>
    </div>
</div>
<div class="form-row">
    <div class="form-group">
        <label>Description</label>
        <textarea id="game-description" placeholder="Game description..."></textarea>
    </div>
</div>
<div class="form-row">
    <div class="form-group">
        <label>Category</label>
        <input type="text" id="game-category" placeholder="Strategy, Family, Party, etc. (comma separated)">
    </div>
    <div class="form-group">
        <label>Mechanisms</label>
        <input type="text" id="game-mechanisms" placeholder="Dice Rolling, Worker Placement, etc. (comma separated)">
    </div>
</div>

          <div class="form-actions">
              <button class="btn" id="cancel-add">Cancel</button>
              <button class="btn btn-primary" id="save-game">Save Game</button>
          </div>
      </div>

      <div id="game-container">
          <div id="results-info" style="margin-bottom: 1rem; color: #666; font-size: 0.9rem;"></div>
          <div class="game-grid" id="game-grid"></div>
          <div class="empty-state" id="empty-state" style="display: none;">
              <h3>No games in your collection yet</h3>
              <p>Click "Add Game" to get started, or import an existing collection.</p>
          </div>
      </div>
  </div>

  <input type="file" id="import-file" accept=".json" style="display: none;">

  <!-- Load new Google Identity Services library -->
  <script src="https://accounts.google.com/gsi/client"></script>
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.4.5/swiper-bundle.min.js"></script>
  <script>
console.log('JavaScript is loading...');
document.addEventListener('DOMContentLoaded', () => {
   console.log('DOM loaded, buttons should work now');
});

class BoardGameCollection {
   constructor() {
       this.games = new Map();
       this.filteredGames = [];
       this.currentFilters = {};
       this.customFilters = [];
       this.isSharedView = false;
       this.isEditMode = false;
       this.gameBackups = new Map();
       this.visibleFields = ['name', 'year', 'players', 'playtime', 'weight', 'images', 'notes'];
       this.cardVisibleFields = ['name', 'players'];
       this.dynamicCardFields = [];
this.currentColumns = 5; // Always start with 5 on desktop
this.mobileColumns = 2; // Always start with 2 on mobile
this.gamePreferences = new Map(); // stores thumbs up/down: 'up', 'down', or null
this.originalSharedPreferences = new Map(); // for shared collections
this.initGoogleDrive();
   }

async init() {
    console.log('Initializing app...');
    
    // Check for shared view FIRST, before loading any storage
const isSharedCollection = await this.checkForSharedView();
    console.log('Is shared collection:', isSharedCollection);
    
    // Only load from storage if it's NOT a shared collection
    if (!isSharedCollection) {
        console.log('Loading from storage...');
        await this.loadFromStorage();
    } else {
        console.log('Skipping storage load for shared collection');
    }
    
    this.bindEvents();
    const isMobile = window.innerWidth <= 768;
    this.setColumns(isMobile ? this.mobileColumns : this.currentColumns);
    
    console.log('About to render...');
    this.render();
    
this.updateDesignerFilter();
this.updatePublisherFilter();
this.updateDesignerNationalityFilter();
this.updateArtistFilter();
this.updateCategoryFilter();
this.updateMechanismsFilter();
this.updateClearThumbsVisibility();

// Apply shared filters to UI AFTER dropdowns are populated
if (this.isSharedView && this.currentFilters) {
    this.applyFiltersToUI(this.currentFilters);
    console.log('Applied shared filters to UI after dropdown population');
}
    
    console.log('About to apply filters...');
    this.applyFilters();
    
    console.log('App initialization complete');
}

// Initialize GitHub file storage
initGoogleDrive() {
    // GitHub storage configuration - replace with your repository details
    this.GITHUB_OWNER = 'jt1919191919'; // Your GitHub username
    this.GITHUB_REPO = 'board-game-tool'; // Your repository name
    this.GITHUB_BRANCH = 'main'; // Usually 'main' or 'master'
    this.GITHUB_FILE_PATH = 'games-data.json'; // File to store your collection
    this.GITHUB_TOKEN = null; // Personal Access Token (user will set this)
    
    this.githubReady = false;
    this.isSignedIn = false;
    
    this.loadGitHubSettings();
}

loadGitHubSettings() {
    try {
        const stored = localStorage.getItem('github-token');
        if (stored) {
            this.GITHUB_TOKEN = stored;
            this.isSignedIn = true;
            this.githubReady = true;
        }
        this.updateGoogleDriveUI();
    } catch (error) {
        console.error('Error loading GitHub settings:', error);
        document.getElementById('google-drive-status').textContent = 'GitHub storage failed - using local storage';
        document.getElementById('google-drive-status').style.color = 'red';
    }





}

async signInToGoogleDrive() {
    const token = prompt('Enter your GitHub Personal Access Token:\n\nTo create one:\n1. Go to GitHub.com → Settings → Developer settings → Personal access tokens\n2. Generate new token (classic)\n3. Select "repo" scope\n4. Copy the token here');
    
    if (token && token.trim()) {
        this.GITHUB_TOKEN = token.trim();
        localStorage.setItem('github-token', this.GITHUB_TOKEN);
        this.isSignedIn = true;
        this.githubReady = true;
        this.updateGoogleDriveUI();
        this.loadFromGitHub();
    }
}

async signOutFromGoogleDrive() {
    try {
        localStorage.removeItem('github-token');
        this.GITHUB_TOKEN = null;
        this.isSignedIn = false;
        this.githubReady = false;
        this.updateGoogleDriveUI();
    } catch (error) {
        console.error('GitHub sign out failed:', error);
    }
}

   handleCredentialResponse(response) {
       // This is for ID tokens, we need OAuth2 tokens for Drive API
       console.log('Credential response received');
   }

updateGoogleDriveUI() {
    const signInBtn = document.getElementById('google-drive-signin');
    const signOutBtn = document.getElementById('google-drive-signout');
    const status = document.getElementById('google-drive-status');
    const mobileSignInBtn = document.getElementById('mobile-google-drive-signin');
    const mobileSignOutBtn = document.getElementById('mobile-google-drive-signout');
    const mobileStatus = document.getElementById('mobile-google-drive-status');
    
    const statusText = this.isSignedIn ? 'Connected to GitHub Storage' : 'Not connected to GitHub Storage';
    const statusColor = this.isSignedIn ? 'white' : 'red';
    
    if (signInBtn && signOutBtn && status) {
        if (this.isSignedIn) {
            signInBtn.style.display = 'none';
            signOutBtn.style.display = 'inline-block';
        } else {
            signInBtn.style.display = 'inline-block';
            signOutBtn.style.display = 'none';
        }
        signInBtn.textContent = 'Connect GitHub';
        signOutBtn.textContent = 'Disconnect GitHub';
        status.textContent = statusText;
        status.style.color = statusColor;
    }
    
    if (mobileSignInBtn && mobileSignOutBtn && mobileStatus) {
        if (this.isSignedIn) {
            mobileSignInBtn.style.display = 'none';
            mobileSignOutBtn.style.display = 'block';
        } else {
            mobileSignInBtn.style.display = 'block';
            mobileSignOutBtn.style.display = 'none';
        }
        mobileSignInBtn.textContent = 'Connect GitHub';
        mobileSignOutBtn.textContent = 'Disconnect GitHub';
        mobileStatus.textContent = statusText;
        mobileStatus.style.color = statusColor;
    }
}

async saveToGitHub() {
    if (!this.githubReady || !this.isSignedIn || !this.GITHUB_TOKEN) {
        console.log('GitHub not ready, saving to localStorage');
        this.saveToLocalStorage();
        return;
    }

    try {
const data = {
    games: Object.fromEntries(this.games),
    preferences: Object.fromEntries(this.gamePreferences),
    lastModified: new Date().toISOString(),
    version: '1.0'
};

        const content = JSON.stringify(data, null, 2);
        const encodedContent = btoa(unescape(encodeURIComponent(content)));
        
        // Check if file exists
        let sha = null;
        try {
            const getResponse = await fetch(`https://api.github.com/repos/${this.GITHUB_OWNER}/${this.GITHUB_REPO}/contents/${this.GITHUB_FILE_PATH}`, {
                headers: {
                    'Authorization': `token ${this.GITHUB_TOKEN}`,
                    'Accept': 'application/vnd.github.v3+json'
                }
            });
            
            if (getResponse.ok) {
                const fileData = await getResponse.json();
                sha = fileData.sha;
            }
        } catch (error) {
            console.log('File does not exist yet, will create new file');
        }

        // Create or update file
        const updateData = {
            message: `Update board game collection - ${new Date().toLocaleString()}`,
            content: encodedContent,
            branch: this.GITHUB_BRANCH
        };
        
        if (sha) {
            updateData.sha = sha;
        }

        const response = await fetch(`https://api.github.com/repos/${this.GITHUB_OWNER}/${this.GITHUB_REPO}/contents/${this.GITHUB_FILE_PATH}`, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${this.GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(updateData)
        });

        if (!response.ok) {
            throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
        }

        console.log('Saved to GitHub successfully');
        
    } catch (error) {
        console.error('Error saving to GitHub:', error);
        alert('Failed to save to GitHub. Check your token and repository settings. Saving locally instead.');
        this.saveToLocalStorage();
    }
}

async loadFromGitHub() {
    // Don't load from GitHub if we're in shared view
    if (this.isSharedView) {
        console.log('Skipping GitHub load - in shared view');
        return;
    }
    
    if (!this.githubReady || !this.isSignedIn || !this.GITHUB_TOKEN) {
        this.loadFromLocalStorage();
        return;
    }

    try {
        const response = await fetch(`https://api.github.com/repos/${this.GITHUB_OWNER}/${this.GITHUB_REPO}/contents/${this.GITHUB_FILE_PATH}`, {
            headers: {
                'Authorization': `token ${this.GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });

        if (response.ok) {
            const fileData = await response.json();
            const content = decodeURIComponent(escape(atob(fileData.content)));
            const data = JSON.parse(content);
            
            if (data.games) {
                this.games.clear();
                Object.entries(data.games).forEach(([id, game]) => {
                    this.games.set(id, game);
                });
                
                if (data.preferences) {
                    this.gamePreferences.clear();
                    Object.entries(data.preferences).forEach(([id, pref]) => {
                        this.gamePreferences.set(id, pref);
                    });
                }
                console.log('Loaded collection from GitHub');
            }
        } else {
            console.log('No collection file found in GitHub repository');
            this.loadFromLocalStorage();
        }
        
    } catch (error) {
        console.error('Error loading from GitHub:', error);
        this.loadFromLocalStorage();
    }
}

   saveToLocalStorage() {
       try {
           const data = Object.fromEntries(this.games);
           localStorage.setItem('boardgame-collection', JSON.stringify(data, null, 2));
           console.log('Saved to localStorage');
       } catch (e) {
           console.warn('Could not save to localStorage:', e);
       }
   }

loadFromLocalStorage() {
    // Don't load local storage if we're in shared view
    if (this.isSharedView) {
        console.log('Skipping localStorage load - in shared view');
        return;
    }
    
    try {
        const stored = localStorage.getItem('boardgame-collection');
        if (stored) {
            const data = JSON.parse(stored);
            if (data.games) {
                Object.entries(data.games).forEach(([id, game]) => {
                    this.games.set(id, game);
                });
                
                if (data.preferences) {
                    Object.entries(data.preferences).forEach(([id, pref]) => {
                        this.gamePreferences.set(id, pref);
                    });
                }
            } else {
                // Legacy format - data is directly the games object
                Object.entries(data).forEach(([id, game]) => {
                    this.games.set(id, game);
                });
            }
            console.log('Loaded collection from localStorage');
        }
    } catch (e) {
        console.warn('Could not load from localStorage:', e);
    }
    
    // Only load sample data if we have no games AND we're not in shared view
    if (this.games.size === 0 && !this.isSharedView) {
        console.log('Loading sample data...');
        this.loadSampleData();
    }
}

async saveToStorage() {
    if (!this.isSharedView) {
        if (this.githubReady && this.isSignedIn) {
            await this.saveToGitHub();
        } else {
            this.saveToLocalStorage();
        }
    }
}

async loadFromStorage() {
    // Don't load from storage if we're in shared view
    if (this.isSharedView) {
        console.log('Skipping storage load - in shared view');
        return;
    }
    
    if (this.githubReady && this.isSignedIn) {
        await this.loadFromGitHub();
    } else {
        this.loadFromLocalStorage();
    }
}

   loadSampleData() {
       const sampleGames = [
           {
               bggId: '161936',
               bggUrl: 'https://boardgamegeek.com/boardgame/161936/pandemic-legacy-season-1',
               name: 'Pandemic Legacy: Season 1',
year: 2015,
               dateAcquired: '1991-11-19',
               players: { min: 2, max: 4 },
               playtime: { min: 60, max: 60 },
               weight: 2.83,
               bestPlayerCount: [3, 4],
               designers: ['Rob Daviau', 'Matt Leacock'],
               artists: ['Chris Quilliams'],
               publishers: ['Z-Man Games'],
               images: [
                   'https://cf.geekdo-images.com/S3ybV1LAp-8SnHIXLLjVHg__itemrep/img/EdBzaOvIMm_O0-2T9lFpiRnYNhI=/fit-in/246x300/filters:strip_icc()/pic2452831.png'
               ],
               notes: 'Incredible campaign game that evolves as you play. Best with 4 players for maximum discussion.',
               customFields: { owned: true, condition: 'Like New' }
           },
           {
               bggId: '167791',
               bggUrl: 'https://boardgamegeek.com/boardgame/167791/terraforming-mars',
               name: 'Terraforming Mars',
year: 2016,
               dateAcquired: '1991-11-19',
               players: { min: 1, max: 5 },
               playtime: { min: 90, max: 120 },
               weight: 3.25,
               bestPlayerCount: [3, 4],
               designers: ['Jacob Fryxelius'],
               artists: ['Isaac Fryxelius'],
               publishers: ['FryxGames'],
               images: [
                   'https://cf.geekdo-images.com/wg9oOLcsKvDesSUdZQ4rxw__itemrep/img/BTkTHO7-8nYRb-DbkY5xNrfI5fI=/fit-in/246x300/filters:strip_icc()/pic3536616.jpg'
               ],
               notes: 'Great engine building game with excellent theme. Takes a while to learn but very rewarding.',
               customFields: { owned: true, condition: 'Very Good' }
           }
       ];

       sampleGames.forEach(game => {
           this.games.set(game.bggId, game);
       });
   }


async checkForSharedView() {
    console.log('Checking for shared view...');
    const urlParams = new URLSearchParams(window.location.search);
    const gistId = urlParams.get('gist');
    const legacySharedData = urlParams.get('share');
    
    console.log('Gist ID parameter:', gistId ? 'Found' : 'Not found');
    console.log('Legacy shared data parameter:', legacySharedData ? 'Found' : 'Not found');
    
    // Try Gist first
    if (gistId) {
        try {
            console.log('Attempting to load shared collection from Gist...');
            
            const response = await fetch(`https://api.github.com/gists/${gistId}`, {
                headers: {
                    'Accept': 'application/vnd.github.v3+json'
                }
            });

            if (!response.ok) {
                throw new Error(`Failed to fetch Gist: ${response.status} ${response.statusText}`);
            }

            const gist = await response.json();
            const fileContent = gist.files['board-game-collection.json'];
            
            if (!fileContent) {
                throw new Error('Board game collection file not found in Gist');
            }

            const config = JSON.parse(fileContent.content);
            console.log('Parsed Gist config:', config);
            
            if (config.games && config.games.length > 0) {
                console.log(`Loading ${config.games.length} shared games from Gist...`);
                
                // Clear existing games and load shared ones
                this.games.clear();
                this.gamePreferences.clear();
                
                config.games.forEach((game, index) => {
                    const gameId = game.bggId || `shared-${index}`;
                    this.games.set(gameId, game);
                    console.log(`Added shared game: ${game.name}`);
                });
                
// Apply shared configuration
                if (config.filters) {
                    this.currentFilters = config.filters;
                    // Don't apply filters to UI yet - will do this after dropdowns are populated
                    console.log('Applied shared filters:', config.filters);
                }
                if (config.columns) {
                    this.currentColumns = config.columns;
                }
                if (config.preferences) {
                    Object.entries(config.preferences).forEach(([gameId, pref]) => {
                        this.gamePreferences.set(gameId, pref);
                        this.originalSharedPreferences.set(gameId, pref);
                    });
                    console.log('Applied shared preferences:', config.preferences);
                }
                
// Set shared view mode
this.isSharedView = true;
this.originalSharedFilters = JSON.parse(JSON.stringify(config.filters || {}));
this.originalSharedSortField = config.sortField || 'name';
this.originalSharedSortOrder = config.sortOrder || 'asc';

// Apply sort settings to UI
if (config.sortField) {
    document.getElementById('sort-field').value = config.sortField;
}
if (config.sortOrder) {
    document.getElementById('sort-order').value = config.sortOrder;
}
                
                console.log(`Successfully loaded shared collection with ${config.games.length} games`);
                return true;
            } else {
                console.log('No games found in Gist config');
            }
        } catch (error) {
            console.error('Error loading shared collection from Gist:', error);
            console.error('Error details:', error.message);
        }
    }
    
    // Fallback to legacy URL parameter method
    if (legacySharedData) {
        try {
            console.log('Attempting to decode legacy shared data...');
            const decodedData = decodeURIComponent(escape(atob(legacySharedData)));
            console.log('Decoded data length:', decodedData.length);
            
            const config = JSON.parse(decodedData);
            console.log('Parsed legacy config:', config);
            
            if (config.games && config.games.length > 0) {
                console.log(`Loading ${config.games.length} shared games...`);
                
                // Clear existing games and load shared ones
                this.games.clear();
                this.gamePreferences.clear();
                
                config.games.forEach((game, index) => {
                    const gameId = game.bggId || `shared-${index}`;
                    this.games.set(gameId, game);
                    console.log(`Added shared game: ${game.name}`);
                });
                
// Apply shared configuration
                if (config.filters) {
                    this.currentFilters = config.filters;
                    // Don't apply filters to UI yet - will do this after dropdowns are populated
                    console.log('Applied shared filters:', config.filters);
                }
                if (config.columns) {
                    this.currentColumns = config.columns;
                }
                if (config.preferences) {
                    Object.entries(config.preferences).forEach(([gameId, pref]) => {
                        this.gamePreferences.set(gameId, pref);
                        this.originalSharedPreferences.set(gameId, pref);
                    });
                    console.log('Applied shared preferences:', config.preferences);
                }
                
// Set shared view mode
this.isSharedView = true;
this.originalSharedFilters = JSON.parse(JSON.stringify(config.filters || {}));
this.originalSharedSortField = config.sortField || 'name';
this.originalSharedSortOrder = config.sortOrder || 'asc';

// Apply sort settings to UI
if (config.sortField) {
    document.getElementById('sort-field').value = config.sortField;
}
if (config.sortOrder) {
    document.getElementById('sort-order').value = config.sortOrder;
}

console.log(`Successfully loaded shared collection with ${config.games.length} games`);
return true;
            } else {
                console.log('No games found in shared config');
            }
        } catch (error) {
            console.error('Error loading legacy shared collection:', error);
            console.error('Error details:', error.message);
        }
    }
    
    return false;
}

applyFiltersToUI(filters) {
    // Apply filters to the UI form fields so the filtering logic works
    if (filters.search) {
        document.getElementById('search').value = filters.search;
        document.getElementById('mobile-search').value = filters.search;
    }
    if (filters.minPlayers) {
        document.getElementById('min-players').value = filters.minPlayers;
        document.getElementById('min-players-type').value = filters.minPlayersType || 'greater';
    }
    if (filters.maxPlayers) {
        document.getElementById('max-players').value = filters.maxPlayers;
        document.getElementById('max-players-type').value = filters.maxPlayersType || 'less';
    }
    if (filters.minPlaytime) {
        document.getElementById('min-playtime').value = filters.minPlaytime;
        document.getElementById('min-playtime-type').value = filters.minPlaytimeType || 'greater';
    }
    if (filters.maxPlaytime) {
        document.getElementById('max-playtime').value = filters.maxPlaytime;
        document.getElementById('max-playtime-type').value = filters.maxPlaytimeType || 'less';
    }
    if (filters.year) {
        document.getElementById('year-filter').value = filters.year;
        document.getElementById('year-filter-type').value = filters.yearType || 'exact';
    }
    if (filters.publisher) {
        document.getElementById('publisher-filter').value = filters.publisher;
        document.getElementById('publisher-filter-type').value = filters.publisherType || 'contains';
    }
    if (filters.minWeight) {
        document.getElementById('min-weight').value = filters.minWeight;
        document.getElementById('min-weight-type').value = filters.minWeightType || 'greater';
    }
    if (filters.maxWeight) {
        document.getElementById('max-weight').value = filters.maxWeight;
        document.getElementById('max-weight-type').value = filters.maxWeightType || 'less';
    }
    if (filters.bestPlayerCount) {
        document.getElementById('best-player-count-filter').value = filters.bestPlayerCount;
    }
    if (filters.notes) {
        document.getElementById('notes-filter').value = filters.notes;
        document.getElementById('notes-filter-type').value = filters.notesType || 'contains';
    }
    if (filters.designer) {
        document.getElementById('designer-filter').value = filters.designer;
    }
if (filters.publisherDropdown) {
        document.getElementById('publisher-dropdown-filter').value = filters.publisherDropdown;
    }
if (filters.dateAcquired) {
        document.getElementById('date-acquired-filter').value = filters.dateAcquired;
        document.getElementById('date-acquired-filter-type').value = filters.dateAcquiredType || 'exact';
    }
    if (filters.designerContains) {
        document.getElementById('designer-contains-filter').value = filters.designerContains;
        document.getElementById('designer-contains-filter-type').value = filters.designerContainsType || 'contains';
    }
    if (filters.designerNationalityContains) {
        document.getElementById('designer-nationality-contains-filter').value = filters.designerNationalityContains;
        document.getElementById('designer-nationality-contains-filter-type').value = filters.designerNationalityContainsType || 'contains';
    }
    if (filters.designerNationality) {
        document.getElementById('designer-nationality-filter').value = filters.designerNationality;
    }
    if (filters.artist) {
        document.getElementById('artist-filter').value = filters.artist;
    }
    if (filters.artistContains) {
        document.getElementById('artist-contains-filter').value = filters.artistContains;
        document.getElementById('artist-contains-filter-type').value = filters.artistContainsType || 'contains';
    }
if (filters.publisherCountry) {
        document.getElementById('publisher-country-filter').value = filters.publisherCountry;
        document.getElementById('publisher-country-filter-type').value = filters.publisherCountryType || 'contains';
    }
if (filters.description) {
        document.getElementById('description-filter').value = filters.description;
        document.getElementById('description-filter-type').value = filters.descriptionType || 'contains';
    }
    if (filters.category) {
        document.getElementById('category-filter').value = filters.category;
    }
    if (filters.categoryContains) {
        document.getElementById('category-contains-filter').value = filters.categoryContains;
        document.getElementById('category-contains-filter-type').value = filters.categoryContainsType || 'contains';
    }
if (filters.mechanisms) {
    document.getElementById('mechanisms-filter').value = filters.mechanisms;
}
if (filters.notesType) {
    document.getElementById('notes-filter-type').value = filters.notesType;
}
if (filters.descriptionType) {
    document.getElementById('description-filter-type').value = filters.descriptionType;
}
if (filters.mechanismsContains) {
    document.getElementById('mechanisms-contains-filter').value = filters.mechanismsContains;
    document.getElementById('mechanisms-contains-filter-type').value = filters.mechanismsContainsType || 'contains';
}
if (filters.type && document.getElementById('type-filter')) {
    document.getElementById('type-filter').value = filters.type;
}
if (filters.typeContains && document.getElementById('type-contains-filter')) {
    document.getElementById('type-contains-filter').value = filters.typeContains;
    document.getElementById('type-contains-filter-type').value = filters.typeContainsType || 'contains';
}
if (filters.designer) {
    document.getElementById('designer-filter').value = filters.designer;
}
if (filters.designerNationality) {
    document.getElementById('designer-nationality-filter').value = filters.designerNationality;
}
if (filters.artist) {
    document.getElementById('artist-filter').value = filters.artist;
}
if (filters.publisherDropdown) {
    document.getElementById('publisher-dropdown-filter').value = filters.publisherDropdown;
}
if (filters.category) {
    document.getElementById('category-filter').value = filters.category;
}
if (filters.mechanisms) {
    document.getElementById('mechanisms-filter').value = filters.mechanisms;
}
}

bindEvents() {
       console.log('Starting bindEvents...');
       
       // Search functionality
       const searchElement = document.getElementById('search');
       console.log('search element:', searchElement);
       if (searchElement) {
           searchElement.addEventListener('input', (e) => {
               this.currentFilters.search = e.target.value;
               const mobileSearch = document.getElementById('mobile-search');
               if (mobileSearch) mobileSearch.value = e.target.value;
               this.updateDynamicCardFields();
               this.applyFilters();
           });
       }

       const mobileSearchElement = document.getElementById('mobile-search');
       console.log('mobile-search element:', mobileSearchElement);
       if (mobileSearchElement) {
           mobileSearchElement.addEventListener('input', (e) => {
               this.currentFilters.search = e.target.value;
               const mainSearch = document.getElementById('search');
               if (mainSearch) mainSearch.value = e.target.value;
               this.updateDynamicCardFields();
               this.applyFilters();
           });
       }

// Mobile menu
       const hamburgerBtn = document.getElementById('hamburger-btn');
       if (hamburgerBtn) {
           hamburgerBtn.addEventListener('click', () => {
               const mobileMenu = document.getElementById('mobile-menu');
               if (mobileMenu) mobileMenu.classList.toggle('show');
           });
       }

       document.addEventListener('click', (e) => {
           const menu = document.getElementById('mobile-menu');
           const hamburger = document.getElementById('hamburger-btn');
           if (menu && hamburger && !menu.contains(e.target) && !hamburger.contains(e.target)) {
               menu.classList.remove('show');
           }
       });

       // Filter controls
       const toggleFiltersBtn = document.getElementById('toggle-filters');
       if (toggleFiltersBtn) {
           toggleFiltersBtn.addEventListener('click', () => {
               const filters = document.getElementById('filters');
               if (filters) filters.classList.toggle('show');
           });
       }

       const mobileToggleFiltersBtn = document.getElementById('mobile-toggle-filters');
       if (mobileToggleFiltersBtn) {
           mobileToggleFiltersBtn.addEventListener('click', () => {
               const filters = document.getElementById('filters');
               if (filters) filters.classList.toggle('show');
           });
       }

       const mobileFiltersBtn = document.getElementById('mobile-filters-btn');
       if (mobileFiltersBtn) {
           mobileFiltersBtn.addEventListener('click', () => {
               const filters = document.getElementById('filters');
               const mobileMenu = document.getElementById('mobile-menu');
               if (filters) filters.classList.toggle('show');
               if (mobileMenu) mobileMenu.classList.remove('show');
           });
       }

// Filter inputs
const filterInputs = [
    'min-players', 'max-players', 'min-playtime', 'max-playtime', 
    'year-filter', 'date-acquired-filter', 'publisher-filter', 'designer-contains-filter', 
    'artist-filter', 'artist-contains-filter', 'designer-nationality-contains-filter', 
    'designer-nationality-filter', 'publisher-country-filter', 'min-weight', 'max-weight',
'best-player-count-filter', 'notes-filter', 'description-filter',
'category-contains-filter', 'mechanisms-contains-filter', 'type-contains-filter'
];
       
       filterInputs.forEach(id => {
           const element = document.getElementById(id);
           if (element) {
               element.addEventListener('input', () => {
                   this.updateFilters();
                   this.updateDynamicCardFields();
                   this.applyFilters();
               });
           }
           
           const typeSelect = document.getElementById(id + '-type');
           if (typeSelect) {
               typeSelect.addEventListener('change', () => {
                   this.updateFilters();
                   this.applyFilters();
               });
           }
       });

// Auto-update weight color when weight changes in add game form
       const gameWeightInput = document.getElementById('game-weight');
       const gameWeightColorSelect = document.getElementById('game-weight-color');
       if (gameWeightInput && gameWeightColorSelect) {
           gameWeightInput.addEventListener('input', () => {
               const weight = parseFloat(gameWeightInput.value);
               if (!isNaN(weight)) {
let defaultColor = '#008000';
if (weight >= 2.5) {
    defaultColor = '#ff0000';
} else if (weight >= 1.9) {
    defaultColor = '#cfa200';
}
                   gameWeightColorSelect.value = defaultColor;
               }
           });
       }

const designerFilter = document.getElementById('designer-filter');
       if (designerFilter) {
           designerFilter.addEventListener('change', () => {
               this.updateFilters();
               this.applyFilters();
           });
       }

const publisherDropdownFilter = document.getElementById('publisher-dropdown-filter');
       if (publisherDropdownFilter) {
           publisherDropdownFilter.addEventListener('change', () => {
               this.updateFilters();
               this.applyFilters();
           });
       }

const designerNationalityFilter = document.getElementById('designer-nationality-filter');
       if (designerNationalityFilter) {
           designerNationalityFilter.addEventListener('change', () => {
               this.updateFilters();
               this.applyFilters();
           });
       }

const artistFilter = document.getElementById('artist-filter');
if (artistFilter) {
    artistFilter.addEventListener('change', () => {
        this.updateFilters();
        this.applyFilters();
    });
}

const categoryFilter = document.getElementById('category-filter');
if (categoryFilter) {
    categoryFilter.addEventListener('change', () => {
        this.updateFilters();
        this.applyFilters();
    });
}

const mechanismsFilter = document.getElementById('mechanisms-filter');
if (mechanismsFilter) {
    mechanismsFilter.addEventListener('change', () => {
        this.updateFilters();
        this.applyFilters();
    });
}

const typeFilter = document.getElementById('type-filter');
if (typeFilter) {
    typeFilter.addEventListener('change', () => {
        this.updateFilters();
        this.applyFilters();
    });
}

       // Sort controls - combined event handlers
       const sortFieldElement = document.getElementById('sort-field');
       if (sortFieldElement) {
           sortFieldElement.addEventListener('change', () => {
               this.updateDynamicCardFields();
               this.applyFilters();
           });
       }
       
const sortOrderElement = document.getElementById('sort-order');
       if (sortOrderElement) {
           sortOrderElement.addEventListener('change', () => this.applyFilters());
       }

       // Clear filters
const clearFiltersBtn = document.getElementById('clear-filters');
       if (clearFiltersBtn) {
           clearFiltersBtn.addEventListener('click', () => {
               this.clearFilters();
           });
       }


// Clear thumbs
const clearThumbsBtn = document.getElementById('clear-thumbs-btn');
if (clearThumbsBtn) {
    clearThumbsBtn.addEventListener('click', () => {
        this.clearThumbs();
    });
}

const mobileClearThumbsBtn = document.getElementById('mobile-clear-thumbs-btn');
if (mobileClearThumbsBtn) {
    mobileClearThumbsBtn.addEventListener('click', () => {
        this.clearThumbs();
    });
}

       // Custom filters
const addCustomFilterBtn = document.getElementById('add-custom-filter');
if (addCustomFilterBtn) {
    addCustomFilterBtn.addEventListener('click', () => {
        this.addCustomFilter();
    });
}

       // Edit mode
const editModeBtn = document.getElementById('edit-mode-btn');
if (editModeBtn) {
    editModeBtn.addEventListener('click', () => {
        this.toggleEditMode();
    });
}

const mobileEditModeBtn = document.getElementById('mobile-edit-mode-btn');
if (mobileEditModeBtn) {
    mobileEditModeBtn.addEventListener('click', () => {
        this.toggleEditMode();
        document.getElementById('mobile-menu').classList.remove('show');
    });
}

const saveChangesBtn = document.getElementById('save-changes-btn');
if (saveChangesBtn) {
    saveChangesBtn.addEventListener('click', () => {
        this.saveAllChanges();
    });
}

const discardChangesBtn = document.getElementById('discard-changes-btn');
if (discardChangesBtn) {
    discardChangesBtn.addEventListener('click', () => {
        this.discardAllChanges();
    });
}

const mobileDiscardChangesBtn = document.getElementById('mobile-discard-changes-btn');
if (mobileDiscardChangesBtn) {
    mobileDiscardChangesBtn.addEventListener('click', () => {
        this.discardAllChanges();
        document.getElementById('mobile-menu').classList.remove('show');
    });
}

const mobileSaveChangesBtn = document.getElementById('mobile-save-changes-btn');
if (mobileSaveChangesBtn) {
    mobileSaveChangesBtn.addEventListener('click', () => {
        this.saveAllChanges();
        document.getElementById('mobile-menu').classList.remove('show');
    });
}

       // Column controls
const columnsBtn = document.getElementById('columns-btn');
if (columnsBtn) {
    columnsBtn.addEventListener('click', () => {
        this.cycleColumns();
    });
}

const mobileColumnsBtn = document.getElementById('mobile-columns-btn');
if (mobileColumnsBtn) {
    mobileColumnsBtn.addEventListener('click', () => {
        this.cycleColumns();
    });
}

       // Add game form
       document.getElementById('add-game-btn').addEventListener('click', () => {
           document.getElementById('add-game-form').classList.add('show');
       });

       document.getElementById('mobile-add-game-btn').addEventListener('click', () => {
           document.getElementById('add-game-form').classList.add('show');
           document.getElementById('mobile-menu').classList.remove('show');
       });

       document.getElementById('close-form').addEventListener('click', () => {
           this.closeForm();
       });

       document.getElementById('cancel-add').addEventListener('click', () => {
           this.closeForm();
       });

       document.getElementById('fetch-bgg-data').addEventListener('click', () => {
           this.fetchBGGData();
       });

       document.getElementById('save-game').addEventListener('click', () => {
           this.saveGame();
       });

       // Share and export
       document.getElementById('share-btn').addEventListener('click', () => {
           this.shareCollection();
       });

       document.getElementById('mobile-share-btn').addEventListener('click', () => {
           this.shareCollection();
           document.getElementById('mobile-menu').classList.remove('show');
       });

       document.getElementById('export-btn').addEventListener('click', () => {
           this.exportData();
       });

       document.getElementById('mobile-export-btn').addEventListener('click', () => {
           this.exportData();
           document.getElementById('mobile-menu').classList.remove('show');
       });

       document.getElementById('import-btn').addEventListener('click', () => {
           document.getElementById('import-file').click();
       });

       document.getElementById('mobile-import-btn').addEventListener('click', () => {
           document.getElementById('import-file').click();
           document.getElementById('mobile-menu').classList.remove('show');
       });

       document.getElementById('import-file').addEventListener('change', (e) => {
           this.importData(e.target.files[0]);
       });

// Google Drive controls
       document.getElementById('google-drive-signin').addEventListener('click', () => {
           this.signInToGoogleDrive();
       });

       document.getElementById('google-drive-signout').addEventListener('click', () => {
           this.signOutFromGoogleDrive();
       });

       // Mobile Google Drive controls
       document.getElementById('mobile-google-drive-signin').addEventListener('click', () => {
           this.signInToGoogleDrive();
           document.getElementById('mobile-menu').classList.remove('show');
       });

       document.getElementById('mobile-google-drive-signout').addEventListener('click', () => {
           this.signOutFromGoogleDrive();
           document.getElementById('mobile-menu').classList.remove('show');
       });

       // Modal events
       document.addEventListener('click', (e) => {
           if (e.target.id === 'game-modal') {
               this.closeModal();
           }
           if (e.target.id === 'lightbox-modal') {
               this.closeLightbox();
           }
       });

       // Responsive handling
       window.addEventListener('resize', () => {
           if (window.innerWidth <= 768) {
               document.getElementById('hamburger-btn').style.display = 'block';
           } else {
               document.getElementById('hamburger-btn').style.display = 'none';
               document.getElementById('mobile-menu').classList.remove('show');
           }
       });


if (window.innerWidth <= 768) {
           document.getElementById('hamburger-btn').style.display = 'block';
       }
   }

   updateFilters() {
       const minPlayers = parseInt(document.getElementById('min-players').value) || null;
       const maxPlayers = parseInt(document.getElementById('max-players').value) || null;
       const minPlaytime = parseInt(document.getElementById('min-playtime').value) || null;
       const maxPlaytime = parseInt(document.getElementById('max-playtime').value) || null;
       const year = parseInt(document.getElementById('year-filter').value) || null;
       const minWeight = parseFloat(document.getElementById('min-weight').value) || null;
       const maxWeight = parseFloat(document.getElementById('max-weight').value) || null;
       const bestPlayerCount = document.getElementById('best-player-count-filter').value;

const dateAcquired = document.getElementById('date-acquired-filter').value || null;
       
       this.currentFilters = {
           search: document.getElementById('search').value,
           minPlayers, maxPlayers, minPlaytime, maxPlaytime, year, dateAcquired, minWeight, maxWeight,
publisher: document.getElementById('publisher-filter').value,
designerContains: document.getElementById('designer-contains-filter').value,
designerNationalityContains: document.getElementById('designer-nationality-contains-filter').value,
designerNationality: document.getElementById('designer-nationality-filter').value,
artist: document.getElementById('artist-filter').value,
artistContains: document.getElementById('artist-contains-filter').value,
publisherCountry: document.getElementById('publisher-country-filter').value,
bestPlayerCount,
description: document.getElementById('description-filter').value,
           minPlayersType: document.getElementById('min-players-type').value,
           maxPlayersType: document.getElementById('max-players-type').value,
           minPlaytimeType: document.getElementById('min-playtime-type').value,
           maxPlaytimeType: document.getElementById('max-playtime-type').value,
           yearType: document.getElementById('year-filter-type').value,
           dateAcquiredType: document.getElementById('date-acquired-filter-type').value,
           minWeightType: document.getElementById('min-weight-type').value,
           maxWeightType: document.getElementById('max-weight-type').value,
           designer: document.getElementById('designer-filter').value,
           designerContainsType: document.getElementById('designer-contains-filter-type').value,
           designerNationalityContainsType: document.getElementById('designer-nationality-contains-filter-type').value,
           artistContainsType: document.getElementById('artist-contains-filter-type').value,
           publisherDropdown: document.getElementById('publisher-dropdown-filter').value,
           publisherCountryType: document.getElementById('publisher-country-filter-type').value,
notes: document.getElementById('notes-filter').value,
notesType: document.getElementById('notes-filter-type').value,
description: document.getElementById('description-filter').value,
descriptionType: document.getElementById('description-filter-type').value,
category: document.getElementById('category-filter').value,
categoryContains: document.getElementById('category-contains-filter').value,
categoryContainsType: document.getElementById('category-contains-filter-type').value,
mechanisms: document.getElementById('mechanisms-filter').value,
mechanismsContains: document.getElementById('mechanisms-contains-filter').value,
mechanismsContainsType: document.getElementById('mechanisms-contains-filter-type').value,
type: document.getElementById('type-filter') ? document.getElementById('type-filter').value : '',
typeContains: document.getElementById('type-contains-filter') ? document.getElementById('type-contains-filter').value : '',
typeContainsType: document.getElementById('type-contains-filter-type') ? document.getElementById('type-contains-filter-type').value : 'contains',
publisherType: document.getElementById('publisher-filter-type').value
       };

       this.customFilters = [];
       document.querySelectorAll('#custom-filters-container .filter-group').forEach(filterGroup => {
           const field = filterGroup.querySelector('.custom-filter-field').value;
           const type = filterGroup.querySelector('.custom-filter-type').value;
           const value = filterGroup.querySelector('.custom-filter-value').value;
           if (value) {
               this.customFilters.push({ field, type, value });
           }
       });
   }

   updateDynamicCardFields() {
       this.dynamicCardFields = [];
       
       if (this.currentFilters.search) {
           this.dynamicCardFields.push('notes', 'designers', 'publishers');
       }
if (this.currentFilters.year) this.dynamicCardFields.push('year');
if (this.currentFilters.dateAcquired) this.dynamicCardFields.push('dateAcquired');
       
       // Add sort field to visible fields
       const sortField = document.getElementById('sort-field').value;
       if (sortField && sortField !== 'name' && sortField !== 'players.min' && sortField !== 'players.max') {
           if (!this.dynamicCardFields.includes(sortField)) {
               this.dynamicCardFields.push(sortField);
           }
       }
       if (this.currentFilters.publisher) this.dynamicCardFields.push('publishers');
       if (this.currentFilters.minPlayers || this.currentFilters.maxPlayers) this.dynamicCardFields.push('players');
       if (this.currentFilters.minPlaytime || this.currentFilters.maxPlaytime) this.dynamicCardFields.push('playtime');
       if (this.currentFilters.minWeight || this.currentFilters.maxWeight) this.dynamicCardFields.push('weight');
       if (this.currentFilters.bestPlayerCount) this.dynamicCardFields.push('bestPlayerCount');
   }

   updateDesignerFilter() {
       const designerCounts = {};
       this.games.forEach(game => {
           if (game.designers) {
               game.designers.forEach(designer => {
                   designerCounts[designer] = (designerCounts[designer] || 0) + 1;
               });
           }
       });

       const sortedDesigners = Object.entries(designerCounts)
           .sort((a, b) => b[1] - a[1]);

       const select = document.getElementById('designer-filter');
       const currentValue = select.value;
       select.innerHTML = '<option value="">All Designers</option>';
       
       sortedDesigners.forEach(([designer, count]) => {
           const option = document.createElement('option');
           option.value = designer;
           option.textContent = `${designer} (${count})`;
           select.appendChild(option);
       });
       
       select.value = currentValue;
   }


updatePublisherFilter() {
       const publisherCounts = {};
       this.games.forEach(game => {
           if (game.publishers) {
               game.publishers.forEach(publisher => {
                   publisherCounts[publisher] = (publisherCounts[publisher] || 0) + 1;
               });
           }
       });

       const sortedPublishers = Object.entries(publisherCounts)
           .sort((a, b) => b[1] - a[1]);

       const select = document.getElementById('publisher-dropdown-filter');
       const currentValue = select.value;
       select.innerHTML = '<option value="">All Publishers</option>';
       
       sortedPublishers.forEach(([publisher, count]) => {
           const option = document.createElement('option');
           option.value = publisher;
           option.textContent = `${publisher} (${count})`;
           select.appendChild(option);
       });
       
       select.value = currentValue;
   }

   updateDesignerNationalityFilter() {
       const nationalityCounts = {};
       this.games.forEach(game => {
           if (game.designerNationality) {
               const nationalities = Array.isArray(game.designerNationality) ? 
                   game.designerNationality : game.designerNationality.split(',').map(s => s.trim());
               nationalities.forEach(nationality => {
                   if (nationality) {
                       nationalityCounts[nationality] = (nationalityCounts[nationality] || 0) + 1;
                   }
               });
           }
       });

       const sortedNationalities = Object.entries(nationalityCounts)
           .sort((a, b) => b[1] - a[1]);

       const select = document.getElementById('designer-nationality-filter');
       const currentValue = select.value;
       select.innerHTML = '<option value="">All Nationalities</option>';
       
       sortedNationalities.forEach(([nationality, count]) => {
           const option = document.createElement('option');
           option.value = nationality;
           option.textContent = `${nationality} (${count})`;
           select.appendChild(option);
       });
       
       select.value = currentValue;
   }

updateArtistFilter() {
    const artistCounts = {};
    this.games.forEach(game => {
        if (game.artists) {
            game.artists.forEach(artist => {
                artistCounts[artist] = (artistCounts[artist] || 0) + 1;
            });
        }
    });

    const sortedArtists = Object.entries(artistCounts)
        .sort((a, b) => b[1] - a[1]);

    const select = document.getElementById('artist-filter');
    const currentValue = select.value;
    select.innerHTML = '<option value="">All Artists</option>';
    
    sortedArtists.forEach(([artist, count]) => {
        const option = document.createElement('option');
        option.value = artist;
        option.textContent = `${artist} (${count})`;
        select.appendChild(option);
    });
    
    select.value = currentValue;
}

updateCategoryFilter() {
    const categoryCounts = {};
    this.games.forEach(game => {
        if (game.category) {
            game.category.forEach(category => {
                categoryCounts[category] = (categoryCounts[category] || 0) + 1;
            });
        }
    });

    const sortedCategories = Object.entries(categoryCounts)
        .sort((a, b) => b[1] - a[1]);

    const select = document.getElementById('category-filter');
    const currentValue = select.value;
    select.innerHTML = '<option value="">All Categories</option>';
    
    sortedCategories.forEach(([category, count]) => {
        const option = document.createElement('option');
        option.value = category;
        option.textContent = `${category} (${count})`;
        select.appendChild(option);
    });
    
    select.value = currentValue;
}

updateMechanismsFilter() {
    const mechanismsCounts = {};
    this.games.forEach(game => {
        if (game.mechanisms) {
            game.mechanisms.forEach(mechanism => {
                mechanismsCounts[mechanism] = (mechanismsCounts[mechanism] || 0) + 1;
            });
        }
    });

    const sortedMechanisms = Object.entries(mechanismsCounts)
        .sort((a, b) => b[1] - a[1]);

    const select = document.getElementById('mechanisms-filter');
    const currentValue = select.value;
    select.innerHTML = '<option value="">All Mechanisms</option>';
    
    sortedMechanisms.forEach(([mechanism, count]) => {
        const option = document.createElement('option');
        option.value = mechanism;
        option.textContent = `${mechanism} (${count})`;
        select.appendChild(option);
    });
    
    select.value = currentValue;
}

   addCustomFilter() {
       const container = document.getElementById('custom-filters-container');
       const filterId = 'custom-filter-' + Date.now();
       
       const filterHtml = `
           <div class="filter-group" id="${filterId}">
               <label>Custom Filter</label>
               <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                   <select class="custom-filter-field">
                       <option value="name">Name</option>
                       <option value="year">Year</option>
                       <option value="designers">Designers</option>
                       <option value="artists">Artists</option>
                       <option value="publishers">Publishers</option>
                       <option value="notes">Notes</option>
                       <option value="weight">Complexity</option>
                       <option value="players.min">Min Players</option>
                       <option value="players.max">Max Players</option>
                       <option value="playtime.min">Min Playtime</option>
                       <option value="playtime.max">Max Playtime</option>
                       <option value="bestPlayerCount">Best Player Count</option>
                   </select>
                   <select class="custom-filter-type">
                       <option value="contains">Contains</option>
                       <option value="exact">Exact</option>
                       <option value="not-contains">Does not contain</option>
                       <option value="greater">Greater than</option>
                       <option value="less">Less than</option>
                       <option value="greater-equal">Greater or equal</option>
                       <option value="less-equal">Less or equal</option>
                   </select>
                   <input type="text" class="custom-filter-value" placeholder="Value">
                   <button type="button" class="custom-filter-delete" onclick="boardGameApp.deleteCustomFilter('${filterId}')">×</button>
               </div>
           </div>
       `;
       
       container.insertAdjacentHTML('beforeend', filterHtml);
       
       const newFilter = document.getElementById(filterId);
       newFilter.querySelectorAll('select, input').forEach(input => {
           input.addEventListener('change', () => {
               this.updateFilters();
               this.applyFilters();
           });
       });
   }

   deleteCustomFilter(filterId) {
       if (confirm('Delete this custom filter?')) {
           document.getElementById(filterId).remove();
           this.updateFilters();
           this.applyFilters();
       }
   }

toggleEditMode() {
       this.isEditMode = !this.isEditMode;
       const btn = document.getElementById('edit-mode-btn');
       const mobileBtn = document.getElementById('mobile-edit-mode-btn');
       const controls = document.getElementById('edit-mode-controls');
       const mobileControls = document.getElementById('mobile-edit-mode-controls');
       
       if (this.isEditMode) {
           this.gameBackups.clear();
           this.games.forEach((game, id) => {
               this.gameBackups.set(id, JSON.parse(JSON.stringify(game)));
           });

           document.body.classList.add('edit-mode');
           btn.style.display = 'none';
           mobileBtn.style.display = 'none';
           controls.classList.add('show');
           if (mobileControls) mobileControls.classList.add('show');
       } else {
           document.body.classList.remove('edit-mode');
           btn.style.display = 'block';
           mobileBtn.style.display = 'block';
           controls.classList.remove('show');
           if (mobileControls) mobileControls.classList.remove('show');
           this.gameBackups.clear();
       }
       
       this.render();
   }

   saveAllChanges() {
       document.querySelectorAll('.game-card.edit-mode').forEach(card => {
           const gameId = card.dataset.gameId;
           const game = this.games.get(gameId);
           if (!game) return;

game.name = card.querySelector('[data-field="name"]').value;
game.bggUrl = card.querySelector('[data-field="bggUrl"]').value;
game.description = card.querySelector('[data-field="description"]').value;
game.year = parseInt(card.querySelector('[data-field="year"]').value) || null;
game.dateAcquired = card.querySelector('[data-field="dateAcquired"]').value || '1991-11-19';
           game.players.min = parseInt(card.querySelector('[data-field="players.min"]').value) || 1;
           game.players.max = parseInt(card.querySelector('[data-field="players.max"]').value) || 1;
           game.playtime.min = parseInt(card.querySelector('[data-field="playtime.min"]').value) || 0;
           game.playtime.max = parseInt(card.querySelector('[data-field="playtime.max"]').value) || 0;
           game.weight = parseFloat(card.querySelector('[data-field="weight"]').value) || 0;
game.weightColor = card.querySelector('[data-field="weightColor"]').value || '#008000';
           game.notes = card.querySelector('[data-field="notes"]').value;

           const designersField = card.querySelector('[data-field="designers"]');
           if (designersField) {
               game.designers = designersField.value.split(',').map(s => s.trim()).filter(s => s);
           }

           const artistsField = card.querySelector('[data-field="artists"]');
           if (artistsField) {
               game.artists = artistsField.value.split(',').map(s => s.trim()).filter(s => s);
           }

           const publishersField = card.querySelector('[data-field="publishers"]');
if (publishersField) {
               game.publishers = publishersField.value.split(',').map(s => s.trim()).filter(s => s);
           }

const designerNationalityField = card.querySelector('[data-field="designerNationality"]');
           if (designerNationalityField) {
               game.designerNationality = designerNationalityField.value.split(',').map(s => s.trim()).filter(s => s);
           }

           const publisherCountryField = card.querySelector('[data-field="publisherCountry"]');
           if (publisherCountryField) {
               game.publisherCountry = publisherCountryField.value.split(',').map(s => s.trim()).filter(s => s);
           }

           const bestPlayersField = card.querySelector('[data-field="bestPlayerCount"]');
           if (bestPlayersField) {
               game.bestPlayerCount = bestPlayersField.value.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
           }

const imageInputs = card.querySelectorAll('.edit-image-item input');
game.images = Array.from(imageInputs).map(input => input.value.trim()).filter(url => url);

const categoryField = card.querySelector('[data-field="category"]');
if (categoryField) {
    game.category = categoryField.value.split(',').map(s => s.trim()).filter(s => s);
}

const mechanismsField = card.querySelector('[data-field="mechanisms"]');
if (mechanismsField) {
    game.mechanisms = mechanismsField.value.split(',').map(s => s.trim()).filter(s => s);
}
       });

this.saveToStorage();
this.updateDesignerFilter();
this.updatePublisherFilter();
this.updateDesignerNationalityFilter();
this.updateArtistFilter();
this.updateCategoryFilter();
this.updateMechanismsFilter();
this.toggleEditMode();
this.applyFilters();
alert('All changes saved successfully!');
   }

   discardAllChanges() {
       if (confirm('Discard all changes? This cannot be undone.')) {
           this.games.clear();
           this.gameBackups.forEach((game, id) => {
               this.games.set(id, game);
           });
           
           this.toggleEditMode();
           this.applyFilters();
       }
   }

cycleColumns() {
       const isMobile = window.innerWidth <= 768;
       const columnOptions = isMobile ? [1, 2, 3] : [1, 2, 3, 4, 5];
       const currentColumns = isMobile ? this.mobileColumns : this.currentColumns;
       let currentIndex = columnOptions.indexOf(currentColumns);
       if (currentIndex === -1) currentIndex = isMobile ? 1 : 4; // Default to 2 mobile, 5 desktop
       const nextIndex = (currentIndex + 1) % columnOptions.length;
       const newColumns = columnOptions[nextIndex];
       
       if (isMobile) {
           this.mobileColumns = newColumns;
       } else {
           this.currentColumns = newColumns;
       }
       this.setColumns(newColumns);
   }

setColumns(cols) {
       const grid = document.getElementById('game-grid');
       grid.className = `game-grid cols-${cols}`;
       
       const colText = `${cols} Column${cols !== 1 ? 's' : ''}`;
       const desktopBtn = document.getElementById('columns-btn');
       const mobileBtn = document.getElementById('mobile-columns-btn');
       
       if (desktopBtn) desktopBtn.textContent = colText;
       if (mobileBtn) mobileBtn.textContent = colText;
   }

   deleteGameInEditMode(gameId) {
       if (confirm('Delete this game? This will be permanent when you save changes.')) {
           this.games.delete(gameId);
           this.render();
       }
   }

   addImageToGame(button) {
       const imageHtml = `
           <div class="edit-image-item">
               <input type="text" value="" placeholder="Image URL">
               <button onclick="this.parentElement.remove()">×</button>
           </div>
       `;
       button.parentElement.insertAdjacentHTML('beforeend', imageHtml);
   }

clearFilters() {
       if (this.isSharedView) {
           // Reset to original shared filters
           this.currentFilters = JSON.parse(JSON.stringify(this.originalSharedFilters || {}));
           this.applyFiltersToUI(this.currentFilters);
           document.getElementById('sort-field').value = this.originalSharedSortField || 'name';
           document.getElementById('sort-order').value = this.originalSharedSortOrder || 'asc';
           this.applyFilters();
           return;
       }
       
       // Original clear behavior for personal collections
document.getElementById('search').value = '';
       document.getElementById('mobile-search').value = '';
       document.getElementById('min-players').value = '';
       document.getElementById('max-players').value = '';
       document.getElementById('min-playtime').value = '';
       document.getElementById('max-playtime').value = '';
       document.getElementById('year-filter').value = '';
document.getElementById('date-acquired-filter').value = '';
       document.getElementById('publisher-filter').value = '';
       document.getElementById('designer-contains-filter').value = '';
       document.getElementById('designer-nationality-contains-filter').value = '';
       document.getElementById('designer-nationality-filter').value = '';
       document.getElementById('artist-filter').value = '';
       document.getElementById('artist-contains-filter').value = '';
document.getElementById('publisher-country-filter').value = '';
document.getElementById('description-filter').value = '';
document.getElementById('category-contains-filter').value = '';
document.getElementById('mechanisms-contains-filter').value = '';
document.getElementById('designer-filter').value = '';
document.getElementById('designer-nationality-filter').value = '';
document.getElementById('artist-filter').value = '';
document.getElementById('publisher-dropdown-filter').value = '';
document.getElementById('category-filter').value = '';
document.getElementById('mechanisms-filter').value = '';
document.getElementById('notes-filter').value = '';
document.getElementById('notes-filter-type').value = 'contains';
document.getElementById('description-filter-type').value = 'contains';

// Reset dynamic card fields when clearing filters
this.dynamicCardFields = [];
document.getElementById('min-weight').value = '';
document.getElementById('max-weight').value = '';
document.getElementById('best-player-count-filter').value = '';

document.getElementById('custom-filters-container').innerHTML = '';

this.currentFilters = {};
this.customFilters = [];
this.applyFilters();
   }

   applyFilters() {
       this.updateFilters();
       
       let filtered = Array.from(this.games.values());

if (this.currentFilters.search) {
    const search = this.currentFilters.search.toLowerCase();
    filtered = filtered.filter(game => 
        game.name.toLowerCase().includes(search) ||
        (game.notes && game.notes.toLowerCase().includes(search)) ||
        (game.description && game.description.toLowerCase().includes(search)) ||
        (game.designers && game.designers.some(d => d.toLowerCase().includes(search))) ||
(game.publishers && game.publishers.some(p => p.toLowerCase().includes(search))) ||
        (game.category && game.category.some(c => c.toLowerCase().includes(search))) ||
        (game.mechanisms && game.mechanisms.some(m => m.toLowerCase().includes(search)))
    );
}

       if (this.currentFilters.minPlayers) {
           const type = this.currentFilters.minPlayersType;
           const value = this.currentFilters.minPlayers;
           filtered = filtered.filter(game => {
               if (!game.players) return false;
               if (type === 'exact') return game.players.min === value;
               if (type === 'greater') return game.players.max >= value;
               if (type === 'less') return game.players.min <= value;
               return true;
           });
       }

       if (this.currentFilters.maxPlayers) {
           const type = this.currentFilters.maxPlayersType;
           const value = this.currentFilters.maxPlayers;
           filtered = filtered.filter(game => {
               if (!game.players) return false;
               if (type === 'exact') return game.players.max === value;
               if (type === 'less') return game.players.min <= value;
               if (type === 'greater') return game.players.max >= value;
               return true;
           });
       }

       if (this.currentFilters.minPlaytime) {
           const type = this.currentFilters.minPlaytimeType;
           const value = this.currentFilters.minPlaytime;
           filtered = filtered.filter(game => {
               if (!game.playtime) return false;
               if (type === 'exact') return game.playtime.min === value;
               if (type === 'greater') return game.playtime.max >= value;
               if (type === 'less') return game.playtime.min <= value;
               return true;
           });
       }

       if (this.currentFilters.maxPlaytime) {
           const type = this.currentFilters.maxPlaytimeType;
           const value = this.currentFilters.maxPlaytime;
           filtered = filtered.filter(game => {
               if (!game.playtime) return false;
               if (type === 'exact') return game.playtime.max === value;
               if (type === 'less') return game.playtime.min <= value;
               if (type === 'greater') return game.playtime.max >= value;
               return true;
           });
       }

if (this.currentFilters.year) {
           const type = this.currentFilters.yearType;
           const value = this.currentFilters.year;
           filtered = filtered.filter(game => {
               if (!game.year) return false;
               if (type === 'exact') return game.year === value;
               if (type === 'greater') return game.year > value;
               if (type === 'less') return game.year < value;
               return true;
           });
       }

if (this.currentFilters.dateAcquired) {
           const type = this.currentFilters.dateAcquiredType;
           const filterDate = new Date(this.currentFilters.dateAcquired);
           filtered = filtered.filter(game => {
               if (!game.dateAcquired) return false;
               const gameDate = new Date(game.dateAcquired);
               if (type === 'exact') return gameDate.getFullYear() === filterDate.getFullYear();
               if (type === 'greater') return gameDate > filterDate;
               if (type === 'less') return gameDate < filterDate;
               return true;
           });
       }

       if (this.currentFilters.minWeight) {
           const type = this.currentFilters.minWeightType;
           const value = this.currentFilters.minWeight;
           filtered = filtered.filter(game => {
               if (game.weight === null || game.weight === undefined) return false;
               if (type === 'exact') return Math.abs(game.weight - value) < 0.1;
               if (type === 'greater') return game.weight > value;
               return true;
           });
       }

       if (this.currentFilters.maxWeight) {
           const type = this.currentFilters.maxWeightType;
           const value = this.currentFilters.maxWeight;
           filtered = filtered.filter(game => {
               if (game.weight === null || game.weight === undefined) return false;
               if (type === 'exact') return Math.abs(game.weight - value) < 0.1;
               if (type === 'less') return game.weight < value;
               return true;
           });
       }

       if (this.currentFilters.publisher) {
           const type = this.currentFilters.publisherType;
           const value = this.currentFilters.publisher.toLowerCase();
           filtered = filtered.filter(game => {
               if (!game.publishers) return false;
               const publisherText = game.publishers.join(' ').toLowerCase();
               if (type === 'contains') return publisherText.includes(value);
               if (type === 'exact') return game.publishers.some(p => p.toLowerCase() === value);
               if (type === 'not-contains') return !publisherText.includes(value);
               return true;
           });
       }

       if (this.currentFilters.designer) {
           filtered = filtered.filter(game => {
               if (!game.designers) return false;
               return game.designers.includes(this.currentFilters.designer);
           });
       }

if (this.currentFilters.publisherDropdown) {
           filtered = filtered.filter(game => {
               if (!game.publishers) return false;
               return game.publishers.includes(this.currentFilters.publisherDropdown);
           });
       }

       if (this.currentFilters.designerContains) {
           const type = this.currentFilters.designerContainsType;
           const value = this.currentFilters.designerContains.toLowerCase();
           filtered = filtered.filter(game => {
               if (!game.designers) return false;
               const designerText = game.designers.join(' ').toLowerCase();
               if (type === 'contains') return designerText.includes(value);
               if (type === 'exact') return game.designers.some(d => d.toLowerCase() === value);
               if (type === 'not-contains') return !designerText.includes(value);
               return true;
           });
       }

if (this.currentFilters.designerNationalityContains) {
           const type = this.currentFilters.designerNationalityContainsType;
           const value = this.currentFilters.designerNationalityContains.toLowerCase();
           filtered = filtered.filter(game => {
               if (!game.designerNationality) return false;
               const nationalityText = Array.isArray(game.designerNationality) ? 
                   game.designerNationality.join(' ').toLowerCase() : 
                   game.designerNationality.toLowerCase();
               if (type === 'contains') return nationalityText.includes(value);
               if (type === 'exact') return nationalityText === value;
               if (type === 'not-contains') return !nationalityText.includes(value);
               return true;
           });
       }

       if (this.currentFilters.designerNationality) {
           filtered = filtered.filter(game => {
               if (!game.designerNationality) return false;
               const nationalities = Array.isArray(game.designerNationality) ? 
                   game.designerNationality : game.designerNationality.split(',').map(s => s.trim());
               return nationalities.includes(this.currentFilters.designerNationality);
           });
       }

       if (this.currentFilters.artist) {
           filtered = filtered.filter(game => {
               if (!game.artists) return false;
               return game.artists.includes(this.currentFilters.artist);
           });
       }

       if (this.currentFilters.artistContains) {
           const type = this.currentFilters.artistContainsType;
           const value = this.currentFilters.artistContains.toLowerCase();
           filtered = filtered.filter(game => {
               if (!game.artists) return false;
               const artistText = game.artists.join(' ').toLowerCase();
               if (type === 'contains') return artistText.includes(value);
               if (type === 'exact') return game.artists.some(a => a.toLowerCase() === value);
               if (type === 'not-contains') return !artistText.includes(value);
               return true;
           });
       }

if (this.currentFilters.publisherCountry) {
           const type = this.currentFilters.publisherCountryType;
           const value = this.currentFilters.publisherCountry.toLowerCase();
           filtered = filtered.filter(game => {
               if (!game.publisherCountry) return false;
               const countryText = Array.isArray(game.publisherCountry) ? 
                   game.publisherCountry.join(' ').toLowerCase() : 
                   game.publisherCountry.toLowerCase();
               if (type === 'contains') return countryText.includes(value);
               if (type === 'exact') return countryText === value;
               if (type === 'not-contains') return !countryText.includes(value);
               return true;
           });
       }

if (this.currentFilters.notes) {
    const type = this.currentFilters.notesType;
    const value = this.currentFilters.notes.toLowerCase();
    filtered = filtered.filter(game => {
        if (!game.notes) return false;
        const notesText = game.notes.toLowerCase();
        if (type === 'contains') return notesText.includes(value);
        if (type === 'exact') return notesText === value;
        if (type === 'not-contains') return !notesText.includes(value);
        return true;
    });
}

if (this.currentFilters.description) {
    const type = this.currentFilters.descriptionType;
    const value = this.currentFilters.description.toLowerCase();
    filtered = filtered.filter(game => {
        const desc = (game.description || '').toLowerCase();
        if (!desc.trim()) return false;
        if (type === 'contains') return desc.includes(value);
        if (type === 'exact') return desc === value;
        if (type === 'not-contains') return !desc.includes(value);
        return true;
    });
}


if (this.currentFilters.category) {
    filtered = filtered.filter(game => {
        if (!game.category) return false;
        return game.category.includes(this.currentFilters.category);
    });
}

if (this.currentFilters.categoryContains) {
    const type = this.currentFilters.categoryContainsType;
    const value = this.currentFilters.categoryContains.toLowerCase();
    filtered = filtered.filter(game => {
        if (!game.category) return false;
        const categoryText = game.category.join(' ').toLowerCase();
        if (type === 'contains') return categoryText.includes(value);
        if (type === 'exact') return game.category.some(c => c.toLowerCase() === value);
        if (type === 'not-contains') return !categoryText.includes(value);
        return true;
    });
}

if (this.currentFilters.mechanisms) {
    filtered = filtered.filter(game => {
        if (!game.mechanisms) return false;
        return game.mechanisms.includes(this.currentFilters.mechanisms);
    });
}

if (this.currentFilters.mechanismsContains) {
    const type = this.currentFilters.mechanismsContainsType;
    const value = this.currentFilters.mechanismsContains.toLowerCase();
    filtered = filtered.filter(game => {
        if (!game.mechanisms) return false;
        const mechanismsText = game.mechanisms.join(' ').toLowerCase();
        if (type === 'contains') return mechanismsText.includes(value);
        if (type === 'exact') return game.mechanisms.some(m => m.toLowerCase() === value);
        if (type === 'not-contains') return !mechanismsText.includes(value);
        return true;
    });
}

       if (this.currentFilters.bestPlayerCount) {
           const counts = this.currentFilters.bestPlayerCount.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
           if (counts.length > 0) {
               filtered = filtered.filter(game => {
                   if (!game.bestPlayerCount || game.bestPlayerCount.length === 0) return false;
                   return counts.some(count => game.bestPlayerCount.includes(count));
               });
           }
       }

       this.customFilters.forEach(filter => {
           filtered = filtered.filter(game => {
               let gameValue;
               
               if (filter.field.includes('.')) {
                   const [field, subField] = filter.field.split('.');
                   gameValue = game[field] ? game[field][subField] : null;
               } else {
                   gameValue = game[filter.field];
               }

               if (gameValue === null || gameValue === undefined) return false;

               const filterValue = filter.value.toLowerCase();
               
               if (Array.isArray(gameValue)) {
                   const arrayText = gameValue.join(' ').toLowerCase();
                   switch (filter.type) {
                       case 'contains': return arrayText.includes(filterValue);
                       case 'exact': return gameValue.some(v => v.toLowerCase() === filterValue);
                       case 'not-contains': return !arrayText.includes(filterValue);
                       default: return false;
                   }
               } else if (typeof gameValue === 'string') {
                   const stringValue = gameValue.toLowerCase();
                   switch (filter.type) {
                       case 'contains': return stringValue.includes(filterValue);
                       case 'exact': return stringValue === filterValue;
                       case 'not-contains': return !stringValue.includes(filterValue);
                       default: return false;
                   }
               } else if (typeof gameValue === 'number') {
                   const numValue = parseFloat(filter.value);
                   if (isNaN(numValue)) return false;
                   switch (filter.type) {
                       case 'exact': return gameValue === numValue;
                       case 'greater': return gameValue > numValue;
                       case 'less': return gameValue < numValue;
                       case 'greater-equal': return gameValue >= numValue;
                       case 'less-equal': return gameValue <= numValue;
                       case 'contains': return gameValue.toString().includes(filter.value);
                       default: return false;
                   }
               }
               
               return false;
           });
       });

// Always include thumbs up games, even if they don't match filters
const thumbsUpGames = Array.from(this.games.values()).filter(game => 
    this.gamePreferences.get(game.bggId) === 'up'
);

// Apply thumb preferences to filtered games (hide thumbs down)
filtered = filtered.filter(game => {
    const preference = this.gamePreferences.get(game.bggId);
    if (preference === 'down') return false; // Hide thumbs down
    return true; // Show everything else (neutral)
});

// Combine thumbs up games with filtered games, removing duplicates
const filteredIds = new Set(filtered.map(game => game.bggId));
const uniqueThumbsUp = thumbsUpGames.filter(game => !filteredIds.has(game.bggId));
filtered = [...thumbsUpGames.filter(game => filteredIds.has(game.bggId)), ...uniqueThumbsUp, ...filtered.filter(game => this.gamePreferences.get(game.bggId) !== 'up')];

const sortField = document.getElementById('sort-field').value;
       const sortOrder = document.getElementById('sort-order').value;

       filtered.sort((a, b) => {
           let aVal, bVal;

           if (sortField.includes('.')) {
               const [field, subField] = sortField.split('.');
               aVal = a[field] ? a[field][subField] : 0;
               bVal = b[field] ? b[field][subField] : 0;
           } else {
               aVal = a[sortField];
               bVal = b[sortField];
           }

           if (typeof aVal === 'string') {
               aVal = aVal.toLowerCase();
               bVal = bVal.toLowerCase();
               // Remove "The " from beginning for sorting
               if (sortField === 'name') {
                   aVal = aVal.replace(/^the\s+/, '');
                   bVal = bVal.replace(/^the\s+/, '');
               }
           }

           if (aVal < bVal) return sortOrder === 'asc' ? -1 : 1;
           if (aVal > bVal) return sortOrder === 'asc' ? 1 : -1;
           return 0;
       });

       this.filteredGames = filtered;
       this.render();
   }

   async fetchBGGData() {
       const url = document.getElementById('bgg-url').value;
       if (!url) return;

       const loadingEl = document.getElementById('loading-indicator');
       const errorEl = document.getElementById('error-message');
       
       loadingEl.style.display = 'block';
       errorEl.style.display = 'none';

       try {
           const bggIdMatch = url.match(/\/boardgame\/(\d+)/);
           if (!bggIdMatch) {
               throw new Error('Invalid BoardGameGeek URL');
           }

           const bggId = bggIdMatch[1];
           
           const controller = new AbortController();
           const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout
           
           const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(`https://boardgamegeek.com/xmlapi2/thing?id=${bggId}&stats=1`)}`, {
               signal: controller.signal
           });
           
           clearTimeout(timeoutId);
           const data = await response.json();
           
           if (!response.ok) {
               throw new Error('Failed to fetch from BoardGameGeek');
           }

           const parser = new DOMParser();
           const xmlDoc = parser.parseFromString(data.contents, 'text/xml');
           const item = xmlDoc.querySelector('item');

           if (!item) {
               throw new Error('Game not found on BoardGameGeek');
           }

           const name = item.querySelector('name[type="primary"]')?.getAttribute('value') || '';
           const year = parseInt(item.querySelector('yearpublished')?.getAttribute('value')) || '';
           const minPlayers = parseInt(item.querySelector('minplayers')?.getAttribute('value')) || 1;
           const maxPlayers = parseInt(item.querySelector('maxplayers')?.getAttribute('value')) || 1;
           const playtime = parseInt(item.querySelector('playingtime')?.getAttribute('value')) || 0;
           const weight = parseFloat(item.querySelector('statistics averageweight')?.getAttribute('value')) || 0;

           const bestPlayerCount = [];
           const polls = item.querySelectorAll('poll[name="suggested_numplayers"] results');
           polls.forEach(result => {
               const numPlayers = result.getAttribute('numplayers');
               const best = result.querySelector('result[value="Best"]');
               const numVotes = best ? parseInt(best.getAttribute('numvotes')) : 0;
               if (numVotes > 0 && numPlayers !== '+') {
                   bestPlayerCount.push(parseInt(numPlayers));
               }
           });

           const designers = Array.from(item.querySelectorAll('link[type="boardgamedesigner"]')).map(el => el.getAttribute('value'));
           const artists = Array.from(item.querySelectorAll('link[type="boardgameartist"]')).map(el => el.getAttribute('value'));
           const publishers = Array.from(item.querySelectorAll('link[type="boardgamepublisher"]')).map(el => el.getAttribute('value'));
           const primaryImage = item.querySelector('image')?.textContent || '';
           const thumbnail = item.querySelector('thumbnail')?.textContent || '';
const images = [primaryImage, thumbnail].filter(img => img && img !== primaryImage || img === primaryImage);



const description = item.querySelector('description')?.textContent?.trim() || '';

const categories = Array.from(item.querySelectorAll('link[type="boardgamecategory"]')).map(el => el.getAttribute('value'));
const mechanisms = Array.from(item.querySelectorAll('link[type="boardgamemechanic"]')).map(el => el.getAttribute('value'));


// Set default weight color based on complexity
let defaultWeightColor = '#008000';
if (weight >= 2.5) {
    defaultWeightColor = '#ff0000';
} else if (weight >= 1.9) {
    defaultWeightColor = '#cfa200';
}

           document.getElementById('game-name').value = name;
           document.getElementById('game-year').value = year;
           document.getElementById('game-min-players').value = minPlayers;
           document.getElementById('game-max-players').value = maxPlayers;
           document.getElementById('game-playtime').value = playtime;
           document.getElementById('game-weight').value = weight.toFixed(1);
           document.getElementById('game-best-players').value = bestPlayerCount.join(', ');
document.getElementById('game-designers').value = designers.join(', ');
document.getElementById('game-artists').value = artists.join(', ');
document.getElementById('game-publishers').value = publishers.join(', ');
document.getElementById('game-images').value = images.join('\n');
document.getElementById('game-description').value = description;
document.getElementById('game-category').value = categories.join(', ');
document.getElementById('game-mechanisms').value = mechanisms.join(', ');

// Set the weight color dropdown if it exists
           const weightColorSelect = document.getElementById('game-weight-color');
           if (weightColorSelect) {
               weightColorSelect.value = defaultWeightColor;
           }

       } catch (error) {
           if (error.name === 'AbortError') {
               errorEl.textContent = 'Request timed out. BGG might be slow, please try again.';
           } else {
               errorEl.textContent = error.message;
           }
           errorEl.style.display = 'block';
       } finally {
           loadingEl.style.display = 'none';
       }
   }

   saveGame() {
const formData = {
           bggId: Date.now().toString(),
           bggUrl: document.getElementById('bgg-url').value,
           name: document.getElementById('game-name').value,
           year: parseInt(document.getElementById('game-year').value) || null,
dateAcquired: document.getElementById('game-date-acquired').value || '1991-11-19',
           players: {
               min: parseInt(document.getElementById('game-min-players').value) || 1,
               max: parseInt(document.getElementById('game-max-players').value) || 1
           },
           playtime: {
               min: parseInt(document.getElementById('game-playtime').value) || 0,
               max: parseInt(document.getElementById('game-playtime').value) || 0
           },
weight: parseFloat(document.getElementById('game-weight').value) || 0,
weightColor: document.getElementById('game-weight-color').value || '#008000',
           bestPlayerCount: document.getElementById('game-best-players').value.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n)),
           designers: document.getElementById('game-designers').value.split(',').map(s => s.trim()).filter(s => s),
           artists: document.getElementById('game-artists').value.split(',').map(s => s.trim()).filter(s => s),
publishers: document.getElementById('game-publishers').value.split(',').map(s => s.trim()).filter(s => s),
designerNationality: document.getElementById('game-designer-nationality').value.split(',').map(s => s.trim()).filter(s => s),
           publisherCountry: document.getElementById('game-publisher-country').value.split(',').map(s => s.trim()).filter(s => s),
images: document.getElementById('game-images').value.split('\n').map(s => s.trim()).filter(s => s),
notes: document.getElementById('game-notes').value,
description: document.getElementById('game-description').value,
category: document.getElementById('game-category').value.split(',').map(s => s.trim()).filter(s => s),
mechanisms: document.getElementById('game-mechanisms').value.split(',').map(s => s.trim()).filter(s => s),
customFields: {}
       };

       if (!formData.name) {
           alert('Game name is required');
           return;
       }

this.games.set(formData.bggId, formData);
this.saveToStorage();
this.updateDesignerFilter();
this.updatePublisherFilter();
this.updateDesignerNationalityFilter();
this.updateArtistFilter();
this.updateCategoryFilter();
this.updateMechanismsFilter();
this.closeForm();
this.applyFilters();
   }

closeForm() {
       document.getElementById('add-game-form').classList.remove('show');
document.getElementById('add-game-form').querySelectorAll('input, textarea').forEach(input => {
    input.value = '';
});
       document.getElementById('add-game-form').querySelectorAll('select').forEach(select => {
           select.selectedIndex = 0;
       });
       document.getElementById('error-message').style.display = 'none';
   }

   render() {
       const container = document.getElementById('game-grid');
       const emptyState = document.getElementById('empty-state');
       const resultsInfo = document.getElementById('results-info');

       if (this.filteredGames.length === 0) {
           container.innerHTML = '';
           emptyState.style.display = 'block';
           resultsInfo.textContent = '';
           return;
       }

       emptyState.style.display = 'none';
       resultsInfo.textContent = `Showing ${this.filteredGames.length} of ${this.games.size} games`;

       container.innerHTML = this.filteredGames.map(game => {
           return this.isEditMode ? this.renderEditGameCard(game) : this.renderGameCard(game);
       }).join('');
       
       if (!this.isEditMode) {
           this.filteredGames.forEach((game, index) => {
               if (game.images && game.images.length > 0) {
                   new Swiper(`#swiper-${game.bggId}`, {
                       navigation: {
                           nextEl: `#swiper-${game.bggId} .swiper-button-next`,
                           prevEl: `#swiper-${game.bggId} .swiper-button-prev`,
                       },

pagination: {
                           el: `#swiper-${game.bggId} .swiper-pagination`,
                           clickable: true,
                       },
                       loop: game.images.length > 1,
                       autoHeight: true,
                   });
               }
           });

           container.querySelectorAll('.details-toggle').forEach(btn => {
               btn.addEventListener('click', (e) => {
                   const content = e.target.nextElementSibling;
                   content.classList.toggle('show');
                   const icon = e.target.querySelector('.toggle-icon');
                   icon.textContent = content.classList.contains('show') ? '▼' : '▶';
               });
           });
       }
   }

   renderGameCard(game) {
       const playerRange = game.players ? `${game.players.min}-${game.players.max}` : 'Unknown';
       const playtimeText = game.playtime ? `${game.playtime.min}${game.playtime.min !== game.playtime.max ? `-${game.playtime.max}` : ''} min` : 'Unknown';
       
       const allVisibleFields = [...new Set([...this.cardVisibleFields, ...this.dynamicCardFields])];
       
       const imagesHtml = game.images && game.images.length > 0 ? `
           <div class="swiper" id="swiper-${game.bggId}">
               <div class="swiper-wrapper">
                   ${game.images.map(img => `
                       <div class="swiper-slide">
                           <img src="${img}" alt="${game.name}" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjBmMGYwIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPk5vIEltYWdlPC90ZXh0Pjwvc3ZnPg=='">
                       </div>
                   `).join('')}
               </div>
               ${game.images.length > 1 ? `
                   <div class="swiper-button-next" onclick="event.stopPropagation();"></div>
                   <div class="swiper-button-prev" onclick="event.stopPropagation();"></div>
                   <div class="swiper-pagination"></div>
               ` : ''}
           </div>
       ` : `
           <div style="height: 200px; background: #f0f0f0; display: flex; align-items: center; justify-content: center; color: #999;">
               No Image
           </div>
       `;

       const metaItems = [];
       
if (allVisibleFields.includes('year') && game.year) {
           metaItems.push(`<div class="meta-item"><span class="meta-label">Year:</span><span>${game.year}</span></div>`);
       }
if (allVisibleFields.includes('dateAcquired') && game.dateAcquired && !this.isSharedView) {
           const dateParts = game.dateAcquired.split('-');
           const acquiredDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
           const formattedDate = acquiredDate.toLocaleDateString('en-US');
           metaItems.push(`<div class="meta-item"><span class="meta-label">Acquired:</span><span>${formattedDate}</span></div>`);
       }
       if (allVisibleFields.includes('players')) {
           metaItems.push(`<div class="meta-item"><span class="meta-label">Players:</span><span>${playerRange}</span></div>`);
       }
       if (allVisibleFields.includes('playtime')) {
           metaItems.push(`<div class="meta-item"><span class="meta-label">Time:</span><span>${playtimeText}</span></div>`);
       }
if (allVisibleFields.includes('weight') && game.weight) {
const weightColor = game.weightColor || '#008000';
metaItems.push(`<div class="meta-item"><span class="meta-label">Weight:</span><span style="color: ${weightColor === '#cfa200' ? '#cfa200' : weightColor};">${game.weight.toFixed(1)}</span><span class="complexity-tooltip"><i class="fa-solid fa-circle-info"></i><span class="tooltiptext"><span style="color: #008000;">Green means easy, ok for non-gamers/kids</span><br><span style="color: #cfa200;">Yellow means too much for above, but normal for most people</span><br><span style="color: #ff0000;">Red means gamers only, higher strategy, full weight</span></span></span></div>`);
       }
       if (allVisibleFields.includes('publishers') && game.publishers?.length > 0) {
           metaItems.push(`<div class="meta-item"><span class="meta-label">Publisher:</span><span>${game.publishers[0]}</span></div>`);
       }
       if (allVisibleFields.includes('bestPlayerCount') && game.bestPlayerCount?.length > 0) {
           metaItems.push(`<div class="meta-item"><span class="meta-label">Best:</span><span>${game.bestPlayerCount.join(', ')}</span></div>`);
       }

const preference = this.gamePreferences.get(game.bggId);
const thumbsHtml = `
    <div class="thumb-buttons">
        <button class="thumb-btn thumb-up ${preference === 'up' ? 'active' : ''}" 
                onclick="event.stopPropagation(); boardGameApp.setGamePreference('${game.bggId}', 'up')">
            <i class="fa-solid fa-thumbtack"></i>
        </button>
        <button class="thumb-btn thumb-down ${preference === 'down' ? 'active' : ''}" 
                onclick="event.stopPropagation(); boardGameApp.setGamePreference('${game.bggId}', 'down')">
            <i class="fa-solid fa-eye-slash"></i>
        </button>
    </div>
`;

return `
    <div class="game-card" data-game-id="${game.bggId}" onclick="boardGameApp.openGameModal('${game.bggId}')" style="cursor: pointer;">
        <div class="image-carousel">
            ${imagesHtml}
        </div>
        <div class="game-info">
            <h3 class="game-title">${game.name}</h3>
            ${metaItems.length > 0 ? `
                <div class="game-meta">
                    ${metaItems.join('')}
                </div>
            ` : ''}
        </div>
        ${thumbsHtml}
    </div>
`;
   }

   renderEditGameCard(game) {
       const addImageButton = (index) => `
           <div class="edit-image-item">
               <input type="text" value="${game.images && game.images[index] ? game.images[index] : ''}" placeholder="Image URL">
               <button onclick="this.parentElement.remove()">×</button>
           </div>
       `;

       const imagesHtml = `
           <div class="edit-images">
               ${game.images && game.images.length > 0 ? 
                   game.images.map((img, index) => addImageButton(index)).join('') :
                   addImageButton(0)
               }
               <button class="add-image-btn" onclick="boardGameApp.addImageToGame(this)">Add Image</button>
           </div>
       `;

       return `
           <div class="game-card edit-mode" data-game-id="${game.bggId}">
               <div class="edit-expanded">


<div class="edit-section">
    <h4>Basic Information</h4>
    <div class="edit-row">
        <div class="edit-group">
            <label>Game Name</label>
            <input type="text" class="edit-field" data-field="name" value="${game.name || ''}">
        </div>
    </div>
<div class="edit-row">
    <div class="edit-group">
        <label>Notes</label>
        <textarea class="edit-field" data-field="notes" rows="3" placeholder="Your thoughts about this game...">${game.notes || ''}</textarea>
    </div>
</div>
<div class="edit-row">
    <div class="edit-group">
        <label>Description</label>
        <textarea class="edit-field" data-field="description" rows="4" placeholder="Game description...">${game.description || ''}</textarea>
    </div>
</div>
<div class="edit-row">
    <div class="edit-group">
        <label>Category</label>
        <input type="text" class="edit-field" data-field="category" value="${Array.isArray(game.category) ? game.category.join(', ') : (game.category || '')}" placeholder="Strategy, Family, Party, etc.">
    </div>
    <div class="edit-group">
        <label>Mechanisms</label>
        <input type="text" class="edit-field" data-field="mechanisms" value="${Array.isArray(game.mechanisms) ? game.mechanisms.join(', ') : (game.mechanisms || '')}" placeholder="Dice Rolling, Worker Placement, etc.">
    </div>
</div>
                       <div class="edit-row">
<div class="edit-group">
                               <label>Year Published</label>
                               <input type="number" class="edit-field" data-field="year" value="${game.year || ''}" min="1900" max="2030">
                           </div>
<div class="edit-group">
                               <label>Date Acquired</label>
                               <input type="date" class="edit-field" data-field="dateAcquired" value="${game.dateAcquired || '1991-11-19'}">
                           </div>
                       </div>
                       <div class="edit-row">
                           <div class="edit-group">
                               <label>Min Players</label>
                               <input type="number" class="edit-field" data-field="players.min" value="${game.players?.min || 1}" min="1">
                           </div>
                           <div class="edit-group">
                               <label>Max Players</label>
                               <input type="number" class="edit-field" data-field="players.max" value="${game.players?.max || 1}" min="1">
                           </div>
                           <div class="edit-group">
                               <label>Min Playtime</label>
                               <input type="number" class="edit-field" data-field="playtime.min" value="${game.playtime?.min || 0}" min="0">
                           </div>
                           <div class="edit-group">
                               <label>Max Playtime</label>
                               <input type="number" class="edit-field" data-field="playtime.max" value="${game.playtime?.max || 0}" min="0">
                           </div>
                       </div>
                       <div class="edit-row">
                           <div class="edit-group">
                               <label>Complexity (1-5)</label>
                               <div style="display: flex; gap: 0.5rem;">
                                   <input type="number" class="edit-field" data-field="weight" value="${game.weight || ''}" min="0" max="5" step="0.1" style="flex: 1;">
<select class="edit-field" data-field="weightColor" style="width: 100px;">
<option value="#008000" ${(game.weightColor || '#008000') === '#008000' ? 'selected' : ''}>Green</option>
<option value="#cfa200" ${(game.weightColor || '#008000') === '#cfa200' ? 'selected' : ''}>Yellow</option>
<option value="#ff0000" ${(game.weightColor || '#008000') === '#ff0000' ? 'selected' : ''}>Red</option>
</select>
                               </div>
                           </div>
                           <div class="edit-group">
                               <label>Best Player Count</label>
                               <input type="text" class="edit-field" data-field="bestPlayerCount" value="${game.bestPlayerCount ? game.bestPlayerCount.join(', ') : ''}" placeholder="2,3,4">
                           </div>
                       </div>
                   </div>
                   
                   <div class="edit-section">
                       <h4>People</h4>
                       <div class="edit-row">
                           <div class="edit-group">
                               <label>Designers</label>
                               <input type="text" class="edit-field" data-field="designers" value="${game.designers ? game.designers.join(', ') : ''}" placeholder="Comma separated">
                           </div>
                           <div class="edit-group">
                               <label>Artists</label>
                               <input type="text" class="edit-field" data-field="artists" value="${game.artists ? game.artists.join(', ') : ''}" placeholder="Comma separated">
                           </div>
<div class="edit-group">
                               <label>Publishers</label>
                               <input type="text" class="edit-field" data-field="publishers" value="${game.publishers ? game.publishers.join(', ') : ''}" placeholder="Comma separated">
                           </div>
<div class="edit-group">
                               <label>Designer Nationality</label>
                               <input type="text" class="edit-field" data-field="designerNationality" value="${Array.isArray(game.designerNationality) ? game.designerNationality.join(', ') : (game.designerNationality || '')}" placeholder="Comma separated">
                           </div>
                           <div class="edit-group">
                               <label>Publisher Country</label>
                               <input type="text" class="edit-field" data-field="publisherCountry" value="${Array.isArray(game.publisherCountry) ? game.publisherCountry.join(', ') : (game.publisherCountry || '')}" placeholder="Comma separated">
                           </div>
        <div class="edit-group">
            <label>BoardGameGeek URL</label>
            <input type="url" class="edit-field" data-field="bggUrl" value="${game.bggUrl || ''}" placeholder="https://boardgamegeek.com/boardgame/...">
        </div>
                       </div>
                   </div>


<div class="edit-section">
                       <h4>Images</h4>
                       ${imagesHtml}
                   </div>

                   <button class="delete-game-btn" onclick="boardGameApp.deleteGameInEditMode('${game.bggId}')">Delete Game</button>
               </div>
           </div>
       `;
   }

   openGameModal(gameId) {
       if (this.isEditMode) return;
       
       const game = this.games.get(gameId);
       if (!game) return;
       
       const modal = document.getElementById('game-modal');
       const content = document.getElementById('modal-game-content');
       
       content.innerHTML = this.renderGameModalContent(game);
       modal.style.display = 'block';
       
       if (game.images && game.images.length > 0) {
           new Swiper('#modal-swiper', {
               navigation: {
                   nextEl: '#modal-swiper .swiper-button-next',
                   prevEl: '#modal-swiper .swiper-button-prev',
               },
               pagination: {
                   el: '#modal-swiper .swiper-pagination',
                   clickable: true,
               },
               loop: game.images.length > 1,
           });
           
           document.querySelectorAll('#modal-swiper .swiper-slide img').forEach(img => {
               img.addEventListener('click', () => {
                   this.openLightbox(game);
               });
           });
       }
   }

   renderGameModalContent(game) {
       const playerRange = game.players ? `${game.players.min}-${game.players.max}` : 'Unknown';
       const playtimeText = game.playtime ? `${game.playtime.min}${game.playtime.min !== game.playtime.max ? `-${game.playtime.max}` : ''} min` : 'Unknown';
       
       const imagesHtml = game.images && game.images.length > 0 ? `
           <div class="swiper" id="modal-swiper" style="height: 300px; margin-bottom: 2rem;">
               <div class="swiper-wrapper">
                   ${game.images.map(img => `
                       <div class="swiper-slide">
                           <img src="${img}" alt="${game.name}" style="width: 100%; height: 100%; object-fit: contain; cursor: pointer;">
                       </div>
                   `).join('')}
               </div>
               ${game.images.length > 1 ? `
                   <div class="swiper-button-next"></div>
                   <div class="swiper-button-prev"></div>
                   <div class="swiper-pagination"></div>
               ` : ''}
           </div>
       ` : '';

const preference = this.gamePreferences.get(game.bggId);
const modalThumbsHtml = `
    <div class="modal-thumbs">
        <button class="thumb-btn thumb-up ${preference === 'up' ? 'active' : ''}" 
                onclick="boardGameApp.setGamePreference('${game.bggId}', 'up')">
            <i class="fa-solid fa-thumbtack"></i>
        </button>
        <button class="thumb-btn thumb-down ${preference === 'down' ? 'active' : ''}" 
                onclick="boardGameApp.setGamePreference('${game.bggId}', 'down')">
            <i class="fa-solid fa-eye-slash"></i>
        </button>
        <button class="thumb-btn" style="background: #667eea; margin-left: 5px;" 
                onclick="boardGameApp.editGameFromModal('${game.bggId}')" title="Edit Game">
            <i class="fa-solid fa-pen-to-square"></i>
        </button>
    </div>
`;

return `
    ${modalThumbsHtml}
    <h2>${game.name}</h2>
    ${imagesHtml}
           

<div style="display: flex; flex-wrap: wrap; gap: 2rem; margin-bottom: 2rem; align-items: center;">
               <div><strong>Year Published:</strong> ${game.year || 'Unknown'}</div>
               <div><strong>Players:</strong> ${playerRange}</div>
               <div><strong>Playtime:</strong> ${playtimeText}</div>
<div><strong>Complexity:</strong> ${game.weight ? `<span style="color: ${(game.weightColor || '#008000') === '#cfa200' ? '#cfa200' : (game.weightColor || '#008000')};">${game.weight.toFixed(1)}</span><span class="complexity-tooltip"><i class="fa-solid fa-circle-info"></i><span class="tooltiptext"><span style="color: #008000;">Green means easy, ok for non-gamers/kids</span><br><span style="color: #cfa200;">Yellow means too much for above, but normal for most people</span><br><span style="color: #ff0000;">Red means gamers only, higher strategy, full weight</span></span></span>` : 'N/A'}</div>
               ${game.bestPlayerCount && game.bestPlayerCount.length > 0 ? `<div><strong>Best with:</strong> ${game.bestPlayerCount.join(', ')} players</div>` : ''}
               ${game.bggUrl ? `<div><strong>BoardGameGeek:</strong> <a href="${game.bggUrl}" target="_blank" style="color: #667eea;">View on BGG</a></div>` : ''}
           </div>
           
           <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 2rem;">
<div class="modal-left-column">
${game.dateAcquired && !this.isSharedView ? `
                       <div style="margin-bottom: 1rem;">
                           <strong>Date Acquired:</strong> ${(() => {
                               const dateParts = game.dateAcquired.split('-');
                               const date = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
                               return date.toLocaleDateString('en-US');
                           })()}
                       </div>
                   ` : ''}
                   ${game.notes && !this.isSharedView ? `
                       <div>
                           <strong>Notes:</strong>
                           <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-top: 0.5rem;">
                               ${game.notes.replace(/\n/g, '<br>').replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" style="color: #667eea;">$1</a>')}
                           </div>
                       </div>
                   ` : ''}
               </div>
               
<div class="modal-right-column">
${game.description ? `
    <div style="margin-bottom: 1rem;">
        <strong>Description:</strong> 
        <span id="desc-short">${game.description.length > 100 ? game.description.substring(0, 100) + '...' : game.description}</span>
        ${game.description.length > 100 ? `
            <span style="color: #667eea; cursor: pointer; margin-left: 5px;" onclick="
                const shortDesc = document.getElementById('desc-short');
                const fullDesc = document.getElementById('desc-full');
                const isShowing = fullDesc.style.display !== 'none';
                if (isShowing) {
                    fullDesc.style.display = 'none';
                    shortDesc.style.display = 'inline';
                    this.textContent = 'More';
                } else {
                    fullDesc.style.display = 'inline';
                    shortDesc.style.display = 'none';
                    this.textContent = 'Less';
                }
            ">More</span>
            <span id="desc-full" style="display: none;">${game.description}</span>
        ` : ''}
    </div>
` : ''}

${game.category && game.category.length > 0 ? `
   <div style="margin-bottom: 1rem;">
       <strong>Category:</strong> 
       <span id="category-short">${game.category.slice(0, 3).join(', ')}${game.category.length > 3 ? '...' : ''}</span>
       ${game.category.length > 3 ? `
           <span style="color: #667eea; cursor: pointer; margin-left: 5px;" onclick="
               const shortCategory = document.getElementById('category-short');
               const fullCategory = document.getElementById('category-full');
               const isShowing = fullCategory.style.display !== 'none';
               if (isShowing) {
                   fullCategory.style.display = 'none';
                   shortCategory.style.display = 'inline';
                   this.textContent = 'More';
               } else {
                   fullCategory.style.display = 'inline';
                   shortCategory.style.display = 'none';
                   this.textContent = 'Less';
               }
           ">More</span>
           <span id="category-full" style="display: none;">${game.category.join(', ')}</span>
       ` : ''}
   </div>
` : ''}

${game.mechanisms && game.mechanisms.length > 0 ? `
   <div style="margin-bottom: 1rem;">
       <strong>Mechanisms:</strong> 
       <span id="mechanisms-short">${game.mechanisms.slice(0, 3).join(', ')}${game.mechanisms.length > 3 ? '...' : ''}</span>
       ${game.mechanisms.length > 3 ? `
           <span style="color: #667eea; cursor: pointer; margin-left: 5px;" onclick="
               const shortMechanisms = document.getElementById('mechanisms-short');
               const fullMechanisms = document.getElementById('mechanisms-full');
               const isShowing = fullMechanisms.style.display !== 'none';
               if (isShowing) {
                   fullMechanisms.style.display = 'none';
                   shortMechanisms.style.display = 'inline';
                   this.textContent = 'More';
               } else {
                   fullMechanisms.style.display = 'inline';
                   shortMechanisms.style.display = 'none';
                   this.textContent = 'Less';
               }
           ">More</span>
           <span id="mechanisms-full" style="display: none;">${game.mechanisms.join(', ')}</span>
       ` : ''}
   </div>
` : ''}

${game.designers && game.designers.length > 0 ? `
   <div style="margin-bottom: 1rem;">
       <strong>Designers:</strong> ${game.designers.join(', ')}
   </div>
` : ''}

                   
${game.designerNationality && game.designerNationality.length > 0 ? `
                       <div style="margin-bottom: 1rem;">
                           <strong>Designer Nationality:</strong> ${Array.isArray(game.designerNationality) ? game.designerNationality.join(', ') : game.designerNationality}
                       </div>
                   ` : ''}
                   
                   ${game.artists && game.artists.length > 0 ? `
                       <div style="margin-bottom: 1rem;">
                           <strong>Artists:</strong> ${game.artists.join(', ')}
                       </div>
                   ` : ''}
                   
${game.publishers && game.publishers.length > 0 ? `
                       <div style="margin-bottom: 1rem;">
                           <strong>Publishers:</strong> ${game.publishers.join(', ')}
                       </div>
                   ` : ''}
                   
${game.publisherCountry && game.publisherCountry.length > 0 ? `
                       <div style="margin-bottom: 1rem;">
                           <strong>Publisher Country:</strong> ${Array.isArray(game.publisherCountry) ? game.publisherCountry.join(', ') : game.publisherCountry}
                       </div>
                   ` : ''}
               </div>
           </div>
       `;
   }

   openLightbox(game) {
       const lightbox = document.getElementById('lightbox-modal');
       const container = document.getElementById('lightbox-swiper');
       
       container.innerHTML = `
           <div class="swiper" style="width: 90vw; height: 90vh;">
               <div class="swiper-wrapper">
                   ${game.images.map(img => `
                       <div class="swiper-slide" style="display: flex; align-items: center; justify-content: center;">
                           <img src="${img}" alt="${game.name}" style="max-width: 100%; max-height: 100%; object-fit: contain;">
                       </div>
                   `).join('')}
               </div>
               ${game.images.length > 1 ? `
                   <div class="swiper-button-next"></div>
                   <div class="swiper-button-prev"></div>
                   <div class="swiper-pagination"></div>
               ` : ''}
           </div>
       `;
       
       lightbox.style.display = 'block';
       
       new Swiper('#lightbox-swiper .swiper', {
           navigation: {
               nextEl: '#lightbox-swiper .swiper-button-next',
               prevEl: '#lightbox-swiper .swiper-button-prev',
           },
           pagination: {
               el: '#lightbox-swiper .swiper-pagination',
               clickable: true,
           },
           loop: game.images.length > 1,
           keyboard: true,
       });
   }

   closeModal() {
       // Destroy any active swipers to prevent memory leaks
       const modalSwiper = document.querySelector('#modal-swiper .swiper');
       if (modalSwiper && modalSwiper.swiper) {
           modalSwiper.swiper.destroy(true, true);
       }
       document.getElementById('game-modal').style.display = 'none';
   }

closeLightbox() {
       // Destroy any active swipers to prevent memory leaks
       const lightboxSwiper = document.querySelector('#lightbox-swiper .swiper');
       if (lightboxSwiper && lightboxSwiper.swiper) {
           lightboxSwiper.swiper.destroy(true, true);
       }
       document.getElementById('lightbox-modal').style.display = 'none';
   }

editGameFromModal(gameId) {
       this.closeModal();
       if (!this.isEditMode) {
           this.toggleEditMode();
       }
       // Wait for render to complete, then scroll to the game
       setTimeout(() => {
           const gameCard = document.querySelector(`[data-game-id="${gameId}"]`);
           if (gameCard) {
               gameCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
           }
       }, 100);
   }


async shareCollection() {
    if (!this.githubReady || !this.isSignedIn || !this.GITHUB_TOKEN) {
        alert('You must be connected to GitHub to share your collection.');
        return;
    }

const allGames = Array.from(this.games.values()).map(game => {
        const sharedGame = { ...game };
        delete sharedGame.notes;
        delete sharedGame.dateAcquired;
        return sharedGame;
    });
// Get current filter and sort values from UI
this.updateFilters();

const config = {
    filters: this.currentFilters,
    visibleFields: this.visibleFields,
    games: allGames,
    viewMode: 'gallery',
    sortField: document.getElementById('sort-field').value,
    sortOrder: document.getElementById('sort-order').value,
    columns: this.currentColumns,
    preferences: Object.fromEntries(this.gamePreferences),
    sharedAt: new Date().toISOString()
};

    try {
        // Create GitHub Gist
        const gistData = {
            description: `Board Game Collection - ${this.filteredGames.length} games curated`,
            public: true,
            files: {
                "board-game-collection.json": {
                    content: JSON.stringify(config, null, 2)
                }
            }
        };

console.log('Creating Gist with data:', gistData);
        console.log('Using token:', this.GITHUB_TOKEN ? `Token present (${this.GITHUB_TOKEN.substring(0, 8)}...)` : 'No token');
        
        // Test token validity first
        const testResponse = await fetch('https://api.github.com/user', {
            headers: {
                'Authorization': `Bearer ${this.GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github+json'
            }
        });
        console.log('Token test response:', testResponse.status);
        if (!testResponse.ok) {
            const testError = await testResponse.text();
            console.log('Token test error:', testError);
            throw new Error('Invalid GitHub token. Please reconnect to GitHub.');
        }
        
        const response = await fetch('https://api.github.com/gists', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${this.GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github+json',
                'Content-Type': 'application/json',
                'X-GitHub-Api-Version': '2022-11-28'
            },
            body: JSON.stringify(gistData)
        });

        console.log('Response status:', response.status);
        console.log('Response headers:', response.headers);
        
        if (!response.ok) {
            const errorText = await response.text();
            console.log('Error response:', errorText);
            throw new Error(`GitHub API error: ${response.status} ${response.statusText} - ${errorText}`);
        }

        const gist = await response.json();
        const shareUrl = `${window.location.origin}${window.location.pathname}?gist=${gist.id}`;
        
// Copy to clipboard and show native share dialog
        await navigator.clipboard.writeText(shareUrl);
        
        if (navigator.share) {
            // Use native share API if available
            try {
                await navigator.share({
                    title: 'Board Game Collection',
                    text: `Check out this curated board game collection (${this.filteredGames.length} games)`,
                    url: shareUrl
                });
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Error sharing:', error);
                    alert(`Share URL copied to clipboard!\n\nThis will show ${this.filteredGames.length} games with your current filters and sorting applied.`);
                }
            }
        } else {
            // Fallback for browsers without native share
            alert(`Share URL copied to clipboard!\n\nThis will show ${this.filteredGames.length} games with your current filters and sorting applied.`);
        }

    } catch (error) {
        console.error('Error creating share link:', error);
        alert('Failed to create share link. Please check your GitHub connection and try again.');
    }
}

   exportData() {
       const data = {
           games: Object.fromEntries(this.games),
           exported: new Date().toISOString(),
           version: '1.0'
       };

       const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
       const url = URL.createObjectURL(blob);
       const a = document.createElement('a');
       a.href = url;
       a.download = `boardgame-collection-${new Date().toISOString().split('T')[0]}.json`;
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
   }

async importData(file) {
       if (!file) return;

       try {
           const text = await file.text();
           const data = JSON.parse(text);

           if (data.games) {
               const shouldClear = confirm('Clear existing collection before importing?');
               if (shouldClear) {
                   this.games.clear();
               }

               Object.entries(data.games).forEach(([id, game]) => {
                   this.games.set(id, game);
               });

this.saveToStorage();
this.updateDesignerFilter();
this.updatePublisherFilter();
this.updateDesignerNationalityFilter();
this.updateArtistFilter();
this.updateCategoryFilter();
this.updateMechanismsFilter();
this.applyFilters();
alert(`Imported ${Object.keys(data.games).length} games successfully!`);
           }
       } catch (error) {
           alert('Error importing file: ' + error.message);
       }
   }

   setGamePreference(gameId, preference) {
       const currentPreference = this.gamePreferences.get(gameId);
       
       if (currentPreference === preference) {
           // If clicking the same preference, toggle it off
           this.gamePreferences.delete(gameId);
       } else {
           // Set new preference
           this.gamePreferences.set(gameId, preference);
       }
       
       this.updateClearThumbsVisibility();
       this.saveToStorage();
       this.applyFilters();
   }

clearThumbs() {
       if (this.isSharedView) {
           // Reset to original shared preferences
           this.gamePreferences.clear();
           this.originalSharedPreferences.forEach((pref, gameId) => {
               this.gamePreferences.set(gameId, pref);
           });
       } else {
           // In own collection, clear all thumbs
           this.gamePreferences.clear();
       }
       
       this.updateClearThumbsVisibility();
       this.saveToStorage();
       this.applyFilters();
   }

 updateClearThumbsVisibility() {
       let hasUserThumbs = false;
       
       if (this.isSharedView) {
           // Show clear button if user has made any changes from the original shared preferences
           hasUserThumbs = Array.from(this.gamePreferences.entries()).some(([gameId, pref]) => {
               return this.originalSharedPreferences.get(gameId) !== pref;
           });
       } else {
           // Show clear button if user has any thumbs in their own collection
           hasUserThumbs = this.gamePreferences.size > 0;
       }
       
       const clearBtn = document.getElementById('clear-thumbs-btn');
       const mobileClearBtn = document.getElementById('mobile-clear-thumbs-btn');
       
       if (clearBtn) clearBtn.style.display = hasUserThumbs ? 'inline-block' : 'none';
       if (mobileClearBtn) mobileClearBtn.style.display = hasUserThumbs ? 'inline-block' : 'none';
   }
}


let boardGameApp;

document.addEventListener('DOMContentLoaded', async () => {
   console.log('Initializing app...');
   try {
       boardGameApp = new BoardGameCollection();
       await boardGameApp.init();
       console.log('App initialized successfully');
   } catch (error) {
       console.error('Failed to initialize app:', error);
   }
});

</script>
<div id="game-modal" class="modal" style="display: none;">
   <div class="modal-content">
       <span class="close-modal" onclick="boardGameApp.closeModal()">&times;</span>
       <div id="modal-game-content"></div>
   </div>
</div>

<div id="lightbox-modal" class="lightbox" style="display: none;">
   <div class="lightbox-content">
       <span class="close-lightbox" onclick="boardGameApp.closeLightbox()">&times;</span>
       <div id="lightbox-swiper"></div>
   </div>
</div>
</body>
</html>
