<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Board Game Collection Manager</title>
    <link rel="icon" href="https://wallpapers.com/images/hd/red-d20-dice-icon-4xdi6uhmnfam2pvj.jpg" type="image/jpeg">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-...your_sha512_hash..." crossorigin="anonymous" referrerpolicy="no-referrer">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.4.5/swiper-bundle.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f7fa;
            color: #333;
            line-height: 1.6;
            transition: background-color 0.3s ease;
        }

        body.edit-mode {
            background: #ffffff;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            margin-bottom: 1rem;
            text-align: center;
        }

        .controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }

.hamburger {
            display: none;
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            transition: transform 0.3s ease;
            z-index: 1001;
            position: relative;
        }

        .hamburger.open {
            transform: rotate(90deg);
        }

.mobile-menu {
            position: fixed;
            top: 0;
            right: -100%;
            width: 250px;
            height: 100vh;
            background: rgba(102, 126, 234, 0.95);
            backdrop-filter: blur(10px);
            transition: right 0.3s ease;
            z-index: 999;
            padding: 4rem 1rem 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

.mobile-menu.show {
            right: 0;
        }

        .mobile-menu .btn {
            width: 100%;
            justify-content: center;
        }

.search-box {
            flex: 1;
            min-width: 150px;
            max-width: 400px;
            position: relative;
        }

.search-icon {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: #333;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1;
        }

.search-clear {
    position: absolute;
    right: 15px;
    top: 50%;
    transform: translateY(-50%);
    color: #999;
    cursor: pointer;
    font-size: 0.7rem;
    opacity: 0.6;
    transition: opacity 0.2s ease;
}

.search-clear:hover {
    opacity: 1;
}

        .controls .search-box {
            max-width: 300px;
        }

.clear-thumbs-btn {
            background: rgba(86, 76, 175, 1) !important;
            white-space: nowrap;
            flex-shrink: 0;
            backdrop-filter: blur(10px);
        }

        .clear-thumbs-btn:hover {
            background: rgba(86, 76, 175, 0.6) !important;
            transform: translateY(-2px);
        }

        .search-box input {
            width: 100%;
            padding: 0.65rem;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            outline: none;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 25px;
            background: rgba(255,255,255,0.2);
            color: white;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }

.btn-primary {
            background: rgba(76, 175, 134, 1);
            backdrop-filter: blur(10px);
        }

        .btn-primary:hover {
            background: rgba(76, 175, 134, 0.6);
            transform: translateY(-2px);
        }

        .edit-mode-controls {
            display: none;
            gap: 1rem;
        }

        .edit-mode-controls.show {
            display: flex;
        }

        .btn-save {
            background: #4CAF50;
        }

        .btn-discard {
            background: #e74c3c;
        }

        .filters {
            background: white;
            padding: 0 1rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 1rem;
            display: none;
        }

.filter-row.gray {
    background-color: #f4f6f9;
    padding: 1rem;
    margin: 0 -1rem;
}

.filter-row.white {
    background-color: white;
    padding: 1rem;
    margin: 0 -1rem;
}

@media (max-width: 768px) {
    .filter-row.gray,
    .filter-row.white {
        margin: 0 -1rem;
        padding: 1rem;
    }
}

        .filters.show {
            display: block;
        }

        .filter-row {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .filter-group label {
            font-weight: 600;
            color: #000;
            font-size: 0.9rem;
        }

        .filter-group input, .filter-group select {
            padding: 0.5rem;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 0.9rem;
            min-width: 10px;
        }

        .filter-group .btn {
            background: #667eea;
            color: white;
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
        }

button#clear-filters {
    background: #667eea;
    color: white;
    padding: 0.5rem 1rem;
    font-size: 0.8rem;
}

        .sort-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

#results-info {
    margin: 0.5rem auto !important;
}

        .container {
            max-width: 98%;
            margin: 0 auto;
            padding: 1rem;
        }

        .game-grid {
            display: grid;
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .game-grid.cols-1 { grid-template-columns: 1fr; }
        .game-grid.cols-2 { grid-template-columns: repeat(2, 1fr); }
        .game-grid.cols-3 { grid-template-columns: repeat(3, 1fr); }
        .game-grid.cols-4 { grid-template-columns: repeat(4, 1fr); }
        .game-grid.cols-5 { grid-template-columns: repeat(5, 1fr); }

        .game-card {
            background: white;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            overflow: hidden;
            transition: all 0.3s ease;
            position: relative;
        }

        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.15);
        }

        .game-card.edit-mode {
    border: 2px solid #ffffff;
    box-shadow: 0 4px 15px rgb(113 50 0 / 30%);
        }

        .image-carousel {
            position: relative;
            height: 200px;
            overflow: hidden;
        }

        .swiper {
            width: 100%;
            height: 100%;
        }

        .swiper-slide {
            display: flex;
            justify-content: center;
            align-items: center;
            background: #f8f9fa;
        }

        .swiper-slide img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

.swiper-slide img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

.image-loading {
            opacity: 0;
        }

        .image-loaded {
            opacity: 1;
        }


.cache-progress {
            margin-bottom: 2rem;
        }

        .cache-progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 1.5rem;
        }

        .cache-progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            transition: width 0.3s ease;
            width: 0%;
        }

#cache-status {
            color: white;
            font-size: 1rem;
            font-weight: 500;
            margin-bottom: 1rem;
            line-height: 1.4;
        }

        #cache-help-text {
            color: white;
            font-size: 1rem;
            font-weight: 400;
            opacity: 0.9;
            line-height: 1.4;
        }

        .swiper-button-next,
        .swiper-button-prev {
            color: white;
            background: rgba(0,0,0,0.5);
            width: 35px;
            height: 35px;
            margin-top: -17px;
            border-radius: 50%;
            z-index: 10;
        }

        .swiper-button-next:after,
        .swiper-button-prev:after {
            font-size: 14px;
        }

        .swiper-pagination-bullet {
            background: white;
            opacity: 0.7;
        }

        .swiper-pagination-bullet-active {
            opacity: 1;
        }

.game-info {
    padding: 0.5rem 1rem 1.5rem;
}

.game-title {
            font-size: 1rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 0.5rem;
            line-height: 1.2;
        }

.game-meta {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            margin-bottom: 1rem;
            font-size: 0.8rem;
        }

.meta-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            color: #666;
            font-size: 0.75rem;
        }

        .meta-label {
            font-weight: 600;
            min-width: 60px;
        }

.thumb-buttons {
    position: absolute;
    bottom: 10px;
    left: 10px;
    right: 10px;
    display: flex;
    justify-content: space-between;
    pointer-events: none;
}

.thumb-btn {
    width: 24px;
    height: 24px;
    border: none;
    border-radius: 50%;
    font-size: 12px;
    cursor: pointer;
    pointer-events: auto;
    opacity: 0.7;
    transition: opacity 0.3s ease;
    z-index: 5;
}

.thumb-btn:hover {
    opacity: 1;
}

.thumb-up {
    background: #144d16b0;
    color: white;
}

.thumb-down {
    background: #ac1900e6;
    color: white;
}

.thumb-btn.active {
    opacity: 1;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

.modal-thumbs {
    position: absolute;
    top: 10px;
    left: 10px;
    display: flex;
    gap: 10px;
    z-index: 10;
}

.game-card {
    position: relative;
}

        .edit-field {
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            font-size: 0.9rem;
            width: 100%;
            margin: 0.25rem 0;
        }

        .edit-field:focus {
            border-color: #667eea;
            outline: none;
        }

        .edit-images {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin: 0.5rem 0;
        }

        .edit-image-item {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .edit-image-item input {
            flex: 1;
        }

        .edit-image-item button {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
        }

        .add-image-btn {
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            margin-top: 0.5rem;
        }

        .delete-game-btn {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            margin-top: 1rem;
            width: 100%;
            font-weight: 600;
        }

        .delete-game-btn:hover {
            background: #c0392b;
        }

        .edit-expanded {
            padding: 1.5rem;
        }

        .edit-section {
            margin-bottom: 1.5rem;
        }

        .edit-section h4 {
            color: #2c3e50;
            margin-bottom: 0.75rem;
            font-size: 1rem;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.25rem;
        }

        .edit-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .edit-group {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .edit-group label {
            font-weight: 600;
            color: #555;
            font-size: 0.85rem;
        }

        .details-toggle {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-weight: 600;
            padding: 0.5rem 0;
            width: 100%;
            text-align: left;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .details-content {
            display: none;
            padding-top: 1rem;
            border-top: 1px solid #eee;
            margin-top: 1rem;
        }

        .details-content.show {
            display: block;
        }

        .detail-section {
            margin-bottom: 1rem;
        }

        .detail-section h4 {
            color: #2c3e50;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .detail-section p {
            color: #666;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .notes {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            font-style: italic;
        }

        .add-game-form {
            display: none;
            background: white;
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            margin-bottom: 2rem;
            position: relative;
        }

        .add-game-form.show {
            display: block;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-group label {
            font-weight: 600;
            color: #2c3e50;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            padding: 0.75rem;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .form-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
        }

        .close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #999;
        }

        .empty-state {
            text-align: center;
            padding: 3rem;
            color: #666;
        }

        .empty-state h3 {
            margin-bottom: 1rem;
            color: #2c3e50;
        }

.loading {
            text-align: center;
            padding: 2rem;
            color: #667eea;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(2px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1500;
            display: none;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 1rem;
            color: #667eea;
            font-weight: 600;
        }


.cache-loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(102, 126, 234, 0.95);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            display: none;
        }

.cache-content {
            text-align: center;
            max-width: 400px;
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .success {
            background: #efe;
            color: #363;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .modal {
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background-color: white;
            margin: 2% auto;
            padding: 2rem;
            border-radius: 15px;
            width: 95%;
            max-width: 1200px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }

        .close-modal {
            position: absolute;
            top: 1rem;
            right: 1.5rem;
            font-size: 2rem;
            cursor: pointer;
            color: #999;
        }

        .lightbox {
            position: fixed;
            z-index: 3000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
        }

        .lightbox-content {
            position: relative;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

.close-lightbox {
            position: absolute;
            top: 2rem;
            right: 2rem;
            font-size: 3rem;
            cursor: pointer;
            color: #999;
            z-index: 3001;
            text-shadow: 0 0 4px rgba(255, 255, 255, 0.8);
        }

        /* Mobile Controls Layout */
        .mobile-controls {
            display: none;
        }

/* Responsive Design */
        @media (max-width: 768px) {
    .modal-content div[style*="grid-template-columns: 1fr 1fr"] {
        grid-template-columns: 1fr !important;
    }
    
    .modal-content div[style*="display: flex"] {
        flex-direction: column !important;
        align-items: flex-start !important;
    }

            .game-meta {
                grid-template-columns: 1fr;
            }

            .form-row {
                grid-template-columns: 1fr;
            }

            .filter-row {
                flex-direction: column;
                gap: 1rem;
            }

            .sort-controls {
                width: 100%;
                justify-content: center;
            }

.hamburger {
                display: block;
            }
            
            #desktop-hamburger-btn {
                display: none !important;
            }
            
            .controls {
                display: none;
            }

            .github-controls {
                display: none !important;
            }

.mobile-controls {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    margin-top: 0.5rem;
    flex-wrap: wrap;
}

.mobile-controls .search-box {
    flex: 1;
    min-width: 100px;
}

.mobile-controls.clear-visible {
    flex-direction: column;
    align-items: stretch;
    gap: 0.5rem;
}

.mobile-controls.clear-visible .search-box {
    width: 100%;
    max-width: none;
    margin-bottom: 0;
}

.mobile-controls.clear-visible .mobile-buttons-row {
    display: flex;
    justify-content: center;
    gap: 0.5rem;
    width: 100%;
}

.mobile-controls:not(.clear-visible) .mobile-buttons-row {
    display: contents;
}
            
            .header h1 {
                font-size: 1.2rem;
                margin-bottom: 0.5rem;
                display: flex;
                align-items: center;
                justify-content: space-between;
            }
            
            .header {
                padding: 0.5rem 1rem;
            }

            .modal-content {
                margin: 1% auto;
                width: 98%;
                max-height: 95vh;
            }
        }

        /* Custom filter delete confirmation */
        .custom-filter-delete {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            font-size: 0.8rem;
        }

.multiselect-container {
            position: relative;
        }

        .multiselect-dropdown {
            position: relative;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            background: white;
            min-height: 40px;
            cursor: pointer;
        }

        .multiselect-selected {
            padding: 0.5rem;
            font-size: 0.9rem;
            min-width: 120px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .multiselect-selected:after {
            content: '▼';
            font-size: 0.8rem;
            color: #666;
        }

        .multiselect-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e1e5e9;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .multiselect-options.show {
            display: block;
        }

.multiselect-option {
            padding: 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            font-size: 0.9rem;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .multiselect-option:hover {
            background: #f8f9fa;
        }

        .multiselect-option input[type="checkbox"] {
            margin: 0;
            flex-shrink: 0;
            width: 16px;
            height: 16px;
            margin-top: 2px;
        }

        .multiselect-option-text {
            flex: 1;
            cursor: pointer;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }

.complexity-tooltip {
    position: relative;
    display: inline-block;
    cursor: help;
    margin-left: 0.25rem;
}

.complexity-tooltip .tooltiptext {
    visibility: hidden;
    width: 200px;
    background-color: rgba(0,0,0,0.9);
    color: #fff;
    text-align: left;
    border-radius: 6px;
    padding: 8px;
    position: absolute;
    z-index: 1;
    bottom: 125%;
    left: 50%;
    margin-left: -100px;
    opacity: 0;
    transition: opacity 0.3s;
    font-size: 0.8rem;
    line-height: 1.4;
}

.complexity-tooltip:hover .tooltiptext {
    visibility: visible;
    opacity: 1;
}

    </style>
</head>
<body>
    <div class="header">
        <h1 id="page-title">
            <i class="fa-solid fa-chess-rook"></i> Board Game Collection Manager
            <button class="hamburger" id="hamburger-btn" style="display: none;">☰</button>
        </h1>
        
<div class="controls">
<div class="search-box">
                <i class="fa-solid fa-magnifying-glass search-icon" id="search-icon"></i>
                <input type="text" id="search" style="padding-left: 2.5rem; padding-right: 2rem;">
                <i class="fa-solid fa-times search-clear" id="search-clear" style="display: none;"></i>
            </div>
<button class="btn" id="toggle-filters"><i class="fa-solid fa-arrow-down-wide-short"></i> Filters</button>
<button class="btn clear-thumbs-btn" id="clear-thumbs-btn" style="display: none;">Reset <i class="fa-solid fa-thumbtack"></i> / <i class="fa-solid fa-eye-slash"></i></button>
            <div class="edit-mode-controls" id="edit-mode-controls">
                <button class="btn btn-discard" id="discard-changes-btn">Discard Changes</button>
                <button class="btn btn-save" id="save-changes-btn">Save Changes</button>
            </div>
</div>

<button class="hamburger" id="desktop-hamburger-btn" style="position: absolute; top: 1rem; right: 1rem; display: block;">
            <i class="fa-solid fa-circle-user"></i>
        </button>

<div class="mobile-controls" id="mobile-controls">
<div class="search-box">
                <i class="fa-solid fa-magnifying-glass search-icon" id="mobile-search-icon"></i>
                <input type="text" id="mobile-search" style="padding-left: 2.5rem; padding-right: 2rem;">
                <i class="fa-solid fa-times search-clear" id="mobile-search-clear" style="display: none;"></i>
            </div>
            <div class="mobile-buttons-row">
                <button class="btn clear-thumbs-btn" id="mobile-clear-thumbs-btn" style="display: none;">Reset <i class="fa-solid fa-thumbtack"></i> / <i class="fa-solid fa-eye-slash"></i></button>
<button class="btn" id="mobile-toggle-filters"><i class="fa-solid fa-arrow-down-wide-short"></i> Filters</button>
            </div>
            <div class="edit-mode-controls mobile-edit-controls" id="mobile-edit-mode-controls-header">
                <button class="btn btn-discard" id="mobile-discard-changes-btn-header">Discard Changes</button>
                <button class="btn btn-save" id="mobile-save-changes-btn-header">Save Changes</button>
            </div>
        </div>


<div class="mobile-menu" id="mobile-menu">
<button class="btn btn-primary" id="mobile-add-game-btn"><i class="fa-solid fa-plus"></i> Add Game</button>
<button class="btn" id="mobile-edit-mode-btn"><i class="fa-solid fa-pen-to-square"></i> Edit</button>
<button class="btn" id="mobile-share-btn"><i class="fa-solid fa-arrow-up-right-from-square"></i> Share Collection</button>
<button class="btn" id="mobile-export-btn"><i class="fa-solid fa-arrow-up-from-bracket"></i> Export Data</button>
<button class="btn" id="mobile-import-btn"><i class="fa-solid fa-download"></i> Import Data</button>
<button class="btn" id="mobile-refresh-cache-btn"><i class="fa-solid fa-arrows-rotate"></i> Refresh Cache</button>
<button class="btn" id="mobile-google-drive-signin" style="display: none;"><i class="fa-solid fa-right-to-bracket"></i> Connect GitHub</button>
<button class="btn" id="mobile-google-drive-signout" style="display: none;"><i class="fa-solid fa-right-to-bracket"></i> Disconnect GitHub</button>
<div id="mobile-google-drive-status" style="font-size: 0.9rem; padding: 0.5rem; text-align: center;">Loading GitHub...</div>
        </div>

<div class="mobile-menu" id="desktop-menu">
<button class="btn btn-primary" id="desktop-add-game-btn"><i class="fa-solid fa-plus"></i> Add Game</button>
<button class="btn" id="desktop-edit-mode-btn"><i class="fa-solid fa-pen-to-square"></i> Edit</button>
<button class="btn" id="desktop-share-btn"><i class="fa-solid fa-arrow-up-right-from-square"></i> Share Collection</button>
<button class="btn" id="desktop-export-btn"><i class="fa-solid fa-arrow-up-from-bracket"></i> Export Data</button>
<button class="btn" id="desktop-import-btn"><i class="fa-solid fa-download"></i> Import Data</button>
<button class="btn" id="desktop-refresh-cache-btn"><i class="fa-solid fa-arrows-rotate"></i> Refresh Cache</button>
<button class="btn" id="desktop-google-drive-signin" style="display: none;"><i class="fa-solid fa-right-to-bracket"></i> Connect GitHub</button>
<button class="btn" id="desktop-google-drive-signout" style="display: none;"><i class="fa-solid fa-right-to-bracket"></i> Disconnect GitHub</button>
            <div id="desktop-google-drive-status" style="font-size: 0.9rem; padding: 0.5rem; text-align: center;">Loading GitHub...</div>
        </div>
</div>

<div id="results-info" style="margin-bottom: 1rem; color: #666; font-size: 0.9rem; max-width: 98%; margin-left: auto; margin-right: auto; padding: 0 1rem; display: flex; justify-content: space-between; align-items: center;">
        <span id="results-text"></span>
        <span id="columns-control" style="cursor: pointer; color: #666; font-size: 0.9rem;"><i class="fa-solid fa-table-columns"></i> <span id="columns-text">5 Columns</span></span>
    </div>


<div class="filters" id="filters">
    <!-- White row: Sort By and clear filters -->
    <div class="filter-row white">
        <div class="sort-controls">
            <label>Sort by:</label>
            <select id="sort-field">
                <option value="name">Name</option>
                <option value="year">Year Published</option>
                <option value="dateAcquired">Date Acquired</option>
                <option value="players.min">Min Players</option>
                <option value="players.max">Max Players</option>
                <option value="playtime.min">Playtime</option>
                <option value="weight">Complexity</option>
            </select>
            <select id="sort-order">
                <option value="asc">Ascending</option>
                <option value="desc">Descending</option>
            </select>
        </div>
        <button class="btn" id="clear-filters">Clear All</button>
    </div>

    <!-- Gray row: Best Player Count, Min Players, Max Players -->
    <div class="filter-row gray">
        <div class="filter-group">
            <label>Best Player Count</label>
            <input type="text" id="best-player-count-filter" placeholder="2,3,4 (comma separated)">
        </div>
        <div class="filter-group">
            <label>Min Players</label>
            <div style="display: flex; gap: 0.5rem;">
                <select id="min-players-type">
                    <option value="greater">Greater than</option>
                    <option value="exact">Exactly</option>
                    <option value="less">Less than</option>
                </select>
                <input type="number" id="min-players" min="1" placeholder="1">
            </div>
        </div>
        <div class="filter-group">
            <label>Max Players</label>
            <div style="display: flex; gap: 0.5rem;">
                <select id="max-players-type">
                    <option value="less">Less than</option>
                    <option value="exact">Exactly</option>
                    <option value="greater">Greater than</option>
                </select>
                <input type="number" id="max-players" min="1" placeholder="10">
            </div>
        </div>
    </div>

    <!-- White row: Complexity -->
    <div class="filter-row white">
        <div class="filter-group">
            <label>Complexity (1-5)</label>
            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                <div style="display: flex; gap: 0.25rem; align-items: center;">
                    <span style="font-size: 0.8rem;">Min:</span>
                    <select id="min-weight-type" style="width: auto;">
                        <option value="greater">></option>
                        <option value="exact">=</option>
                    </select>
                    <input type="number" id="min-weight" min="1" max="5" step="0.1" placeholder="1.0" style="width: 70px;">
                </div>
                <div style="display: flex; gap: 0.25rem; align-items: center;">
                    <span style="font-size: 0.8rem;">Max:</span>
                    <select id="max-weight-type" style="width: auto;">
                        <option value="less"><</option>
                        <option value="exact">=</option>
                    </select>
                    <input type="number" id="max-weight" min="1" max="5" step="0.1" placeholder="5.0" style="width: 70px;">
                </div>
            </div>
        </div>
    </div>

    <!-- Gray row: Year Published, Date Acquired -->
    <div class="filter-row gray">
        <div class="filter-group">
            <label>Year Published</label>
            <div style="display: flex; gap: 0.5rem;">
                <select id="year-filter-type">
                    <option value="exact">Exactly</option>
                    <option value="greater">After</option>
                    <option value="less">Before</option>
                </select>
                <input type="number" id="year-filter" min="1900" max="2030" placeholder="2020">
            </div>
        </div>
        <div class="filter-group">
            <label>Date Acquired</label>
            <div style="display: flex; gap: 0.5rem;">
                <select id="date-acquired-filter-type">
                    <option value="exact">Same Year As...</option>
                    <option value="greater">After</option>
                    <option value="less">Before</option>
                </select>
                <input type="date" id="date-acquired-filter">
            </div>
        </div>
    </div>

    <!-- White row: Min Playtime, Max Playtime -->
    <div class="filter-row white">
        <div class="filter-group">
            <label>Min Playtime</label>
            <div style="display: flex; gap: 0.5rem;">
                <select id="min-playtime-type">
                    <option value="greater">Greater than</option>
                    <option value="exact">Exactly</option>
                    <option value="less">Less than</option>
                </select>
                <input type="number" id="min-playtime" min="0" placeholder="30">
            </div>
        </div>
        <div class="filter-group">
            <label>Max Playtime</label>
            <div style="display: flex; gap: 0.5rem;">
                <select id="max-playtime-type">
                    <option value="less">Less than</option>
                    <option value="exact">Exactly</option>
                    <option value="greater">Greater than</option>
                </select>
                <input type="number" id="max-playtime" min="0" placeholder="120">
            </div>
        </div>
    </div>

    <!-- Gray row: Designer (select multiple), Designer Does Not Contain -->
    <div class="filter-row gray">
        <div class="filter-group">
            <label>Designer (select multiple)</label>
            <div class="multiselect-container">
                <div class="multiselect-dropdown" id="designer-filter-dropdown">
                    <div class="multiselect-selected">All Designers</div>
                    <div class="multiselect-options" id="designer-filter-options"></div>
                </div>
            </div>
        </div>
        <div class="filter-group">
            <label>Designer Does Not Contain</label>
            <div style="display: flex; gap: 0.5rem;">
                <select id="designer-contains-filter-type">
                    <option value="contains">Contains</option>
                    <option value="not-contains" selected>Does not contain</option>
                </select>
                <input type="text" id="designer-contains-filter" placeholder="Designer name">
            </div>
        </div>
    </div>

    <!-- White row: Designer Nationality (select multiple), Designer Nationality Does Not Contain -->
    <div class="filter-row white">
        <div class="filter-group">
            <label>Designer Nationality (select multiple)</label>
            <div class="multiselect-container">
                <div class="multiselect-dropdown" id="designer-nationality-filter-dropdown">
                    <div class="multiselect-selected">All Nationalities</div>
                    <div class="multiselect-options" id="designer-nationality-filter-options"></div>
                </div>
            </div>
        </div>
        <div class="filter-group">
            <label>Designer Nationality Does Not Contain</label>
            <div style="display: flex; gap: 0.5rem;">
                <select id="designer-nationality-contains-filter-type">
                    <option value="contains">Contains</option>
                    <option value="not-contains" selected>Does not contain</option>
                </select>
                <input type="text" id="designer-nationality-contains-filter" placeholder="Nationality">
            </div>
        </div>
    </div>

    <!-- Gray row: Artist (select multiple), Artist Does Not Contain -->
    <div class="filter-row gray">
        <div class="filter-group">
            <label>Artist (select multiple)</label>
            <div class="multiselect-container">
                <div class="multiselect-dropdown" id="artist-filter-dropdown">
                    <div class="multiselect-selected">All Artists</div>
                    <div class="multiselect-options" id="artist-filter-options"></div>
                </div>
            </div>
        </div>
        <div class="filter-group">
            <label>Artist Does Not Contain</label>
            <div style="display: flex; gap: 0.5rem;">
                <select id="artist-contains-filter-type">
                    <option value="contains">Contains</option>
                    <option value="not-contains" selected>Does not contain</option>
                </select>
                <input type="text" id="artist-contains-filter" placeholder="Artist name">
            </div>
        </div>
    </div>

    <!-- White row: Publisher (select multiple), Publisher Does Not Contain -->
    <div class="filter-row white">
        <div class="filter-group">
            <label>Publisher (select multiple)</label>
            <div class="multiselect-container">
                <div class="multiselect-dropdown" id="publisher-dropdown-filter-dropdown">
                    <div class="multiselect-selected">All Publishers</div>
                    <div class="multiselect-options" id="publisher-dropdown-filter-options"></div>
                </div>
            </div>
        </div>
        <div class="filter-group">
            <label>Publisher Does Not Contain</label>
            <div style="display: flex; gap: 0.5rem;">
                <select id="publisher-filter-type">
                    <option value="contains">Contains</option>
                    <option value="not-contains" selected>Does not contain</option>
                </select>
                <input type="text" id="publisher-filter" placeholder="Publisher name">
            </div>
        </div>
    </div>

    <!-- Gray row: Publisher Location (select multiple), Publisher Location Does Not Contain -->
    <div class="filter-row gray">
        <div class="filter-group">
            <label>Publisher Location (select multiple)</label>
            <div class="multiselect-container">
                <div class="multiselect-dropdown" id="publisher-country-dropdown-filter-dropdown">
                    <div class="multiselect-selected">All Publisher Countries</div>
                    <div class="multiselect-options" id="publisher-country-dropdown-filter-options"></div>
                </div>
            </div>
        </div>
        <div class="filter-group">
            <label>Publisher Location Does Not Contain</label>
            <div style="display: flex; gap: 0.5rem;">
                <select id="publisher-country-filter-type">
                    <option value="contains">Contains</option>
                    <option value="not-contains" selected>Does not contain</option>
                </select>
                <input type="text" id="publisher-country-filter" placeholder="Country">
            </div>
        </div>
    </div>

    <!-- White row: Notes, Description -->
    <div class="filter-row white">
        <div class="filter-group">
            <label>Notes</label>
            <div style="display: flex; gap: 0.5rem;">
                <select id="notes-filter-type">
                    <option value="contains">Contains</option>
                    <option value="exact">Exact</option>
                    <option value="not-contains">Does not contain</option>
                </select>
                <input type="text" id="notes-filter" placeholder="Search notes">
            </div>
        </div>
        <div class="filter-group">
            <label>Description</label>
            <div style="display: flex; gap: 0.5rem;">
                <select id="description-filter-type">
                    <option value="contains">Contains</option>
                    <option value="exact">Exact</option>
                    <option value="not-contains">Does not contain</option>
                </select>
                <input type="text" id="description-filter" placeholder="Search descriptions">
            </div>
        </div>
    </div>

    <!-- Gray row: Category (select multiple), Category Contains -->
    <div class="filter-row gray">
        <div class="filter-group">
            <label>Category (select multiple)</label>
            <div class="multiselect-container">
                <div class="multiselect-dropdown" id="category-filter-dropdown">
                    <div class="multiselect-selected">All Categories</div>
                    <div class="multiselect-options" id="category-filter-options"></div>
                </div>
            </div>
        </div>
        <div class="filter-group">
            <label>Category Contains</label>
            <div style="display: flex; gap: 0.5rem;">
                <select id="category-contains-filter-type">
                    <option value="contains">Contains</option>
                    <option value="exact">Exact</option>
                    <option value="not-contains">Does not contain</option>
                </select>
                <input type="text" id="category-contains-filter" placeholder="Category name">
            </div>
        </div>
    </div>

    <!-- White row: Mechanisms (select multiple), Mechanisms Contains -->
    <div class="filter-row white">
        <div class="filter-group">
            <label>Mechanisms (select multiple)</label>
            <div class="multiselect-container">
                <div class="multiselect-dropdown" id="mechanisms-filter-dropdown">
                    <div class="multiselect-selected">All Mechanisms</div>
                    <div class="multiselect-options" id="mechanisms-filter-options"></div>
                </div>
            </div>
        </div>
        <div class="filter-group">
            <label>Mechanisms Contains</label>
            <div style="display: flex; gap: 0.5rem;">
                <select id="mechanisms-contains-filter-type">
                    <option value="contains">Contains</option>
                    <option value="exact">Exact</option>
                    <option value="not-contains">Does not contain</option>
                </select>
                <input type="text" id="mechanisms-contains-filter" placeholder="Mechanism name">
            </div>
        </div>
    </div>

    <!-- Gray row: Custom Filters -->
    <div class="filter-row gray">
        <div class="filter-group">
            <label>Custom Filters</label>
            <button class="btn" id="add-custom-filter">Add Custom Filter</button>
        </div>
        <div id="custom-filters-container"></div>
    </div>
</div>


<div class="container">
    <div class="add-game-form" id="add-game-form">
           <button class="close-btn" id="close-form">&times;</button>
           <h2>Add New Game</h2>
           
           <div class="form-row">
               <div class="form-group">
                   <label>BoardGameGeek URL</label>
                   <input type="url" id="bgg-url" placeholder="https://boardgamegeek.com/boardgame/...">
                   <button class="btn btn-primary" id="fetch-bgg-data">Fetch Game Data</button>
               </div>
           </div>

           <div id="loading-indicator" class="loading" style="display: none;">
               Fetching game data from BoardGameGeek...
           </div>

           <div id="error-message" class="error" style="display: none;"></div>

           <div class="form-row">
               <div class="form-group">
                   <label>Game Name</label>
                   <input type="text" id="game-name" required>
               </div>
<div class="form-group">
                   <label>Year Published</label>
                   <input type="number" id="game-year" min="1900" max="2030">
               </div>
<div class="form-group">
                   <label>Date Acquired</label>
                   <input type="date" id="game-date-acquired" value="1991-11-19">
               </div>
           </div>

           <div class="form-row">
               <div class="form-group">
                   <label>Min Players</label>
                   <input type="number" id="game-min-players" min="1" max="20">
               </div>
               <div class="form-group">
                   <label>Max Players</label>
                   <input type="number" id="game-max-players" min="1" max="20">
               </div>
               <div class="form-group">
                   <label>Playtime (minutes)</label>
                   <input type="number" id="game-playtime" min="0" max="600">
               </div>
<div class="form-group">
                   <label>Complexity (1-5)</label>
                   <div style="display: flex; gap: 0.5rem;">
                       <input type="number" id="game-weight" step="0.1" min="0" max="5" style="flex: 1;">
<select id="game-weight-color" style="width: 100px;">
    <option value="#008000">Green</option>
    <option value="#cfa200">Yellow</option>
    <option value="#ff0000">Red</option>
</select>
                   </div>
               </div>
           </div>

           <div class="form-row">
               <div class="form-group">
                   <label>Best Player Count</label>
                   <input type="text" id="game-best-players" placeholder="2,3,4 (comma separated)">
               </div>
               <div class="form-group">
                   <label>Designers</label>
<input type="text" id="game-designers" placeholder="Semicolon separated">
               </div>
               <div class="form-group">
                   <label>Artists</label>
                   <input type="text" id="game-artists" placeholder="Semicolon separated">
               </div>
<div class="form-group">
                   <label>Publishers</label>
                   <input type="text" id="game-publishers" placeholder="Semicolon separated">
               </div>
<div class="form-group">
                   <label>Designer Nationality</label>
                   <input type="text" id="game-designer-nationality" placeholder="Semicolon separated">
               </div>
               <div class="form-group">
                   <label>Publisher Country</label>
                   <input type="text" id="game-publisher-country" placeholder="Semicolon separated">
               </div>
           </div>

<div class="form-row">
    <div class="form-group">
        <label>Images (URLs, one per line)</label>
        <textarea id="game-images" placeholder="https://image1.jpg&#10;https://image2.jpg"></textarea>
    </div>
    <div class="form-group">
        <label>Notes</label>
        <textarea id="game-notes" placeholder="Your thoughts about this game..."></textarea>
    </div>
</div>
<div class="form-row">
    <div class="form-group">
        <label>Description</label>
        <textarea id="game-description" placeholder="Game description..."></textarea>
    </div>
</div>
<div class="form-row">
    <div class="form-group">
<label>Category</label>
        <input type="text" id="game-category" placeholder="Strategy; Family; Party; etc. (semicolon separated)">
    </div>
    <div class="form-group">
        <label>Mechanisms</label>
        <input type="text" id="game-mechanisms" placeholder="Dice Rolling; Worker Placement; etc. (semicolon separated)">
    </div>
</div>

          <div class="form-actions">
              <button class="btn" id="cancel-add">Cancel</button>
              <button class="btn btn-primary" id="save-game">Save Game</button>
          </div>
      </div>

<div id="game-container">
    <div class="game-grid" id="game-grid"></div>
          <div class="empty-state" id="empty-state" style="display: none;">
              <h3>No games in your collection yet</h3>
              <p>Click "Add Game" to get started, or import an existing collection.</p>
          </div>
      </div>
  </div>

  <input type="file" id="import-file" accept=".json" style="display: none;">

  <!-- Load new Google Identity Services library -->
  <script src="https://accounts.google.com/gsi/client"></script>
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.4.5/swiper-bundle.min.js"></script>
  <script>
console.log('JavaScript is loading...');
document.addEventListener('DOMContentLoaded', () => {
   console.log('DOM loaded, buttons should work now');
});

class CacheManager {
    constructor() {
        this.dbName = 'BoardGameCollectionDB';
        this.dbVersion = 1;
        this.db = null;
        this.isReady = false;
    }

    async init() {
        return new Promise((resolve, reject) => {
            if (!('indexedDB' in window)) {
                console.warn('IndexedDB not supported, caching disabled');
                resolve(false);
                return;
            }

            const request = indexedDB.open(this.dbName, this.dbVersion);
            
            request.onerror = () => {
                console.error('Failed to open IndexedDB');
                resolve(false);
            };
            
            request.onsuccess = (event) => {
                this.db = event.target.result;
                this.isReady = true;
                resolve(true);
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                if (!db.objectStoreNames.contains('games')) {
                    db.createObjectStore('games', { keyPath: 'bggId' });
                }
                
                if (!db.objectStoreNames.contains('images')) {
                    db.createObjectStore('images', { keyPath: 'url' });
                }
                
                if (!db.objectStoreNames.contains('metadata')) {
                    db.createObjectStore('metadata', { keyPath: 'key' });
                }
            };
        });
    }

    async cacheGame(game) {
        if (!this.isReady) return false;
        
        try {
            const transaction = this.db.transaction(['games'], 'readwrite');
            const store = transaction.objectStore('games');
            await this.promisifyRequest(store.put(game));
            return true;
        } catch (error) {
            console.error('Failed to cache game:', error);
            return false;
        }
    }

    async getCachedGame(bggId) {
        if (!this.isReady) return null;
        
        try {
            const transaction = this.db.transaction(['games'], 'readonly');
            const store = transaction.objectStore('games');
            const result = await this.promisifyRequest(store.get(bggId));
            return result;
        } catch (error) {
            console.error('Failed to get cached game:', error);
            return null;
        }
    }

    async cacheImage(url, blob) {
        if (!this.isReady) return false;
        
        try {
            const transaction = this.db.transaction(['images'], 'readwrite');
            const store = transaction.objectStore('images');
            await this.promisifyRequest(store.put({ url, blob, cachedAt: Date.now() }));
            return true;
        } catch (error) {
            console.error('Failed to cache image:', error);
            return false;
        }
    }

    async getCachedImageUrl(url) {
        if (!this.isReady) return null;
        
        try {
            const transaction = this.db.transaction(['images'], 'readonly');
            const store = transaction.objectStore('images');
            const result = await this.promisifyRequest(store.get(url));
            
            if (result && result.blob) {
                return URL.createObjectURL(result.blob);
            }
            return null;
        } catch (error) {
            console.error('Failed to get cached image:', error);
            return null;
        }
    }

    async setMetadata(key, value) {
        if (!this.isReady) return false;
        
        try {
            const transaction = this.db.transaction(['metadata'], 'readwrite');
            const store = transaction.objectStore('metadata');
            await this.promisifyRequest(store.put({ key, value, updatedAt: Date.now() }));
            return true;
        } catch (error) {
            console.error('Failed to set metadata:', error);
            return false;
        }
    }

    async getMetadata(key) {
        if (!this.isReady) return null;
        
        try {
            const transaction = this.db.transaction(['metadata'], 'readonly');
            const store = transaction.objectStore('metadata');
            const result = await this.promisifyRequest(store.get(key));
            return result ? result.value : null;
        } catch (error) {
            console.error('Failed to get metadata:', error);
            return null;
        }
    }

    promisifyRequest(request) {
        return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    async clearCache() {
        if (!this.isReady) return false;
        
        try {
            const transaction = this.db.transaction(['games', 'images', 'metadata'], 'readwrite');
            await Promise.all([
                this.promisifyRequest(transaction.objectStore('games').clear()),
                this.promisifyRequest(transaction.objectStore('images').clear()),
                this.promisifyRequest(transaction.objectStore('metadata').clear())
            ]);
            return true;
        } catch (error) {
            console.error('Failed to clear cache:', error);
            return false;
        }
    }
}

class BoardGameCollection {
   constructor() {
       this.games = new Map();
       this.filteredGames = [];
       this.currentFilters = {};
       this.customFilters = [];
       this.isSharedView = false;
       this.isEditMode = false;
       this.gameBackups = new Map();
       this.visibleFields = ['name', 'year', 'players', 'playtime', 'weight', 'images', 'notes'];
       this.cardVisibleFields = ['name', 'players'];
       this.dynamicCardFields = [];
this.currentColumns = 5; // Always start with 5 on desktop
this.mobileColumns = 1; // Always start with 1 on mobile
this.gamePreferences = new Map(); // stores thumbs up/down: 'up', 'down', or null
       this.originalSharedPreferences = new Map(); // for shared collections
this.searchTimeout = null;
       this.filterTimeout = null;
this.cacheManager = new CacheManager();
       this.initGoogleDrive();
   }


async init() {
    console.log('Initializing app...');
    this.showLoading('Initializing collection...');
    
// Initialize cache
await this.cacheManager.init();

    // Check for shared view FIRST, before loading any storage
    const isSharedCollection = await this.checkForSharedView();
    console.log('Is shared collection:', isSharedCollection);
    console.log('Games loaded:', this.games.size);
    
    // Only load from storage if it's NOT a shared collection
    if (!isSharedCollection) {
        console.log('Loading from storage...');
        this.showLoading('Loading your collection...');
        await this.loadFromStorage();
    } else {
        console.log('Skipping storage load for shared collection');
    }
    
    this.showLoading('Setting up interface...');
    this.bindEvents();
    const isMobile = window.innerWidth <= 768;
    this.setColumns(isMobile ? 1 : this.currentColumns);
    
    // Initialize filteredGames if not already set
    if (this.filteredGames.length === 0) {
        this.filteredGames = Array.from(this.games.values());
    }
    
    console.log('About to render...', 'Games count:', this.games.size, 'Filtered games:', this.filteredGames.length);
    this.showLoading('Rendering games...');
    this.render();
    
    this.showLoading('Building filters...');
    this.updateDesignerFilter();
this.updatePublisherFilter();
this.updatePublisherCountryDropdownFilter();
this.updateDesignerNationalityFilter();
    this.updateArtistFilter();
    this.updateCategoryFilter();
    this.updateMechanismsFilter();
    this.updateClearThumbsVisibility();

    // Apply shared filters to UI AFTER dropdowns are populated
    if (this.isSharedView && this.currentFilters) {
        this.applyFiltersToUI(this.currentFilters);
        console.log('Applied shared filters to UI after dropdown population');
    }
    
    console.log('About to apply filters...');
    this.applyFilters();
    
console.log('App initialization complete');
    this.hideLoading();
}


// Initialize GitHub file storage
initGoogleDrive() {
    // GitHub storage configuration - replace with your repository details
    this.GITHUB_OWNER = 'jt1919191919'; // Your GitHub username
    this.GITHUB_REPO = 'board-game-tool'; // Your repository name
    this.GITHUB_BRANCH = 'main'; // Usually 'main' or 'master'
    this.GITHUB_FILE_PATH = 'games-data.json'; // File to store your collection
    this.GITHUB_TOKEN = null; // Personal Access Token (user will set this)
    
    this.githubReady = false;
    this.isSignedIn = false;
    
    this.loadGitHubSettings();
}

loadGitHubSettings() {
    try {
        const stored = localStorage.getItem('github-token');
        if (stored) {
            this.GITHUB_TOKEN = stored;
            this.isSignedIn = true;
            this.githubReady = true;
        }
        this.updateGoogleDriveUI();
    } catch (error) {
        console.error('Error loading GitHub settings:', error);
        document.getElementById('google-drive-status').textContent = 'GitHub storage failed - using local storage';
        document.getElementById('google-drive-status').style.color = 'red';
    }





}

async signInToGoogleDrive() {
    const token = prompt('Enter your GitHub Personal Access Token:\n\nTo create one:\n1. Go to GitHub.com → Settings → Developer settings → Personal access tokens\n2. Generate new token (classic)\n3. Select "repo" scope\n4. Copy the token here');
    
    if (token && token.trim()) {
        this.GITHUB_TOKEN = token.trim();
        localStorage.setItem('github-token', this.GITHUB_TOKEN);
        this.isSignedIn = true;
        this.githubReady = true;
        this.updateGoogleDriveUI();
        this.loadFromGitHub();
    }
}

async signOutFromGoogleDrive() {
    try {
        localStorage.removeItem('github-token');
        this.GITHUB_TOKEN = null;
        this.isSignedIn = false;
        this.githubReady = false;
        this.updateGoogleDriveUI();
    } catch (error) {
        console.error('GitHub sign out failed:', error);
    }
}

   handleCredentialResponse(response) {
       // This is for ID tokens, we need OAuth2 tokens for Drive API
       console.log('Credential response received');
   }

showLoading(text = 'Loading...') {
    const overlay = document.getElementById('loading-overlay');
    if (overlay) {
        const textEl = overlay.querySelector('.loading-text');
        if (textEl) textEl.textContent = text;
        overlay.style.display = 'flex';
        // Force a repaint to ensure loading shows immediately
        overlay.offsetHeight;
    }
}

hideLoading() {
    const overlay = document.getElementById('loading-overlay');
    if (overlay) {
        overlay.style.display = 'none';
    }
}


updateGoogleDriveUI() {
    const desktopSignInBtn = document.getElementById('desktop-google-drive-signin');
    const desktopSignOutBtn = document.getElementById('desktop-google-drive-signout');
    const desktopStatus = document.getElementById('desktop-google-drive-status');
    const mobileSignInBtn = document.getElementById('mobile-google-drive-signin');
    const mobileSignOutBtn = document.getElementById('mobile-google-drive-signout');
    const mobileStatus = document.getElementById('mobile-google-drive-status');
    
    const statusText = this.isSignedIn ? 'Connected to GitHub Storage' : 'Not connected to GitHub Storage';
    const statusColor = this.isSignedIn ? 'white' : 'red';
    
    if (desktopSignInBtn && desktopSignOutBtn && desktopStatus) {
        if (this.isSignedIn) {
            desktopSignInBtn.style.display = 'none';
            desktopSignOutBtn.style.display = 'block';
        } else {
            desktopSignInBtn.style.display = 'block';
            desktopSignOutBtn.style.display = 'none';
        }
        desktopSignInBtn.innerHTML = '<i class="fa-solid fa-right-to-bracket"></i> Connect GitHub';
        desktopSignOutBtn.innerHTML = '<i class="fa-solid fa-right-to-bracket"></i> Disconnect GitHub';
        desktopStatus.textContent = statusText;
        desktopStatus.style.color = statusColor;
    }
    
    if (mobileSignInBtn && mobileSignOutBtn && mobileStatus) {
        if (this.isSignedIn) {
            mobileSignInBtn.style.display = 'none';
            mobileSignOutBtn.style.display = 'block';
        } else {
            mobileSignInBtn.style.display = 'block';
            mobileSignOutBtn.style.display = 'none';
        }
        mobileSignInBtn.innerHTML = '<i class="fa-solid fa-right-to-bracket"></i> Connect GitHub';
        mobileSignOutBtn.innerHTML = '<i class="fa-solid fa-right-to-bracket"></i> Disconnect GitHub';
        mobileStatus.textContent = statusText;
        mobileStatus.style.color = statusColor;
    }
}

async saveToGitHub() {
    if (!this.githubReady || !this.isSignedIn || !this.GITHUB_TOKEN) {
        console.log('GitHub not ready, saving to localStorage');
        this.saveToLocalStorage();
        return;
    }

    try {
const data = {
    games: Object.fromEntries(this.games),
    preferences: Object.fromEntries(this.gamePreferences),
    lastModified: new Date().toISOString(),
    version: '1.0'
};

        const content = JSON.stringify(data, null, 2);
        const encodedContent = btoa(unescape(encodeURIComponent(content)));
        
        // Check if file exists
        let sha = null;
        try {
            const getResponse = await fetch(`https://api.github.com/repos/${this.GITHUB_OWNER}/${this.GITHUB_REPO}/contents/${this.GITHUB_FILE_PATH}`, {
                headers: {
                    'Authorization': `token ${this.GITHUB_TOKEN}`,
                    'Accept': 'application/vnd.github.v3+json'
                }
            });
            
            if (getResponse.ok) {
                const fileData = await getResponse.json();
                sha = fileData.sha;
            }
        } catch (error) {
            console.log('File does not exist yet, will create new file');
        }

        // Create or update file
        const updateData = {
            message: `Update board game collection - ${new Date().toLocaleString()}`,
            content: encodedContent,
            branch: this.GITHUB_BRANCH
        };
        
        if (sha) {
            updateData.sha = sha;
        }

        const response = await fetch(`https://api.github.com/repos/${this.GITHUB_OWNER}/${this.GITHUB_REPO}/contents/${this.GITHUB_FILE_PATH}`, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${this.GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(updateData)
        });

        if (!response.ok) {
            throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
        }

        console.log('Saved to GitHub successfully');
        
    } catch (error) {
        console.error('Error saving to GitHub:', error);
        alert('Failed to save to GitHub. Check your token and repository settings. Saving locally instead.');
        this.saveToLocalStorage();
    }
}

async loadFromGitHub() {
    // Don't load from GitHub if we're in shared view
    if (this.isSharedView) {
        console.log('Skipping GitHub load - in shared view');
        return;
    }
    
    if (!this.githubReady || !this.isSignedIn || !this.GITHUB_TOKEN) {
        this.loadFromLocalStorage();
        return;
    }

    try {
        const response = await fetch(`https://api.github.com/repos/${this.GITHUB_OWNER}/${this.GITHUB_REPO}/contents/${this.GITHUB_FILE_PATH}`, {
            headers: {
                'Authorization': `token ${this.GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });

        if (response.ok) {
            const fileData = await response.json();
            const content = decodeURIComponent(escape(atob(fileData.content)));
            const data = JSON.parse(content);
            
            if (data.games) {
                this.games.clear();
                Object.entries(data.games).forEach(([id, game]) => {
                    this.games.set(id, game);
                });
                
                if (data.preferences) {
                    this.gamePreferences.clear();
                    Object.entries(data.preferences).forEach(([id, pref]) => {
                        this.gamePreferences.set(id, pref);
                    });
                }
                console.log('Loaded collection from GitHub');
            }
        } else {
            console.log('No collection file found in GitHub repository');
            this.loadFromLocalStorage();
        }
        
    } catch (error) {
        console.error('Error loading from GitHub:', error);
        this.loadFromLocalStorage();
    }
}

   saveToLocalStorage() {
       try {
           const data = Object.fromEntries(this.games);
           localStorage.setItem('boardgame-collection', JSON.stringify(data, null, 2));
           console.log('Saved to localStorage');
       } catch (e) {
           console.warn('Could not save to localStorage:', e);
       }
   }

loadFromLocalStorage() {
    // Don't load local storage if we're in shared view
    if (this.isSharedView) {
        console.log('Skipping localStorage load - in shared view');
        return;
    }
    
    try {
        const stored = localStorage.getItem('boardgame-collection');
        if (stored) {
            const data = JSON.parse(stored);
            if (data.games) {
                Object.entries(data.games).forEach(([id, game]) => {
                    this.games.set(id, this.migrateGameData(game));
                });
                
                if (data.preferences) {
                    Object.entries(data.preferences).forEach(([id, pref]) => {
                        this.gamePreferences.set(id, pref);
                    });
                }
            } else {
                // Legacy format - data is directly the games object
                Object.entries(data).forEach(([id, game]) => {
                    this.games.set(id, this.migrateGameData(game));
                });
            }
            console.log('Loaded collection from localStorage');
        }
    } catch (e) {
        console.warn('Could not load from localStorage:', e);
    }
    
    // Only load sample data if we have no games AND we're not in shared view
    if (this.games.size === 0 && !this.isSharedView) {
        console.log('Loading sample data...');
        this.loadSampleData();
    }
}

migrateGameData(game) {
    // Auto-migrate comma-separated fields to semicolon-separated
    const fieldsToMigrate = ['designers', 'artists', 'publishers', 'category', 'mechanisms'];
    
    fieldsToMigrate.forEach(field => {
        if (game[field] && typeof game[field] === 'string') {
            // Convert comma-separated string to array, then back to proper array
            game[field] = game[field].split(',').map(s => s.trim()).filter(s => s);
        }
    });
    
    // Handle nationality and country fields
    if (game.designerNationality && typeof game.designerNationality === 'string') {
        game.designerNationality = game.designerNationality.split(',').map(s => s.trim()).filter(s => s);
    }
    if (game.publisherCountry && typeof game.publisherCountry === 'string') {
        game.publisherCountry = game.publisherCountry.split(',').map(s => s.trim()).filter(s => s);
    }
    
    return game;
}

async saveToStorage() {
    if (!this.isSharedView) {
        if (this.githubReady && this.isSignedIn) {
            await this.saveToGitHub();
        } else {
            this.saveToLocalStorage();
        }
        // Also save to cache
        await this.saveToCache();
    }
}

async loadFromStorage() {
    // Don't load from storage if we're in shared view
    if (this.isSharedView) {
        console.log('Skipping storage load - in shared view');
        return;
    }
    
    // Try cache first, then fallback to storage
    const cacheLoaded = await this.loadFromCache();
    if (!cacheLoaded) {
        if (this.githubReady && this.isSignedIn) {
            await this.loadFromGitHub();
        } else {
            this.loadFromLocalStorage();
        }
    }
}


async loadFromCache() {
    if (!this.cacheManager.isReady) return false;
    
    try {
        const cachedGames = await this.cacheManager.getMetadata('games');
        const cachedPreferences = await this.cacheManager.getMetadata('preferences');
        const lastCached = await this.cacheManager.getMetadata('lastCached');
        
        // Only use cache if it's recent (within 1 hour for GitHub sync)
        if (lastCached) {
            const cacheAge = Date.now() - new Date(lastCached).getTime();
            const maxAge = 60 * 60 * 1000; // 1 hour
            if (cacheAge > maxAge) {
                console.log('Cache is stale, will refresh from storage');
                return false;
            }
        }
        
        if (cachedGames && Object.keys(cachedGames).length > 0) {
            this.games.clear();
            Object.entries(cachedGames).forEach(([id, game]) => {
                this.games.set(id, game);
            });
            
            if (cachedPreferences) {
                this.gamePreferences.clear();
                Object.entries(cachedPreferences).forEach(([id, pref]) => {
                    this.gamePreferences.set(id, pref);
                });
            }
            
            console.log('Loaded collection from cache');
            // Preload cached images in background
            this.preloadCachedImages();
            return true;
        }
    } catch (error) {
        console.error('Error loading from cache:', error);
    }
    
    return false;
}

async preloadCachedImages() {
    // Preload images from cache in background
    const allImages = Array.from(this.games.values()).flatMap(game => game.images || []);
    for (const imageUrl of allImages) {
        try {
            const cachedUrl = await this.cacheManager.getCachedImageUrl(imageUrl);
            if (cachedUrl) {
                // Preload in background
                const img = new Image();
                img.src = cachedUrl;
            }
        } catch (error) {
            // Ignore errors, this is just preloading
        }
    }
}

async saveToCache() {
    if (!this.cacheManager.isReady) return;
    
    try {
        const gamesData = Object.fromEntries(this.games);
        const preferencesData = Object.fromEntries(this.gamePreferences);
        
        await this.cacheManager.setMetadata('games', gamesData);
        await this.cacheManager.setMetadata('preferences', preferencesData);
        await this.cacheManager.setMetadata('lastCached', new Date().toISOString());
        
        console.log('Saved collection to cache');
    } catch (error) {
        console.error('Error saving to cache:', error);
    }
}

async refreshCache() {
    if (!this.cacheManager.isReady) return;
    
    const cacheOverlay = document.getElementById('cache-loading');
    const progressFill = document.getElementById('cache-progress-fill');
    const statusText = document.getElementById('cache-status');
    
    try {
        cacheOverlay.style.display = 'flex';
statusText.textContent = 'Loading game collection';
        progressFill.style.width = '10%';
        
        await this.cacheManager.clearCache();
        
        // Cache all games
        const games = Array.from(this.games.values());
        for (let i = 0; i < games.length; i++) {
statusText.textContent = `Loading collection - caching game ${i + 1} of ${games.length}`;
            await this.cacheManager.cacheGame(games[i]);
            const progress = 10 + (i / games.length) * 60;
            progressFill.style.width = `${progress}%`;
        }
        
        // Cache images
        const allImages = games.flatMap(game => game.images || []);
        for (let i = 0; i < allImages.length; i++) {
statusText.textContent = `Loading collection - caching image ${i + 1} of ${allImages.length}`;
            try {
                const response = await fetch(allImages[i]);
                if (response.ok) {
                    const blob = await response.blob();
                    await this.cacheManager.cacheImage(allImages[i], blob);
                }
            } catch (error) {
                console.warn('Failed to cache image:', allImages[i]);
            }
            const progress = 70 + (i / allImages.length) * 25;
            progressFill.style.width = `${progress}%`;
        }
        
        statusText.textContent = 'Loading collection - finalizing cache';
        progressFill.style.width = '95%';
        
        await this.saveToCache();
        
        progressFill.style.width = '100%';
        statusText.textContent = 'Collection loaded successfully!';
        
        setTimeout(() => {
            cacheOverlay.style.display = 'none';
        }, 1000);
        
    } catch (error) {
        console.error('Cache refresh failed:', error);
        statusText.textContent = 'Cache refresh failed';
        setTimeout(() => {
            cacheOverlay.style.display = 'none';
        }, 2000);
    }
}

   loadSampleData() {
       const sampleGames = [
           {
               bggId: '161936',
               bggUrl: 'https://boardgamegeek.com/boardgame/161936/pandemic-legacy-season-1',
               name: 'Pandemic Legacy: Season 1',
year: 2015,
               dateAcquired: '1991-11-19',
               players: { min: 2, max: 4 },
               playtime: { min: 60, max: 60 },
               weight: 2.83,
               bestPlayerCount: [3, 4],
               designers: ['Rob Daviau', 'Matt Leacock'],
               artists: ['Chris Quilliams'],
               publishers: ['Z-Man Games'],
               images: [
                   'https://cf.geekdo-images.com/S3ybV1LAp-8SnHIXLLjVHg__itemrep/img/EdBzaOvIMm_O0-2T9lFpiRnYNhI=/fit-in/246x300/filters:strip_icc()/pic2452831.png'
               ],
               notes: 'Incredible campaign game that evolves as you play. Best with 4 players for maximum discussion.',
               customFields: { owned: true, condition: 'Like New' }
           },
           {
               bggId: '167791',
               bggUrl: 'https://boardgamegeek.com/boardgame/167791/terraforming-mars',
               name: 'Terraforming Mars',
year: 2016,
               dateAcquired: '1991-11-19',
               players: { min: 1, max: 5 },
               playtime: { min: 90, max: 120 },
               weight: 3.25,
               bestPlayerCount: [3, 4],
               designers: ['Jacob Fryxelius'],
               artists: ['Isaac Fryxelius'],
               publishers: ['FryxGames'],
               images: [
                   'https://cf.geekdo-images.com/wg9oOLcsKvDesSUdZQ4rxw__itemrep/img/BTkTHO7-8nYRb-DbkY5xNrfI5fI=/fit-in/246x300/filters:strip_icc()/pic3536616.jpg'
               ],
               notes: 'Great engine building game with excellent theme. Takes a while to learn but very rewarding.',
               customFields: { owned: true, condition: 'Very Good' }
           }
       ];

       sampleGames.forEach(game => {
           this.games.set(game.bggId, game);
       });
   }


async checkForSharedView() {
    console.log('Checking for shared view...');
    const urlParams = new URLSearchParams(window.location.search);
    const gistId = urlParams.get('gist');
    const legacySharedData = urlParams.get('share');
    
    console.log('Gist ID parameter:', gistId ? 'Found' : 'Not found');
    console.log('Legacy shared data parameter:', legacySharedData ? 'Found' : 'Not found');
    
    // Try Gist first
    if (gistId) {
        try {
            console.log('Attempting to load shared collection from Gist...');
            
            const response = await fetch(`https://api.github.com/gists/${gistId}`, {
                headers: {
                    'Accept': 'application/vnd.github.v3+json'
                }
            });

            if (!response.ok) {
                throw new Error(`Failed to fetch Gist: ${response.status} ${response.statusText}`);
            }

            const gist = await response.json();
            const fileContent = gist.files['board-game-collection.json'];
            
            if (!fileContent) {
                throw new Error('Board game collection file not found in Gist');
            }

            const config = JSON.parse(fileContent.content);
            console.log('Parsed Gist config:', config);
            
            if (config.games && config.games.length > 0) {
                console.log(`Loading ${config.games.length} shared games from Gist...`);
                
                // Clear existing games and load shared ones
                this.games.clear();
                this.gamePreferences.clear();
                
                config.games.forEach((game, index) => {
                    const gameId = game.bggId || `shared-${index}`;
                    this.games.set(gameId, game);
                    console.log(`Added shared game: ${game.name}`);
                });
           

// Apply shared configuration
                if (config.filters) {
                    this.currentFilters = config.filters;
                    // Don't apply filters to UI yet - will do this after dropdowns are populated
                    console.log('Applied shared filters:', config.filters);
                }
                if (config.columns) {
                    this.currentColumns = config.columns;
                }
                if (config.preferences) {
                    Object.entries(config.preferences).forEach(([gameId, pref]) => {
                        this.gamePreferences.set(gameId, pref);
                        this.originalSharedPreferences.set(gameId, pref);
                    });
                    console.log('Applied shared preferences:', config.preferences);
                }
                
// Set shared view mode
this.isSharedView = true;
this.originalSharedFilters = JSON.parse(JSON.stringify(config.filters || {}));
this.originalSharedPreferences = new Map(Object.entries(config.preferences || {}));
this.originalSharedSortField = config.sortField || 'name';
this.originalSharedSortOrder = config.sortOrder || 'asc';

// Apply sort settings to UI
if (config.sortField) {
    document.getElementById('sort-field').value = config.sortField;
}
if (config.sortOrder) {
    document.getElementById('sort-order').value = config.sortOrder;
}
                
                console.log(`Successfully loaded shared collection with ${config.games.length} games`);
                return true;
            } else {
                console.log('No games found in Gist config');
            }
        } catch (error) {
            console.error('Error loading shared collection from Gist:', error);
            console.error('Error details:', error.message);
        }
    }
    
    // Fallback to legacy URL parameter method
    if (legacySharedData) {
        try {
            console.log('Attempting to decode legacy shared data...');
            const decodedData = decodeURIComponent(escape(atob(legacySharedData)));
            console.log('Decoded data length:', decodedData.length);
            
            const config = JSON.parse(decodedData);
            console.log('Parsed legacy config:', config);
            
            if (config.games && config.games.length > 0) {
                console.log(`Loading ${config.games.length} shared games...`);
                
                // Clear existing games and load shared ones
                this.games.clear();
                this.gamePreferences.clear();
                
                config.games.forEach((game, index) => {
                    const gameId = game.bggId || `shared-${index}`;
                    this.games.set(gameId, game);
                    console.log(`Added shared game: ${game.name}`);
                });
                
// Apply shared configuration
                if (config.filters) {
                    this.currentFilters = config.filters;
                    // Don't apply filters to UI yet - will do this after dropdowns are populated
                    console.log('Applied shared filters:', config.filters);
                }
                if (config.columns) {
                    this.currentColumns = config.columns;
                }
                if (config.preferences) {
                    Object.entries(config.preferences).forEach(([gameId, pref]) => {
                        this.gamePreferences.set(gameId, pref);
                        this.originalSharedPreferences.set(gameId, pref);
                    });
                    console.log('Applied shared preferences:', config.preferences);
                }
                
// Set shared view mode
this.isSharedView = true;
this.originalSharedFilters = JSON.parse(JSON.stringify(config.filters || {}));
this.originalSharedPreferences = new Map(Object.entries(config.preferences || {}));
this.originalSharedSortField = config.sortField || 'name';
this.originalSharedSortOrder = config.sortOrder || 'asc';

// Apply sort settings to UI
if (config.sortField) {
    document.getElementById('sort-field').value = config.sortField;
}
if (config.sortOrder) {
    document.getElementById('sort-order').value = config.sortOrder;
}

console.log(`Successfully loaded shared collection with ${config.games.length} games`);
return true;
            } else {
                console.log('No games found in shared config');
            }
        } catch (error) {
            console.error('Error loading legacy shared collection:', error);
            console.error('Error details:', error.message);
        }
    }
    
    return false;
}


applyFiltersToUI(filters) {
    // Apply filters to the UI form fields so the filtering logic works
    if (filters.search) {
        document.getElementById('search').value = filters.search;
        document.getElementById('mobile-search').value = filters.search;
    }
    if (filters.minPlayers) {
        document.getElementById('min-players').value = filters.minPlayers;
        document.getElementById('min-players-type').value = filters.minPlayersType || 'greater';
    }
    if (filters.maxPlayers) {
        document.getElementById('max-players').value = filters.maxPlayers;
        document.getElementById('max-players-type').value = filters.maxPlayersType || 'less';
    }
    if (filters.minPlaytime) {
        document.getElementById('min-playtime').value = filters.minPlaytime;
        document.getElementById('min-playtime-type').value = filters.minPlaytimeType || 'greater';
    }
    if (filters.maxPlaytime) {
        document.getElementById('max-playtime').value = filters.maxPlaytime;
        document.getElementById('max-playtime-type').value = filters.maxPlaytimeType || 'less';
    }
    if (filters.year) {
        document.getElementById('year-filter').value = filters.year;
        document.getElementById('year-filter-type').value = filters.yearType || 'exact';
    }
    if (filters.publisher) {
        document.getElementById('publisher-filter').value = filters.publisher;
        document.getElementById('publisher-filter-type').value = filters.publisherType || 'contains';
    }
    if (filters.minWeight) {
        document.getElementById('min-weight').value = filters.minWeight;
        document.getElementById('min-weight-type').value = filters.minWeightType || 'greater';
    }
    if (filters.maxWeight) {
        document.getElementById('max-weight').value = filters.maxWeight;
        document.getElementById('max-weight-type').value = filters.maxWeightType || 'less';
    }
    if (filters.bestPlayerCount) {
        document.getElementById('best-player-count-filter').value = filters.bestPlayerCount;
    }
    if (filters.notes) {
        document.getElementById('notes-filter').value = filters.notes;
        document.getElementById('notes-filter-type').value = filters.notesType || 'contains';
    }
if (filters.dateAcquired) {
        document.getElementById('date-acquired-filter').value = filters.dateAcquired;
        document.getElementById('date-acquired-filter-type').value = filters.dateAcquiredType || 'exact';
    }
    if (filters.designerContains) {
        document.getElementById('designer-contains-filter').value = filters.designerContains;
        document.getElementById('designer-contains-filter-type').value = filters.designerContainsType || 'contains';
    }
    if (filters.designerNationalityContains) {
        document.getElementById('designer-nationality-contains-filter').value = filters.designerNationalityContains;
        document.getElementById('designer-nationality-contains-filter-type').value = filters.designerNationalityContainsType || 'contains';
    }
    if (filters.artistContains) {
        document.getElementById('artist-contains-filter').value = filters.artistContains;
        document.getElementById('artist-contains-filter-type').value = filters.artistContainsType || 'contains';
    }
if (filters.publisherCountry) {
        document.getElementById('publisher-country-filter').value = filters.publisherCountry;
        document.getElementById('publisher-country-filter-type').value = filters.publisherCountryType || 'contains';
    }
if (filters.description) {
        document.getElementById('description-filter').value = filters.description;
        document.getElementById('description-filter-type').value = filters.descriptionType || 'contains';
    }
    if (filters.categoryContains) {
        document.getElementById('category-contains-filter').value = filters.categoryContains;
        document.getElementById('category-contains-filter-type').value = filters.categoryContainsType || 'contains';
    }
if (filters.mechanismsContains) {
    document.getElementById('mechanisms-contains-filter').value = filters.mechanismsContains;
    document.getElementById('mechanisms-contains-filter-type').value = filters.mechanismsContainsType || 'contains';
}

    // Apply multiselect filters
    if (filters.designer && Array.isArray(filters.designer)) {
        document.querySelectorAll('#designer-filter-options input[type="checkbox"]').forEach(cb => {
            cb.checked = filters.designer.includes(cb.value);
        });
    }
    if (filters.designerNationality && Array.isArray(filters.designerNationality)) {
        document.querySelectorAll('#designer-nationality-filter-options input[type="checkbox"]').forEach(cb => {
            cb.checked = filters.designerNationality.includes(cb.value);
        });
    }
    if (filters.artist && Array.isArray(filters.artist)) {
        document.querySelectorAll('#artist-filter-options input[type="checkbox"]').forEach(cb => {
            cb.checked = filters.artist.includes(cb.value);
        });
    }
    if (filters.publisherDropdown && Array.isArray(filters.publisherDropdown)) {
        document.querySelectorAll('#publisher-dropdown-filter-options input[type="checkbox"]').forEach(cb => {
            cb.checked = filters.publisherDropdown.includes(cb.value);
        });
    }
if (filters.publisherCountryDropdown && Array.isArray(filters.publisherCountryDropdown)) {
        document.querySelectorAll('#publisher-country-dropdown-filter-options input[type="checkbox"]').forEach(cb => {
            cb.checked = filters.publisherCountryDropdown.includes(cb.value);
        });
    }
    if (filters.category && Array.isArray(filters.category)) {
        document.querySelectorAll('#category-filter-options input[type="checkbox"]').forEach(cb => {
            cb.checked = filters.category.includes(cb.value);
        });
    }
    if (filters.mechanisms && Array.isArray(filters.mechanisms)) {
        document.querySelectorAll('#mechanisms-filter-options input[type="checkbox"]').forEach(cb => {
            cb.checked = filters.mechanisms.includes(cb.value);
        });
    }
}

bindEvents() {
       console.log('Starting bindEvents...');
       

// Search functionality with debouncing
       const searchElement = document.getElementById('search');
       console.log('search element:', searchElement);
       if (searchElement) {
searchElement.addEventListener('input', (e) => {
               this.currentFilters.search = e.target.value;
               const mobileSearch = document.getElementById('mobile-search');
               if (mobileSearch) mobileSearch.value = e.target.value;
               this.updateDynamicCardFields();
               
               // Show loading immediately when typing
               if (e.target.value.length > 0) {
                   this.showLoading('Searching...');
               }
               
// Debounce search
               clearTimeout(this.searchTimeout);
               this.searchTimeout = setTimeout(() => {
                   this.applyFilters();
               }, 800);
           });
       }

const mobileSearchElement = document.getElementById('mobile-search');
       console.log('mobile-search element:', mobileSearchElement);
       if (mobileSearchElement) {
mobileSearchElement.addEventListener('input', (e) => {
               this.currentFilters.search = e.target.value;
               const mainSearch = document.getElementById('search');
               if (mainSearch) mainSearch.value = e.target.value;
               this.updateDynamicCardFields();
               
// Debounce search
               clearTimeout(this.searchTimeout);
               this.searchTimeout = setTimeout(() => {
                   this.applyFilters();
               }, 800);
           });
       }

// Setup clear search functionality
this.setupClearSearch('search', 'search-clear');
this.setupClearSearch('mobile-search', 'mobile-search-clear');

// Mobile menu
       const hamburgerBtn = document.getElementById('hamburger-btn');
       if (hamburgerBtn) {
           hamburgerBtn.addEventListener('click', (e) => {
               e.stopPropagation();
               const mobileMenu = document.getElementById('mobile-menu');
if (mobileMenu) {
                   const isOpen = mobileMenu.classList.contains('show');
                   if (!isOpen) {
                       history.pushState(null, '', window.location.href);
                   }
                   mobileMenu.classList.toggle('show');
                   hamburgerBtn.classList.toggle('open');
                   hamburgerBtn.innerHTML = isOpen ? '☰' : '✕';
               }
           });
       }

       // Desktop menu
       const desktopHamburgerBtn = document.getElementById('desktop-hamburger-btn');
       if (desktopHamburgerBtn) {
           desktopHamburgerBtn.addEventListener('click', (e) => {
               e.stopPropagation();
               const desktopMenu = document.getElementById('desktop-menu');
               if (desktopMenu) {
                   const isOpen = desktopMenu.classList.contains('show');
                   desktopMenu.classList.toggle('show');
                   desktopHamburgerBtn.classList.toggle('open');
                   desktopHamburgerBtn.innerHTML = isOpen ? '<i class="fa-solid fa-circle-user"></i>' : '✕';
               }
           });
       }

document.addEventListener('click', (e) => {
           const menu = document.getElementById('mobile-menu');
           const hamburger = document.getElementById('hamburger-btn');
           if (menu && hamburger && !menu.contains(e.target) && !hamburger.contains(e.target)) {
               menu.classList.remove('show');
               hamburger.classList.remove('open');
               hamburger.innerHTML = '☰';
           }
           
           const desktopMenu = document.getElementById('desktop-menu');
           const desktopHamburger = document.getElementById('desktop-hamburger-btn');
           if (desktopMenu && desktopHamburger && !desktopMenu.contains(e.target) && !desktopHamburger.contains(e.target)) {
               desktopMenu.classList.remove('show');
               desktopHamburger.classList.remove('open');
               desktopHamburger.innerHTML = '<i class="fa-solid fa-circle-user"></i>';
           }
       });

       // Close menus when menu buttons are clicked
       document.addEventListener('click', (e) => {
           // Mobile menu buttons
           if (e.target.closest('#mobile-menu .btn')) {
               const menu = document.getElementById('mobile-menu');
               const hamburger = document.getElementById('hamburger-btn');
               if (menu && hamburger) {
                   menu.classList.remove('show');
                   hamburger.classList.remove('open');
                   hamburger.innerHTML = '☰';
               }
           }
           
           // Desktop menu buttons
           if (e.target.closest('#desktop-menu .btn')) {
               const desktopMenu = document.getElementById('desktop-menu');
               const desktopHamburger = document.getElementById('desktop-hamburger-btn');
               if (desktopMenu && desktopHamburger) {
                   desktopMenu.classList.remove('show');
                   desktopHamburger.classList.remove('open');
                   desktopHamburger.innerHTML = '<i class="fa-solid fa-circle-user"></i>';
               }
           }
       });

// Filter controls
const toggleFiltersBtn = document.getElementById('toggle-filters');
       if (toggleFiltersBtn) {
           toggleFiltersBtn.addEventListener('click', () => {
               const filters = document.getElementById('filters');
               const icon = toggleFiltersBtn.querySelector('i');
               if (filters) {
                   const isShowing = filters.classList.contains('show');
                   filters.classList.toggle('show');
                   
                   if (isShowing) {
                       // Closing filters
                       icon.className = 'fa-solid fa-arrow-down-wide-short';
                       toggleFiltersBtn.style.backgroundColor = '';
                       toggleFiltersBtn.style.border = '';
                   } else {
                       // Opening filters
                       icon.className = 'fa-solid fa-angle-up';
                       toggleFiltersBtn.style.backgroundColor = '#744ea600';
                       toggleFiltersBtn.style.border = '1px solid #ffffff';
                       window.scrollTo({ top: 0, behavior: 'smooth' });
                   }
               }
           });
       }

const mobileToggleFiltersBtn = document.getElementById('mobile-toggle-filters');
       if (mobileToggleFiltersBtn) {
           mobileToggleFiltersBtn.addEventListener('click', () => {
               const filters = document.getElementById('filters');
               const icon = mobileToggleFiltersBtn.querySelector('i');
               if (filters) {
                   const isShowing = filters.classList.contains('show');
                   filters.classList.toggle('show');
                   
                   if (isShowing) {
                       // Closing filters
                       icon.className = 'fa-solid fa-arrow-down-wide-short';
                       mobileToggleFiltersBtn.style.backgroundColor = '';
                       mobileToggleFiltersBtn.style.border = '';
                   } else {
                       // Opening filters
                       icon.className = 'fa-solid fa-angle-up';
                       mobileToggleFiltersBtn.style.backgroundColor = '#744ea600';
                       mobileToggleFiltersBtn.style.border = '1px solid #ffffff';
                       window.scrollTo({ top: 0, behavior: 'smooth' });
                   }
               }
           });
       }

// Filter inputs
const filterInputs = [
    'min-players', 'max-players', 'min-playtime', 'max-playtime', 
    'year-filter', 'date-acquired-filter', 'publisher-filter', 'designer-contains-filter', 
    'artist-filter', 'artist-contains-filter', 'designer-nationality-contains-filter', 
    'designer-nationality-filter', 'publisher-country-filter', 'min-weight', 'max-weight',
'best-player-count-filter', 'notes-filter', 'description-filter',
'category-contains-filter', 'mechanisms-contains-filter', 'type-contains-filter'
];
       
filterInputs.forEach(id => {
           const element = document.getElementById(id);
           if (element) {
element.addEventListener('input', () => {
                   this.updateFilters();
                   this.updateDynamicCardFields();
                   
// Debounce filtering
clearTimeout(this.filterTimeout);
this.filterTimeout = setTimeout(() => {
    this.applyFilters();
}, 500);
               });
           }
           
           const typeSelect = document.getElementById(id + '-type');
           if (typeSelect) {
               typeSelect.addEventListener('change', () => {
                   this.updateFilters();
                   this.applyFilters();
               });
           }
       });

// Auto-update weight color when weight changes in add game form
       const gameWeightInput = document.getElementById('game-weight');
       const gameWeightColorSelect = document.getElementById('game-weight-color');
       if (gameWeightInput && gameWeightColorSelect) {
           gameWeightInput.addEventListener('input', () => {
               const weight = parseFloat(gameWeightInput.value);
               if (!isNaN(weight)) {
let defaultColor = '#008000';
if (weight >= 2.5) {
    defaultColor = '#ff0000';
} else if (weight >= 1.9) {
    defaultColor = '#cfa200';
}
                   gameWeightColorSelect.value = defaultColor;
               }
           });
       }

const designerFilter = document.getElementById('designer-filter');
       if (designerFilter) {
           designerFilter.addEventListener('change', () => {
               this.updateFilters();
               this.applyFilters();
           });
       }

const publisherDropdownFilter = document.getElementById('publisher-dropdown-filter');
       if (publisherDropdownFilter) {
           publisherDropdownFilter.addEventListener('change', () => {
               this.updateFilters();
               this.applyFilters();
           });
       }

const publisherCountryDropdownFilter = document.getElementById('publisher-country-dropdown-filter');
       if (publisherCountryDropdownFilter) {
           publisherCountryDropdownFilter.addEventListener('change', () => {
               this.updateFilters();
               this.applyFilters();
           });
       }

const designerNationalityFilter = document.getElementById('designer-nationality-filter');
       if (designerNationalityFilter) {
           designerNationalityFilter.addEventListener('change', () => {
               this.updateFilters();
               this.applyFilters();
           });
       }

const artistFilter = document.getElementById('artist-filter');
if (artistFilter) {
    artistFilter.addEventListener('change', () => {
        this.updateFilters();
        this.applyFilters();
    });
}

const categoryFilter = document.getElementById('category-filter');
if (categoryFilter) {
    categoryFilter.addEventListener('change', () => {
        this.updateFilters();
        this.applyFilters();
    });
}

const mechanismsFilter = document.getElementById('mechanisms-filter');
if (mechanismsFilter) {
    mechanismsFilter.addEventListener('change', () => {
        this.updateFilters();
        this.applyFilters();
    });
}

const typeFilter = document.getElementById('type-filter');
if (typeFilter) {
    typeFilter.addEventListener('change', () => {
        this.updateFilters();
        this.applyFilters();
    });
}

       // Sort controls - combined event handlers
       const sortFieldElement = document.getElementById('sort-field');
       if (sortFieldElement) {
           sortFieldElement.addEventListener('change', () => {
               this.updateDynamicCardFields();
               this.applyFilters();
           });
       }
       
const sortOrderElement = document.getElementById('sort-order');
       if (sortOrderElement) {
           sortOrderElement.addEventListener('change', () => this.applyFilters());
       }

       // Clear filters
const clearFiltersBtn = document.getElementById('clear-filters');
       if (clearFiltersBtn) {
           clearFiltersBtn.addEventListener('click', () => {
               this.clearFilters();
           });
       }


// Clear thumbs
const clearThumbsBtn = document.getElementById('clear-thumbs-btn');
if (clearThumbsBtn) {
    clearThumbsBtn.addEventListener('click', () => {
        this.clearThumbs();
    });
}

const mobileClearThumbsBtn = document.getElementById('mobile-clear-thumbs-btn');
if (mobileClearThumbsBtn) {
    mobileClearThumbsBtn.addEventListener('click', () => {
        this.clearThumbs();
    });
}

       // Custom filters
const addCustomFilterBtn = document.getElementById('add-custom-filter');
if (addCustomFilterBtn) {
    addCustomFilterBtn.addEventListener('click', () => {
        this.addCustomFilter();
    });
}


// Edit mode buttons - Mobile
const mobileEditModeBtn = document.getElementById('mobile-edit-mode-btn');
if (mobileEditModeBtn) {
    mobileEditModeBtn.addEventListener('click', () => {
        this.toggleEditMode();
        const mobileMenu = document.getElementById('mobile-menu');
        const hamburger = document.getElementById('hamburger-btn');
        if (mobileMenu) mobileMenu.classList.remove('show');
        if (hamburger) {
            hamburger.classList.remove('open');
            hamburger.innerHTML = '☰';
        }
    });
}


// Edit mode buttons - Desktop  
const desktopEditModeBtn = document.getElementById('desktop-edit-mode-btn');
if (desktopEditModeBtn) {
    desktopEditModeBtn.addEventListener('click', () => {
        this.toggleEditMode();
        const desktopMenu = document.getElementById('desktop-menu');
        if (desktopMenu) desktopMenu.classList.remove('show');
    });
}

// Column controls
const columnsControl = document.getElementById('columns-control');
if (columnsControl) {
    columnsControl.addEventListener('click', () => {
        this.cycleColumns();
    });
}

// Add game form - check if elements exist before adding listeners
const addGameBtn = document.getElementById('add-game-btn');
       if (addGameBtn) {
           addGameBtn.addEventListener('click', () => {
               document.getElementById('add-game-form').classList.add('show');
               window.scrollTo({ top: 0, behavior: 'smooth' });
           });
       }

       const mobileAddGameBtn = document.getElementById('mobile-add-game-btn');
       if (mobileAddGameBtn) {
           mobileAddGameBtn.addEventListener('click', () => {
               document.getElementById('add-game-form').classList.add('show');
               const mobileMenu = document.getElementById('mobile-menu');
               const hamburger = document.getElementById('hamburger-btn');
               if (mobileMenu) mobileMenu.classList.remove('show');
               if (hamburger) {
                   hamburger.classList.remove('open');
                   hamburger.innerHTML = '☰';
               }
               window.scrollTo({ top: 0, behavior: 'smooth' });
           });
       }

       document.getElementById('close-form').addEventListener('click', () => {
           this.closeForm();
       });

       document.getElementById('cancel-add').addEventListener('click', () => {
           this.closeForm();
       });

       document.getElementById('fetch-bgg-data').addEventListener('click', () => {
           this.fetchBGGData();
       });

       document.getElementById('save-game').addEventListener('click', () => {
           this.saveGame();
       });


// Share and export - only add listeners for mobile buttons since desktop buttons are now in menu
       const mobileShareBtn = document.getElementById('mobile-share-btn');
       if (mobileShareBtn) {
           mobileShareBtn.addEventListener('click', () => {
               this.shareCollection();
               document.getElementById('mobile-menu').classList.remove('show');
           });
       }

       const mobileExportBtn = document.getElementById('mobile-export-btn');
       if (mobileExportBtn) {
           mobileExportBtn.addEventListener('click', () => {
               this.exportData();
               document.getElementById('mobile-menu').classList.remove('show');
           });
       }

       const mobileImportBtn = document.getElementById('mobile-import-btn');
       if (mobileImportBtn) {
           mobileImportBtn.addEventListener('click', () => {
               document.getElementById('import-file').click();
               document.getElementById('mobile-menu').classList.remove('show');
           });
       }

const mobileRefreshCacheBtn = document.getElementById('mobile-refresh-cache-btn');
       if (mobileRefreshCacheBtn) {
           mobileRefreshCacheBtn.addEventListener('click', () => {
               this.refreshCache();
               document.getElementById('mobile-menu').classList.remove('show');
           });
       }

       document.getElementById('import-file').addEventListener('change', (e) => {
           this.importData(e.target.files[0]);
       });


// Desktop menu controls
       document.getElementById('desktop-add-game-btn').addEventListener('click', () => {
           document.getElementById('add-game-form').classList.add('show');
           document.getElementById('desktop-menu').classList.remove('show');
           window.scrollTo({ top: 0, behavior: 'smooth' });
       });

// Header edit mode controls
const saveChangesBtnHeader = document.getElementById('save-changes-btn');
if (saveChangesBtnHeader) {
    saveChangesBtnHeader.addEventListener('click', () => {
        this.saveAllChanges();
    });
}

const discardChangesBtnHeader = document.getElementById('discard-changes-btn');
if (discardChangesBtnHeader) {
    discardChangesBtnHeader.addEventListener('click', () => {
        this.discardAllChanges();
    });
}

const mobileSaveChangesBtnHeader = document.getElementById('mobile-save-changes-btn-header');
if (mobileSaveChangesBtnHeader) {
    mobileSaveChangesBtnHeader.addEventListener('click', () => {
        this.saveAllChanges();
    });
}

const mobileDiscardChangesBtnHeader = document.getElementById('mobile-discard-changes-btn-header');
if (mobileDiscardChangesBtnHeader) {
    mobileDiscardChangesBtnHeader.addEventListener('click', () => {
        this.discardAllChanges();
    });
}


// Desktop menu button event listeners
       const desktopShareBtn = document.getElementById('desktop-share-btn');
       if (desktopShareBtn) {
           desktopShareBtn.addEventListener('click', () => {
               this.shareCollection();
               document.getElementById('desktop-menu').classList.remove('show');
           });
       }

       const desktopExportBtn = document.getElementById('desktop-export-btn');
       if (desktopExportBtn) {
           desktopExportBtn.addEventListener('click', () => {
               this.exportData();
               document.getElementById('desktop-menu').classList.remove('show');
           });
       }

       const desktopImportBtn = document.getElementById('desktop-import-btn');
       if (desktopImportBtn) {
           desktopImportBtn.addEventListener('click', () => {
               document.getElementById('import-file').click();
               document.getElementById('desktop-menu').classList.remove('show');
           });
       }

const desktopRefreshCacheBtn = document.getElementById('desktop-refresh-cache-btn');
       if (desktopRefreshCacheBtn) {
           desktopRefreshCacheBtn.addEventListener('click', () => {
               this.refreshCache();
               document.getElementById('desktop-menu').classList.remove('show');
           });
       }

       const desktopGoogleDriveSignin = document.getElementById('desktop-google-drive-signin');
       if (desktopGoogleDriveSignin) {
           desktopGoogleDriveSignin.addEventListener('click', () => {
               this.signInToGoogleDrive();
               document.getElementById('desktop-menu').classList.remove('show');
           });
       }

       const desktopGoogleDriveSignout = document.getElementById('desktop-google-drive-signout');
       if (desktopGoogleDriveSignout) {
           desktopGoogleDriveSignout.addEventListener('click', () => {
               this.signOutFromGoogleDrive();
               document.getElementById('desktop-menu').classList.remove('show');
           });
       }

       // Mobile Google Drive controls
       const mobileGoogleDriveSignin = document.getElementById('mobile-google-drive-signin');
       if (mobileGoogleDriveSignin) {
           mobileGoogleDriveSignin.addEventListener('click', () => {
               this.signInToGoogleDrive();
               document.getElementById('mobile-menu').classList.remove('show');
           });
       }

       const mobileGoogleDriveSignout = document.getElementById('mobile-google-drive-signout');
       if (mobileGoogleDriveSignout) {
           mobileGoogleDriveSignout.addEventListener('click', () => {
               this.signOutFromGoogleDrive();
               document.getElementById('mobile-menu').classList.remove('show');
           });
       }

// Modal events
       document.addEventListener('click', (e) => {
           if (e.target.id === 'game-modal') {
               this.closeModal();
           }
           if (e.target.id === 'lightbox-modal') {
               this.closeLightbox();
           }
       });

       // Keyboard and browser back button support
       document.addEventListener('keydown', (e) => {
           if (e.key === 'Escape') {
               // Close modals first, then menus
               const gameModal = document.getElementById('game-modal');
               const lightboxModal = document.getElementById('lightbox-modal');
               const mobileMenu = document.getElementById('mobile-menu');
               const desktopMenu = document.getElementById('desktop-menu');
               const hamburger = document.getElementById('hamburger-btn');
               const desktopHamburger = document.getElementById('desktop-hamburger-btn');
               
               if (gameModal && gameModal.style.display === 'block') {
                   this.closeModal();
               } else if (lightboxModal && lightboxModal.style.display === 'block') {
                   this.closeLightbox();
               } else if (mobileMenu && mobileMenu.classList.contains('show')) {
                   mobileMenu.classList.remove('show');
                   if (hamburger) {
                       hamburger.classList.remove('open');
                       hamburger.innerHTML = '☰';
                   }
               } else if (desktopMenu && desktopMenu.classList.contains('show')) {
                   desktopMenu.classList.remove('show');
                   if (desktopHamburger) {
                       desktopHamburger.classList.remove('open');
                       desktopHamburger.innerHTML = '<i class="fa-solid fa-circle-user"></i>';
                   }
               }
           }
       });


// Browser back button support
       window.addEventListener('popstate', (e) => {
           e.preventDefault();
           
           const gameModal = document.getElementById('game-modal');
           const lightboxModal = document.getElementById('lightbox-modal');
           const mobileMenu = document.getElementById('mobile-menu');
           const desktopMenu = document.getElementById('desktop-menu');
           const addGameForm = document.getElementById('add-game-form');
           const hamburger = document.getElementById('hamburger-btn');
           const desktopHamburger = document.getElementById('desktop-hamburger-btn');
           
           let somethingWasClosed = false;
           
           if (lightboxModal && lightboxModal.style.display === 'block') {
               this.closeLightbox();
               somethingWasClosed = true;
           } else if (gameModal && gameModal.style.display === 'block') {
               this.closeModal();
               somethingWasClosed = true;
           } else if (addGameForm && addGameForm.classList.contains('show')) {
               this.closeForm();
               somethingWasClosed = true;
           } else if (mobileMenu && mobileMenu.classList.contains('show')) {
               mobileMenu.classList.remove('show');
               if (hamburger) {
                   hamburger.classList.remove('open');
                   hamburger.innerHTML = '☰';
               }
               somethingWasClosed = true;
           } else if (desktopMenu && desktopMenu.classList.contains('show')) {
               desktopMenu.classList.remove('show');
               if (desktopHamburger) {
                   desktopHamburger.classList.remove('open');
                   desktopHamburger.innerHTML = '<i class="fa-solid fa-circle-user"></i>';
               }
               somethingWasClosed = true;
           }
           
           if (somethingWasClosed) {
               // Push state back to prevent actual navigation
               history.pushState(null, '', window.location.href);
           }
       });

       // Responsive handling
       window.addEventListener('resize', () => {
           if (window.innerWidth <= 768) {
               document.getElementById('hamburger-btn').style.display = 'block';
           } else {
               document.getElementById('hamburger-btn').style.display = 'none';
               document.getElementById('mobile-menu').classList.remove('show');
           }
       });


if (window.innerWidth <= 768) {
           document.getElementById('hamburger-btn').style.display = 'block';
       }
   }

   updateFilters() {
       const minPlayers = parseInt(document.getElementById('min-players').value) || null;
       const maxPlayers = parseInt(document.getElementById('max-players').value) || null;
       const minPlaytime = parseInt(document.getElementById('min-playtime').value) || null;
       const maxPlaytime = parseInt(document.getElementById('max-playtime').value) || null;
       const year = parseInt(document.getElementById('year-filter').value) || null;
       const minWeight = parseFloat(document.getElementById('min-weight').value) || null;
       const maxWeight = parseFloat(document.getElementById('max-weight').value) || null;
       const bestPlayerCount = document.getElementById('best-player-count-filter').value;

const dateAcquired = document.getElementById('date-acquired-filter').value || null;
       
       this.currentFilters = {
           search: document.getElementById('search').value,
           minPlayers, maxPlayers, minPlaytime, maxPlaytime, year, dateAcquired, minWeight, maxWeight,
publisher: document.getElementById('publisher-filter').value,
designerContains: document.getElementById('designer-contains-filter').value,
designerNationalityContains: document.getElementById('designer-nationality-contains-filter').value,
designerNationality: this.getMultiselectValues('designer-nationality-filter'),
artist: this.getMultiselectValues('artist-filter'),
artistContains: document.getElementById('artist-contains-filter').value,
publisherCountry: document.getElementById('publisher-country-filter').value,
bestPlayerCount,
description: document.getElementById('description-filter').value,
           minPlayersType: document.getElementById('min-players-type').value,
           maxPlayersType: document.getElementById('max-players-type').value,
           minPlaytimeType: document.getElementById('min-playtime-type').value,
           maxPlaytimeType: document.getElementById('max-playtime-type').value,
           yearType: document.getElementById('year-filter-type').value,
           dateAcquiredType: document.getElementById('date-acquired-filter-type').value,
           minWeightType: document.getElementById('min-weight-type').value,
           maxWeightType: document.getElementById('max-weight-type').value,
designer: this.getMultiselectValues('designer-filter'),
           designerContainsType: document.getElementById('designer-contains-filter-type').value,
           designerNationalityContainsType: document.getElementById('designer-nationality-contains-filter-type').value,
           artistContainsType: document.getElementById('artist-contains-filter-type').value,
publisherDropdown: this.getMultiselectValues('publisher-dropdown-filter'),
publisherCountryDropdown: this.getMultiselectValues('publisher-country-dropdown-filter'),
           publisherCountryType: document.getElementById('publisher-country-filter-type').value,
notes: document.getElementById('notes-filter').value,
notesType: document.getElementById('notes-filter-type').value,
description: document.getElementById('description-filter').value,
descriptionType: document.getElementById('description-filter-type').value,
category: this.getMultiselectValues('category-filter'),
categoryContains: document.getElementById('category-contains-filter').value,
categoryContainsType: document.getElementById('category-contains-filter-type').value,
mechanisms: this.getMultiselectValues('mechanisms-filter'),
mechanismsContains: document.getElementById('mechanisms-contains-filter').value,
mechanismsContainsType: document.getElementById('mechanisms-contains-filter-type').value,
type: document.getElementById('type-filter') ? document.getElementById('type-filter').value : '',
typeContains: document.getElementById('type-contains-filter') ? document.getElementById('type-contains-filter').value : '',
typeContainsType: document.getElementById('type-contains-filter-type') ? document.getElementById('type-contains-filter-type').value : 'contains',
publisherType: document.getElementById('publisher-filter-type').value
       };

       this.customFilters = [];
       document.querySelectorAll('#custom-filters-container .filter-group').forEach(filterGroup => {
           const field = filterGroup.querySelector('.custom-filter-field').value;
           const type = filterGroup.querySelector('.custom-filter-type').value;
           const value = filterGroup.querySelector('.custom-filter-value').value;
           if (value) {
               this.customFilters.push({ field, type, value });
           }
       });
   }

   updateDynamicCardFields() {
       this.dynamicCardFields = [];
       
       if (this.currentFilters.search) {
           this.dynamicCardFields.push('notes', 'designers', 'publishers');
       }
if (this.currentFilters.year) this.dynamicCardFields.push('year');
if (this.currentFilters.dateAcquired) this.dynamicCardFields.push('dateAcquired');
       
       // Add sort field to visible fields
       const sortField = document.getElementById('sort-field').value;
       if (sortField && sortField !== 'name' && sortField !== 'players.min' && sortField !== 'players.max') {
           if (!this.dynamicCardFields.includes(sortField)) {
               this.dynamicCardFields.push(sortField);
           }
       }
       if (this.currentFilters.publisher) this.dynamicCardFields.push('publishers');
       if (this.currentFilters.minPlayers || this.currentFilters.maxPlayers) this.dynamicCardFields.push('players');
       if (this.currentFilters.minPlaytime || this.currentFilters.maxPlaytime) this.dynamicCardFields.push('playtime');
       if (this.currentFilters.minWeight || this.currentFilters.maxWeight) this.dynamicCardFields.push('weight');
       if (this.currentFilters.bestPlayerCount) this.dynamicCardFields.push('bestPlayerCount');
   }

updateDesignerFilter() {
       const designerCounts = {};
       this.games.forEach(game => {
           if (game.designers) {
               game.designers.forEach(designer => {
                   designerCounts[designer] = (designerCounts[designer] || 0) + 1;
               });
           }
       });

       const sortedDesigners = Object.entries(designerCounts)
           .sort((a, b) => b[1] - a[1]);

       this.updateMultiselectOptions('designer-filter', sortedDesigners, 'All Designers');
   }

updatePublisherFilter() {
       const publisherCounts = {};
       this.games.forEach(game => {
           if (game.publishers) {
               game.publishers.forEach(publisher => {
                   publisherCounts[publisher] = (publisherCounts[publisher] || 0) + 1;
               });
           }
       });

       const sortedPublishers = Object.entries(publisherCounts)
           .sort((a, b) => b[1] - a[1]);

       this.updateMultiselectOptions('publisher-dropdown-filter', sortedPublishers, 'All Publishers');
   }

updatePublisherCountryDropdownFilter() {
       const publisherCountryCounts = {};
       this.games.forEach(game => {
           if (game.publisherCountry) {
               const countries = Array.isArray(game.publisherCountry) ? 
                   game.publisherCountry : game.publisherCountry.split(';').map(s => s.trim()).filter(s => s);
               countries.forEach(country => {
                   publisherCountryCounts[country] = (publisherCountryCounts[country] || 0) + 1;
               });
           }
       });

       const sortedPublisherCountries = Object.entries(publisherCountryCounts)
           .sort((a, b) => b[1] - a[1]);

       this.updateMultiselectOptions('publisher-country-dropdown-filter', sortedPublisherCountries, 'All Publisher Countries');
   }

updateDesignerNationalityFilter() {
       const nationalityCounts = {};
       this.games.forEach(game => {
           if (game.designerNationality) {
               const nationalities = Array.isArray(game.designerNationality) ? 
                   game.designerNationality : game.designerNationality.split(',').map(s => s.trim());
               nationalities.forEach(nationality => {
                   if (nationality) {
                       nationalityCounts[nationality] = (nationalityCounts[nationality] || 0) + 1;
                   }
               });
           }
       });

       const sortedNationalities = Object.entries(nationalityCounts)
           .sort((a, b) => b[1] - a[1]);

       this.updateMultiselectOptions('designer-nationality-filter', sortedNationalities, 'All Nationalities');
   }

updateArtistFilter() {
    const artistCounts = {};
    this.games.forEach(game => {
        if (game.artists) {
            game.artists.forEach(artist => {
                artistCounts[artist] = (artistCounts[artist] || 0) + 1;
            });
        }
    });

    const sortedArtists = Object.entries(artistCounts)
        .sort((a, b) => b[1] - a[1]);

    this.updateMultiselectOptions('artist-filter', sortedArtists, 'All Artists');
}

updateCategoryFilter() {
    const categoryCounts = {};
    this.games.forEach(game => {
        if (game.category) {
            game.category.forEach(category => {
                categoryCounts[category] = (categoryCounts[category] || 0) + 1;
            });
        }
    });

    const sortedCategories = Object.entries(categoryCounts)
        .sort((a, b) => b[1] - a[1]);

    this.updateMultiselectOptions('category-filter', sortedCategories, 'All Categories');
}

updateMechanismsFilter() {
    const mechanismsCounts = {};
    this.games.forEach(game => {
        if (game.mechanisms) {
            game.mechanisms.forEach(mechanism => {
                mechanismsCounts[mechanism] = (mechanismsCounts[mechanism] || 0) + 1;
            });
        }
    });

    const sortedMechanisms = Object.entries(mechanismsCounts)
        .sort((a, b) => b[1] - a[1]);

    this.updateMultiselectOptions('mechanisms-filter', sortedMechanisms, 'All Mechanisms');
}

   addCustomFilter() {
       const container = document.getElementById('custom-filters-container');
       const filterId = 'custom-filter-' + Date.now();
       
       const filterHtml = `
           <div class="filter-group" id="${filterId}">
               <label>Custom Filter</label>
               <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                   <select class="custom-filter-field">
                       <option value="name">Name</option>
                       <option value="year">Year</option>
                       <option value="designers">Designers</option>
                       <option value="artists">Artists</option>
                       <option value="publishers">Publishers</option>
                       <option value="notes">Notes</option>
                       <option value="weight">Complexity</option>
                       <option value="players.min">Min Players</option>
                       <option value="players.max">Max Players</option>
                       <option value="playtime.min">Min Playtime</option>
                       <option value="playtime.max">Max Playtime</option>
                       <option value="bestPlayerCount">Best Player Count</option>
                   </select>
                   <select class="custom-filter-type">
                       <option value="contains">Contains</option>
                       <option value="exact">Exact</option>
                       <option value="not-contains">Does not contain</option>
                       <option value="greater">Greater than</option>
                       <option value="less">Less than</option>
                       <option value="greater-equal">Greater or equal</option>
                       <option value="less-equal">Less or equal</option>
                   </select>
                   <input type="text" class="custom-filter-value" placeholder="Value">
                   <button type="button" class="custom-filter-delete" onclick="boardGameApp.deleteCustomFilter('${filterId}')">×</button>
               </div>
           </div>
       `;
       
       container.insertAdjacentHTML('beforeend', filterHtml);
       
       const newFilter = document.getElementById(filterId);
       newFilter.querySelectorAll('select, input').forEach(input => {
           input.addEventListener('change', () => {
               this.updateFilters();
               this.applyFilters();
           });
       });
   }

   deleteCustomFilter(filterId) {
       if (confirm('Delete this custom filter?')) {
           document.getElementById(filterId).remove();
           this.updateFilters();
           this.applyFilters();
       }
   }

toggleEditMode() {
       this.isEditMode = !this.isEditMode;
       const controls = document.getElementById('edit-mode-controls');
       const mobileControls = document.getElementById('mobile-edit-mode-controls-header');
       const menuMobileControls = document.getElementById('mobile-edit-mode-controls');
       const menuDesktopControls = document.getElementById('desktop-edit-mode-controls');
       

if (this.isEditMode) {
           this.gameBackups.clear();
           this.games.forEach((game, id) => {
               this.gameBackups.set(id, JSON.parse(JSON.stringify(game)));
           });

           document.body.classList.add('edit-mode');
           if (controls) controls.classList.add('show');
           if (mobileControls) mobileControls.classList.add('show');
           if (menuMobileControls) menuMobileControls.classList.add('show');
           if (menuDesktopControls) menuDesktopControls.classList.add('show');
       } else {
           document.body.classList.remove('edit-mode');
           if (controls) controls.classList.remove('show');
           if (mobileControls) mobileControls.classList.remove('show');
           if (menuMobileControls) menuMobileControls.classList.remove('show');
           if (menuDesktopControls) menuDesktopControls.classList.remove('show');
           this.gameBackups.clear();
       }
       
// Use requestAnimationFrame to defer render
requestAnimationFrame(() => this.render());
   }

saveAllChanges() {
    document.querySelectorAll('.game-card.edit-mode').forEach(card => {
           const gameId = card.dataset.gameId;
           const game = this.games.get(gameId);
           if (!game) return;

game.name = card.querySelector('[data-field="name"]').value;
game.bggUrl = card.querySelector('[data-field="bggUrl"]').value;
game.description = card.querySelector('[data-field="description"]').value;
game.year = parseInt(card.querySelector('[data-field="year"]').value) || null;
game.dateAcquired = card.querySelector('[data-field="dateAcquired"]').value || '1991-11-19';
           game.players.min = parseInt(card.querySelector('[data-field="players.min"]').value) || 1;
           game.players.max = parseInt(card.querySelector('[data-field="players.max"]').value) || 1;
           game.playtime.min = parseInt(card.querySelector('[data-field="playtime.min"]').value) || 0;
           game.playtime.max = parseInt(card.querySelector('[data-field="playtime.max"]').value) || 0;
           game.weight = parseFloat(card.querySelector('[data-field="weight"]').value) || 0;
game.weightColor = card.querySelector('[data-field="weightColor"]').value || '#008000';
           game.notes = card.querySelector('[data-field="notes"]').value;


const designersField = card.querySelector('[data-field="designers"]');
           if (designersField) {
               game.designers = designersField.value.split(';').map(s => s.trim()).filter(s => s);
           }

           const artistsField = card.querySelector('[data-field="artists"]');
           if (artistsField) {
               game.artists = artistsField.value.split(';').map(s => s.trim()).filter(s => s);
           }

           const publishersField = card.querySelector('[data-field="publishers"]');
if (publishersField) {
               game.publishers = publishersField.value.split(';').map(s => s.trim()).filter(s => s);
           }

const designerNationalityField = card.querySelector('[data-field="designerNationality"]');
           if (designerNationalityField) {
               game.designerNationality = designerNationalityField.value.split(';').map(s => s.trim()).filter(s => s);
           }

           const publisherCountryField = card.querySelector('[data-field="publisherCountry"]');
           if (publisherCountryField) {
               game.publisherCountry = publisherCountryField.value.split(';').map(s => s.trim()).filter(s => s);
           }

           const bestPlayersField = card.querySelector('[data-field="bestPlayerCount"]');
           if (bestPlayersField) {
               game.bestPlayerCount = bestPlayersField.value.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
           }

const imageInputs = card.querySelectorAll('.edit-image-item input');
game.images = Array.from(imageInputs).map(input => input.value.trim()).filter(url => url);

const categoryField = card.querySelector('[data-field="category"]');
if (categoryField) {
    game.category = categoryField.value.split(';').map(s => s.trim()).filter(s => s);
}

const mechanismsField = card.querySelector('[data-field="mechanisms"]');
if (mechanismsField) {
    game.mechanisms = mechanismsField.value.split(';').map(s => s.trim()).filter(s => s);
}
       });

this.saveToStorage();
this.updateDesignerFilter();
this.updatePublisherFilter();
this.updatePublisherCountryDropdownFilter();
this.updateDesignerNationalityFilter();
this.updateArtistFilter();
this.updateCategoryFilter();
this.updateMechanismsFilter();
this.toggleEditMode();
this.applyFilters();
alert('All changes saved successfully!');
   }

   discardAllChanges() {
       if (confirm('Discard all changes? This cannot be undone.')) {
           this.games.clear();
           this.gameBackups.forEach((game, id) => {
               this.games.set(id, game);
           });
           
           this.toggleEditMode();
           this.applyFilters();
       }
   }

cycleColumns() {
       const isMobile = window.innerWidth <= 768;
       const columnOptions = isMobile ? [1, 2] : [1, 2, 3, 4, 5];
       const currentColumns = isMobile ? this.mobileColumns : this.currentColumns;
       let currentIndex = columnOptions.indexOf(currentColumns);
if (currentIndex === -1) currentIndex = isMobile ? 0 : 4; // Default to 1 mobile, 5 desktop
       const nextIndex = (currentIndex + 1) % columnOptions.length;
       const newColumns = columnOptions[nextIndex];
       
       if (isMobile) {
           this.mobileColumns = newColumns;
       } else {
           this.currentColumns = newColumns;
       }
       this.setColumns(newColumns);
   }

setColumns(cols) {
       const grid = document.getElementById('game-grid');
       grid.className = `game-grid cols-${cols}`;
       
       const colText = `${cols} Column${cols !== 1 ? 's' : ''}`;
       const columnsText = document.getElementById('columns-text');
       
       if (columnsText) columnsText.textContent = colText;
   }

   deleteGameInEditMode(gameId) {
       if (confirm('Delete this game? This will be permanent when you save changes.')) {
           this.games.delete(gameId);
           this.render();
       }
   }

   addImageToGame(button) {
       const imageHtml = `
           <div class="edit-image-item">
               <input type="text" value="" placeholder="Image URL">
               <button onclick="this.parentElement.remove()">×</button>
           </div>
       `;
       button.parentElement.insertAdjacentHTML('beforeend', imageHtml);
   }


clearFilters() {
       if (this.isSharedView) {
           // Reset to original shared filters
           this.currentFilters = JSON.parse(JSON.stringify(this.originalSharedFilters || {}));
           
           // Clear all UI filters first
           document.getElementById('search').value = '';
           document.getElementById('mobile-search').value = '';
           document.getElementById('min-players').value = '';
           document.getElementById('max-players').value = '';
           document.getElementById('min-playtime').value = '';
           document.getElementById('max-playtime').value = '';
           document.getElementById('year-filter').value = '';
           document.getElementById('date-acquired-filter').value = '';
           document.getElementById('publisher-filter').value = '';
           document.getElementById('designer-contains-filter').value = '';
           document.getElementById('designer-nationality-contains-filter').value = '';
           document.getElementById('artist-contains-filter').value = '';
           document.getElementById('publisher-country-filter').value = '';
           document.getElementById('description-filter').value = '';
           document.getElementById('category-contains-filter').value = '';
           document.getElementById('mechanisms-contains-filter').value = '';
           document.getElementById('notes-filter').value = '';
           document.getElementById('min-weight').value = '';
           document.getElementById('max-weight').value = '';
           document.getElementById('best-player-count-filter').value = '';
           
           // Clear multiselect filters
           document.querySelectorAll('#designer-filter-options input[type="checkbox"]').forEach(cb => cb.checked = false);
           document.querySelectorAll('#designer-nationality-filter-options input[type="checkbox"]').forEach(cb => cb.checked = false);
           document.querySelectorAll('#artist-filter-options input[type="checkbox"]').forEach(cb => cb.checked = false);
document.querySelectorAll('#publisher-dropdown-filter-options input[type="checkbox"]').forEach(cb => cb.checked = false);
       document.querySelectorAll('#publisher-country-dropdown-filter-options input[type="checkbox"]').forEach(cb => cb.checked = false);
       document.querySelectorAll('#category-filter-options input[type="checkbox"]').forEach(cb => cb.checked = false);
           document.querySelectorAll('#mechanisms-filter-options input[type="checkbox"]').forEach(cb => cb.checked = false);
           
           // Apply original shared filters to UI
           this.applyFiltersToUI(this.currentFilters);
           document.getElementById('sort-field').value = this.originalSharedSortField || 'name';
           document.getElementById('sort-order').value = this.originalSharedSortOrder || 'asc';
           
           // Update multiselect displays
           this.updateMultiselectDisplay('designer-filter', 'All Designers');
           this.updateMultiselectDisplay('designer-nationality-filter', 'All Nationalities');
           this.updateMultiselectDisplay('artist-filter', 'All Artists');
 this.updateMultiselectDisplay('publisher-dropdown-filter', 'All Publishers');
       this.updateMultiselectDisplay('publisher-country-dropdown-filter', 'All Publisher Countries');
       this.updateMultiselectDisplay('category-filter', 'All Categories');
           this.updateMultiselectDisplay('mechanisms-filter', 'All Mechanisms');
           
           this.applyFilters();
           return;
       }
       
       // Original clear behavior for personal collections
       document.getElementById('search').value = '';
       document.getElementById('mobile-search').value = '';
       document.getElementById('min-players').value = '';
       document.getElementById('max-players').value = '';
       document.getElementById('min-playtime').value = '';
       document.getElementById('max-playtime').value = '';
       document.getElementById('year-filter').value = '';
       document.getElementById('date-acquired-filter').value = '';
       document.getElementById('publisher-filter').value = '';
       document.getElementById('designer-contains-filter').value = '';
       document.getElementById('designer-nationality-contains-filter').value = '';
       document.getElementById('artist-contains-filter').value = '';
       document.getElementById('publisher-country-filter').value = '';
       document.getElementById('description-filter').value = '';
       document.getElementById('category-contains-filter').value = '';
       document.getElementById('mechanisms-contains-filter').value = '';
       document.getElementById('notes-filter').value = '';
       document.getElementById('notes-filter-type').value = 'contains';
       document.getElementById('description-filter-type').value = 'contains';
       document.getElementById('min-weight').value = '';
       document.getElementById('max-weight').value = '';
       document.getElementById('best-player-count-filter').value = '';

       // Clear multiselect filters
       document.querySelectorAll('#designer-filter-options input[type="checkbox"]').forEach(cb => cb.checked = false);
       document.querySelectorAll('#designer-nationality-filter-options input[type="checkbox"]').forEach(cb => cb.checked = false);
       document.querySelectorAll('#artist-filter-options input[type="checkbox"]').forEach(cb => cb.checked = false);
document.querySelectorAll('#publisher-dropdown-filter-options input[type="checkbox"]').forEach(cb => cb.checked = false);
       document.querySelectorAll('#publisher-country-dropdown-filter-options input[type="checkbox"]').forEach(cb => cb.checked = false);
       document.querySelectorAll('#category-filter-options input[type="checkbox"]').forEach(cb => cb.checked = false);
       document.querySelectorAll('#mechanisms-filter-options input[type="checkbox"]').forEach(cb => cb.checked = false);

       // Update displays
       this.updateMultiselectDisplay('designer-filter', 'All Designers');
       this.updateMultiselectDisplay('designer-nationality-filter', 'All Nationalities');
       this.updateMultiselectDisplay('artist-filter', 'All Artists');
this.updateMultiselectDisplay('publisher-dropdown-filter', 'All Publishers');
       this.updateMultiselectDisplay('publisher-country-dropdown-filter', 'All Publisher Countries');
       this.updateMultiselectDisplay('category-filter', 'All Categories');
       this.updateMultiselectDisplay('mechanisms-filter', 'All Mechanisms');

       document.getElementById('custom-filters-container').innerHTML = '';

       // Reset dynamic card fields when clearing filters
       this.dynamicCardFields = [];
       this.currentFilters = {};
       this.customFilters = [];
       this.updateFilters();
       this.applyFilters();
   }

applyFilters() {
    // For mobile, force loading to show before heavy operations
    if (window.innerWidth <= 768) {
        this.showLoading('Filtering games...');
        // Use requestAnimationFrame to ensure loading shows before blocking operations
        requestAnimationFrame(() => {
            this.performFiltering();
        });
    } else {
        this.performFiltering();
    }
}

performFiltering() {
    try {
        this.updateFilters();
        
        let filtered = Array.from(this.games.values());

if (this.currentFilters.search) {
    const search = this.currentFilters.search.toLowerCase();
    filtered = filtered.filter(game => 
        game.name.toLowerCase().includes(search) ||
        (game.notes && game.notes.toLowerCase().includes(search)) ||
        (game.description && game.description.toLowerCase().includes(search)) ||
        (game.designers && game.designers.some(d => d.toLowerCase().includes(search))) ||
(game.publishers && game.publishers.some(p => p.toLowerCase().includes(search))) ||
        (game.category && game.category.some(c => c.toLowerCase().includes(search))) ||
        (game.mechanisms && game.mechanisms.some(m => m.toLowerCase().includes(search)))
    );
}

       if (this.currentFilters.minPlayers) {
           const type = this.currentFilters.minPlayersType;
           const value = this.currentFilters.minPlayers;
           filtered = filtered.filter(game => {
               if (!game.players) return false;
               if (type === 'exact') return game.players.min === value;
               if (type === 'greater') return game.players.max >= value;
               if (type === 'less') return game.players.min <= value;
               return true;
           });
       }

       if (this.currentFilters.maxPlayers) {
           const type = this.currentFilters.maxPlayersType;
           const value = this.currentFilters.maxPlayers;
           filtered = filtered.filter(game => {
               if (!game.players) return false;
               if (type === 'exact') return game.players.max === value;
               if (type === 'less') return game.players.min <= value;
               if (type === 'greater') return game.players.max >= value;
               return true;
           });
       }

       if (this.currentFilters.minPlaytime) {
           const type = this.currentFilters.minPlaytimeType;
           const value = this.currentFilters.minPlaytime;
           filtered = filtered.filter(game => {
               if (!game.playtime) return false;
               if (type === 'exact') return game.playtime.min === value;
               if (type === 'greater') return game.playtime.max >= value;
               if (type === 'less') return game.playtime.min <= value;
               return true;
           });
       }

       if (this.currentFilters.maxPlaytime) {
           const type = this.currentFilters.maxPlaytimeType;
           const value = this.currentFilters.maxPlaytime;
           filtered = filtered.filter(game => {
               if (!game.playtime) return false;
               if (type === 'exact') return game.playtime.max === value;
               if (type === 'less') return game.playtime.min <= value;
               if (type === 'greater') return game.playtime.max >= value;
               return true;
           });
       }

if (this.currentFilters.year) {
           const type = this.currentFilters.yearType;
           const value = this.currentFilters.year;
           filtered = filtered.filter(game => {
               if (!game.year) return false;
               if (type === 'exact') return game.year === value;
               if (type === 'greater') return game.year > value;
               if (type === 'less') return game.year < value;
               return true;
           });
       }

if (this.currentFilters.dateAcquired) {
           const type = this.currentFilters.dateAcquiredType;
           const filterDate = new Date(this.currentFilters.dateAcquired);
           filtered = filtered.filter(game => {
               if (!game.dateAcquired) return false;
               const gameDate = new Date(game.dateAcquired);
               if (type === 'exact') return gameDate.getFullYear() === filterDate.getFullYear();
               if (type === 'greater') return gameDate > filterDate;
               if (type === 'less') return gameDate < filterDate;
               return true;
           });
       }

       if (this.currentFilters.minWeight) {
           const type = this.currentFilters.minWeightType;
           const value = this.currentFilters.minWeight;
           filtered = filtered.filter(game => {
               if (game.weight === null || game.weight === undefined) return false;
               if (type === 'exact') return Math.abs(game.weight - value) < 0.1;
               if (type === 'greater') return game.weight > value;
               return true;
           });
       }

       if (this.currentFilters.maxWeight) {
           const type = this.currentFilters.maxWeightType;
           const value = this.currentFilters.maxWeight;
           filtered = filtered.filter(game => {
               if (game.weight === null || game.weight === undefined) return false;
               if (type === 'exact') return Math.abs(game.weight - value) < 0.1;
               if (type === 'less') return game.weight < value;
               return true;
           });
       }

       if (this.currentFilters.publisher) {
           const type = this.currentFilters.publisherType;
           const value = this.currentFilters.publisher.toLowerCase();
           filtered = filtered.filter(game => {
               if (!game.publishers) return false;
               const publisherText = game.publishers.join(' ').toLowerCase();
               if (type === 'contains') return publisherText.includes(value);
               if (type === 'exact') return game.publishers.some(p => p.toLowerCase() === value);
               if (type === 'not-contains') return !publisherText.includes(value);
               return true;
           });
       }

if (this.currentFilters.designer && this.currentFilters.designer.length > 0) {
           filtered = filtered.filter(game => {
               if (!game.designers) return false;
               return this.currentFilters.designer.some(designer => game.designers.includes(designer));
           });
       }

if (this.currentFilters.publisherDropdown && this.currentFilters.publisherDropdown.length > 0) {
           filtered = filtered.filter(game => {
               if (!game.publishers) return false;
               return this.currentFilters.publisherDropdown.some(publisher => game.publishers.includes(publisher));
           });
       }

if (this.currentFilters.publisherCountryDropdown && this.currentFilters.publisherCountryDropdown.length > 0) {
           filtered = filtered.filter(game => {
               if (!game.publisherCountry) return false;
               const countries = Array.isArray(game.publisherCountry) ? 
                   game.publisherCountry : game.publisherCountry.split(';').map(s => s.trim());
               return this.currentFilters.publisherCountryDropdown.some(country => countries.includes(country));
           });
       }

       if (this.currentFilters.designerContains) {
           const type = this.currentFilters.designerContainsType;
           const value = this.currentFilters.designerContains.toLowerCase();
           filtered = filtered.filter(game => {
               if (!game.designers) return false;
               const designerText = game.designers.join(' ').toLowerCase();
               if (type === 'contains') return designerText.includes(value);
               if (type === 'exact') return game.designers.some(d => d.toLowerCase() === value);
               if (type === 'not-contains') return !designerText.includes(value);
               return true;
           });
       }

if (this.currentFilters.designerNationalityContains) {
           const type = this.currentFilters.designerNationalityContainsType;
           const value = this.currentFilters.designerNationalityContains.toLowerCase();
           filtered = filtered.filter(game => {
               if (!game.designerNationality) return false;
               const nationalityText = Array.isArray(game.designerNationality) ? 
                   game.designerNationality.join(' ').toLowerCase() : 
                   game.designerNationality.toLowerCase();
               if (type === 'contains') return nationalityText.includes(value);
               if (type === 'exact') return nationalityText === value;
               if (type === 'not-contains') return !nationalityText.includes(value);
               return true;
           });
       }

if (this.currentFilters.designerNationality && this.currentFilters.designerNationality.length > 0) {
           filtered = filtered.filter(game => {
               if (!game.designerNationality) return false;
               const nationalities = Array.isArray(game.designerNationality) ? 
                   game.designerNationality : game.designerNationality.split(',').map(s => s.trim());
               return this.currentFilters.designerNationality.some(nationality => nationalities.includes(nationality));
           });
       }

if (this.currentFilters.artist && this.currentFilters.artist.length > 0) {
           filtered = filtered.filter(game => {
               if (!game.artists) return false;
               return this.currentFilters.artist.some(artist => game.artists.includes(artist));
           });
       }

       if (this.currentFilters.artistContains) {
           const type = this.currentFilters.artistContainsType;
           const value = this.currentFilters.artistContains.toLowerCase();
           filtered = filtered.filter(game => {
               if (!game.artists) return false;
               const artistText = game.artists.join(' ').toLowerCase();
               if (type === 'contains') return artistText.includes(value);
               if (type === 'exact') return game.artists.some(a => a.toLowerCase() === value);
               if (type === 'not-contains') return !artistText.includes(value);
               return true;
           });
       }

if (this.currentFilters.publisherCountry) {
           const type = this.currentFilters.publisherCountryType;
           const value = this.currentFilters.publisherCountry.toLowerCase();
           filtered = filtered.filter(game => {
               if (!game.publisherCountry) return false;
               const countryText = Array.isArray(game.publisherCountry) ? 
                   game.publisherCountry.join(' ').toLowerCase() : 
                   game.publisherCountry.toLowerCase();
               if (type === 'contains') return countryText.includes(value);
               if (type === 'exact') return countryText === value;
               if (type === 'not-contains') return !countryText.includes(value);
               return true;
           });
       }

if (this.currentFilters.notes) {
    const type = this.currentFilters.notesType;
    const value = this.currentFilters.notes.toLowerCase();
    filtered = filtered.filter(game => {
        if (!game.notes) return false;
        const notesText = game.notes.toLowerCase();
        if (type === 'contains') return notesText.includes(value);
        if (type === 'exact') return notesText === value;
        if (type === 'not-contains') return !notesText.includes(value);
        return true;
    });
}

if (this.currentFilters.description) {
    const type = this.currentFilters.descriptionType;
    const value = this.currentFilters.description.toLowerCase();
    filtered = filtered.filter(game => {
        const desc = (game.description || '').toLowerCase();
        if (!desc.trim()) return false;
        if (type === 'contains') return desc.includes(value);
        if (type === 'exact') return desc === value;
        if (type === 'not-contains') return !desc.includes(value);
        return true;
    });
}


if (this.currentFilters.category && this.currentFilters.category.length > 0) {
    filtered = filtered.filter(game => {
        if (!game.category) return false;
        return this.currentFilters.category.some(category => game.category.includes(category));
    });
}

if (this.currentFilters.categoryContains) {
    const type = this.currentFilters.categoryContainsType;
    const value = this.currentFilters.categoryContains.toLowerCase();
    filtered = filtered.filter(game => {
        if (!game.category) return false;
        const categoryText = game.category.join(' ').toLowerCase();
        if (type === 'contains') return categoryText.includes(value);
        if (type === 'exact') return game.category.some(c => c.toLowerCase() === value);
        if (type === 'not-contains') return !categoryText.includes(value);
        return true;
    });
}

if (this.currentFilters.mechanisms && this.currentFilters.mechanisms.length > 0) {
    filtered = filtered.filter(game => {
        if (!game.mechanisms) return false;
        return this.currentFilters.mechanisms.some(mechanism => game.mechanisms.includes(mechanism));
    });
}

if (this.currentFilters.mechanismsContains) {
    const type = this.currentFilters.mechanismsContainsType;
    const value = this.currentFilters.mechanismsContains.toLowerCase();
    filtered = filtered.filter(game => {
        if (!game.mechanisms) return false;
        const mechanismsText = game.mechanisms.join(' ').toLowerCase();
        if (type === 'contains') return mechanismsText.includes(value);
        if (type === 'exact') return game.mechanisms.some(m => m.toLowerCase() === value);
        if (type === 'not-contains') return !mechanismsText.includes(value);
        return true;
    });
}

       if (this.currentFilters.bestPlayerCount) {
           const counts = this.currentFilters.bestPlayerCount.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
           if (counts.length > 0) {
               filtered = filtered.filter(game => {
                   if (!game.bestPlayerCount || game.bestPlayerCount.length === 0) return false;
                   return counts.some(count => game.bestPlayerCount.includes(count));
               });
           }
       }

       this.customFilters.forEach(filter => {
           filtered = filtered.filter(game => {
               let gameValue;
               
               if (filter.field.includes('.')) {
                   const [field, subField] = filter.field.split('.');
                   gameValue = game[field] ? game[field][subField] : null;
               } else {
                   gameValue = game[filter.field];
               }

               if (gameValue === null || gameValue === undefined) return false;

               const filterValue = filter.value.toLowerCase();
               
               if (Array.isArray(gameValue)) {
                   const arrayText = gameValue.join(' ').toLowerCase();
                   switch (filter.type) {
                       case 'contains': return arrayText.includes(filterValue);
                       case 'exact': return gameValue.some(v => v.toLowerCase() === filterValue);
                       case 'not-contains': return !arrayText.includes(filterValue);
                       default: return false;
                   }
               } else if (typeof gameValue === 'string') {
                   const stringValue = gameValue.toLowerCase();
                   switch (filter.type) {
                       case 'contains': return stringValue.includes(filterValue);
                       case 'exact': return stringValue === filterValue;
                       case 'not-contains': return !stringValue.includes(filterValue);
                       default: return false;
                   }
               } else if (typeof gameValue === 'number') {
                   const numValue = parseFloat(filter.value);
                   if (isNaN(numValue)) return false;
                   switch (filter.type) {
                       case 'exact': return gameValue === numValue;
                       case 'greater': return gameValue > numValue;
                       case 'less': return gameValue < numValue;
                       case 'greater-equal': return gameValue >= numValue;
                       case 'less-equal': return gameValue <= numValue;
                       case 'contains': return gameValue.toString().includes(filter.value);
                       default: return false;
                   }
               }
               
               return false;
           });
       });

// Always include thumbs up games, even if they don't match filters
const thumbsUpGames = Array.from(this.games.values()).filter(game => 
    this.gamePreferences.get(game.bggId) === 'up'
);

// Apply thumb preferences to filtered games (hide thumbs down)
filtered = filtered.filter(game => {
    const preference = this.gamePreferences.get(game.bggId);
    if (preference === 'down') return false; // Hide thumbs down
    return true; // Show everything else (neutral)
});

// Combine thumbs up games with filtered games, removing duplicates
const filteredIds = new Set(filtered.map(game => game.bggId));
const uniqueThumbsUp = thumbsUpGames.filter(game => !filteredIds.has(game.bggId));
filtered = [...thumbsUpGames.filter(game => filteredIds.has(game.bggId)), ...uniqueThumbsUp, ...filtered.filter(game => this.gamePreferences.get(game.bggId) !== 'up')];

const sortField = document.getElementById('sort-field').value;
       const sortOrder = document.getElementById('sort-order').value;

       filtered.sort((a, b) => {
           let aVal, bVal;

           if (sortField.includes('.')) {
               const [field, subField] = sortField.split('.');
               aVal = a[field] ? a[field][subField] : 0;
               bVal = b[field] ? b[field][subField] : 0;
           } else {
               aVal = a[sortField];
               bVal = b[sortField];
           }

           if (typeof aVal === 'string') {
               aVal = aVal.toLowerCase();
               bVal = bVal.toLowerCase();
               // Remove "The " from beginning for sorting
               if (sortField === 'name') {
                   aVal = aVal.replace(/^the\s+/, '');
                   bVal = bVal.replace(/^the\s+/, '');
               }
           }

           if (aVal < bVal) return sortOrder === 'asc' ? -1 : 1;
           if (aVal > bVal) return sortOrder === 'asc' ? 1 : -1;
           return 0;
       });

this.filteredGames = filtered;
this.render();
} finally {
        if (window.innerWidth <= 768) {
            this.hideLoading();
        }
    }
   }

   async fetchBGGData() {
       const url = document.getElementById('bgg-url').value;
       if (!url) return;

       const loadingEl = document.getElementById('loading-indicator');
       const errorEl = document.getElementById('error-message');
       
       loadingEl.style.display = 'block';
       errorEl.style.display = 'none';

       try {
           const bggIdMatch = url.match(/\/boardgame\/(\d+)/);
           if (!bggIdMatch) {
               throw new Error('Invalid BoardGameGeek URL');
           }

           const bggId = bggIdMatch[1];
           
           const controller = new AbortController();
           const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout
           
const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(`https://boardgamegeek.com/xmlapi2/thing?id=${bggId}&stats=1`)}`, {
               signal: controller.signal
           });
           
clearTimeout(timeoutId);
           const json = await response.json();
const data = json.contents;
           
           if (!response.ok) {
               throw new Error('Failed to fetch from BoardGameGeek');
           }

           const parser = new DOMParser();
           const xmlDoc = parser.parseFromString(data, 'text/xml');
           const item = xmlDoc.querySelector('item');

           if (!item) {
               throw new Error('Game not found on BoardGameGeek');
           }

           const name = item.querySelector('name[type="primary"]')?.getAttribute('value') || '';
           const year = parseInt(item.querySelector('yearpublished')?.getAttribute('value')) || '';
           const minPlayers = parseInt(item.querySelector('minplayers')?.getAttribute('value')) || 1;
           const maxPlayers = parseInt(item.querySelector('maxplayers')?.getAttribute('value')) || 1;
           const playtime = parseInt(item.querySelector('playingtime')?.getAttribute('value')) || 0;
           const weight = parseFloat(item.querySelector('statistics averageweight')?.getAttribute('value')) || 0;

           const bestPlayerCount = [];
           const polls = item.querySelectorAll('poll[name="suggested_numplayers"] results');
           polls.forEach(result => {
               const numPlayers = result.getAttribute('numplayers');
               const best = result.querySelector('result[value="Best"]');
               const numVotes = best ? parseInt(best.getAttribute('numvotes')) : 0;
               if (numVotes > 0 && numPlayers !== '+') {
                   bestPlayerCount.push(parseInt(numPlayers));
               }
           });

           const designers = Array.from(item.querySelectorAll('link[type="boardgamedesigner"]')).map(el => el.getAttribute('value'));
           const artists = Array.from(item.querySelectorAll('link[type="boardgameartist"]')).map(el => el.getAttribute('value'));
           const publishers = Array.from(item.querySelectorAll('link[type="boardgamepublisher"]')).map(el => el.getAttribute('value'));
           const primaryImage = item.querySelector('image')?.textContent || '';
           const thumbnail = item.querySelector('thumbnail')?.textContent || '';
const images = [primaryImage, thumbnail].filter(img => img && img !== primaryImage || img === primaryImage);



const description = item.querySelector('description')?.textContent?.trim() || '';

const categories = Array.from(item.querySelectorAll('link[type="boardgamecategory"]')).map(el => el.getAttribute('value'));
const mechanisms = Array.from(item.querySelectorAll('link[type="boardgamemechanic"]')).map(el => el.getAttribute('value'));


// Set default weight color based on complexity
let defaultWeightColor = '#008000';
if (weight >= 2.5) {
    defaultWeightColor = '#ff0000';
} else if (weight >= 1.9) {
    defaultWeightColor = '#cfa200';
}

           document.getElementById('game-name').value = name;
           document.getElementById('game-year').value = year;
           document.getElementById('game-min-players').value = minPlayers;
           document.getElementById('game-max-players').value = maxPlayers;
           document.getElementById('game-playtime').value = playtime;
           document.getElementById('game-weight').value = weight.toFixed(1);
           document.getElementById('game-best-players').value = bestPlayerCount.join(', ');
document.getElementById('game-designers').value = designers.join('; ');
document.getElementById('game-artists').value = artists.join('; ');
document.getElementById('game-publishers').value = publishers.join('; ');
document.getElementById('game-images').value = images.join('\n');
document.getElementById('game-description').value = description;
document.getElementById('game-category').value = categories.join('; ');
document.getElementById('game-mechanisms').value = mechanisms.join('; ');

// Set the weight color dropdown if it exists
           const weightColorSelect = document.getElementById('game-weight-color');
           if (weightColorSelect) {
               weightColorSelect.value = defaultWeightColor;
           }

       } catch (error) {
           if (error.name === 'AbortError') {
               errorEl.textContent = 'Request timed out. BGG might be slow, please try again.';
           } else {
               errorEl.textContent = error.message;
           }
           errorEl.style.display = 'block';
       } finally {
           loadingEl.style.display = 'none';
       }
   }

   saveGame() {
const formData = {
           bggId: Date.now().toString(),
           bggUrl: document.getElementById('bgg-url').value,
           name: document.getElementById('game-name').value,
           year: parseInt(document.getElementById('game-year').value) || null,
dateAcquired: document.getElementById('game-date-acquired').value || '1991-11-19',
           players: {
               min: parseInt(document.getElementById('game-min-players').value) || 1,
               max: parseInt(document.getElementById('game-max-players').value) || 1
           },
           playtime: {
               min: parseInt(document.getElementById('game-playtime').value) || 0,
               max: parseInt(document.getElementById('game-playtime').value) || 0
           },
weight: parseFloat(document.getElementById('game-weight').value) || 0,
weightColor: document.getElementById('game-weight-color').value || '#008000',
           bestPlayerCount: document.getElementById('game-best-players').value.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n)),
designers: document.getElementById('game-designers').value.split(';').map(s => s.trim()).filter(s => s),
           artists: document.getElementById('game-artists').value.split(';').map(s => s.trim()).filter(s => s),
publishers: document.getElementById('game-publishers').value.split(';').map(s => s.trim()).filter(s => s),
designerNationality: document.getElementById('game-designer-nationality').value.split(';').map(s => s.trim()).filter(s => s),
           publisherCountry: document.getElementById('game-publisher-country').value.split(';').map(s => s.trim()).filter(s => s),
images: document.getElementById('game-images').value.split('\n').map(s => s.trim()).filter(s => s),
notes: document.getElementById('game-notes').value,
description: document.getElementById('game-description').value,
category: document.getElementById('game-category').value.split(';').map(s => s.trim()).filter(s => s),
mechanisms: document.getElementById('game-mechanisms').value.split(';').map(s => s.trim()).filter(s => s),
customFields: {}
       };

       if (!formData.name) {
           alert('Game name is required');
           return;
       }

this.games.set(formData.bggId, formData);
this.saveToStorage();
this.updateDesignerFilter();
this.updatePublisherFilter();
this.updateDesignerNationalityFilter();
this.updateArtistFilter();
this.updateCategoryFilter();
this.updateMechanismsFilter();
this.closeForm();
this.applyFilters();
   }

closeForm() {
       document.getElementById('add-game-form').classList.remove('show');
document.getElementById('add-game-form').querySelectorAll('input, textarea').forEach(input => {
    input.value = '';
});
       document.getElementById('add-game-form').querySelectorAll('select').forEach(select => {
           select.selectedIndex = 0;
       });
       document.getElementById('error-message').style.display = 'none';
   }

render() {
       this.showLoading('Rendering games...');
       const container = document.getElementById('game-grid');
       const emptyState = document.getElementById('empty-state');
       const resultsInfo = document.getElementById('results-info');
       

if (this.filteredGames.length === 0) {
           container.innerHTML = '';
           emptyState.style.display = 'block';
           resultsInfo.style.display = 'none';
           this.hideLoading();
           return;
       }

       emptyState.style.display = 'none';
       resultsInfo.style.display = 'flex';
       const resultsText = document.getElementById('results-text');
       if (resultsText) {
           resultsText.textContent = `Showing ${this.filteredGames.length} of ${this.games.size} games`;
       }

       // Use DocumentFragment for better performance
       const fragment = document.createDocumentFragment();
       const tempDiv = document.createElement('div');
       
// Batch render in chunks for better responsiveness
       const chunkSize = window.innerWidth <= 768 ? 10 : 30;
       const renderChunk = (startIndex) => {
           const endIndex = Math.min(startIndex + chunkSize, this.filteredGames.length);
           const html = this.filteredGames.slice(startIndex, endIndex).map(game => {
               return this.isEditMode ? this.renderEditGameCard(game) : this.renderGameCard(game);
           }).join('');
           
           tempDiv.innerHTML = html;
           while (tempDiv.firstChild) {
               fragment.appendChild(tempDiv.firstChild);
           }
           
           if (endIndex < this.filteredGames.length) {
               // Use requestAnimationFrame for smoother rendering
               requestAnimationFrame(() => renderChunk(endIndex));
           } else {
               // All chunks rendered, update DOM once
               container.innerHTML = '';
container.appendChild(fragment);
               this.initializeSwipersAfterRender();
               this.forceImageLoading();
               this.hideLoading();
           }
       };
       
       renderChunk(0);
       
   }


initializeSwipersAfterRender() {
       if (!this.isEditMode) {
           this.filteredGames.forEach((game, index) => {
               if (game.images && game.images.length > 1) {
const swiperEl = document.getElementById(`swiper-${game.bggId}`);
                   if (swiperEl && !swiperEl.swiper) {
                       if (window.innerWidth <= 768) {
                           // Lazy initialize swipers on mobile - only when user interacts
                           swiperEl.addEventListener('touchstart', function initMobileSwiper() {
                               if (!this.swiper) {
                                   new Swiper(`#swiper-${game.bggId}`, {
                                       navigation: {
                                           nextEl: `#swiper-${game.bggId} .swiper-button-next`,
                                           prevEl: `#swiper-${game.bggId} .swiper-button-prev`,
                                       },
                                       pagination: {
                                           el: `#swiper-${game.bggId} .swiper-pagination`,
                                           clickable: true,
                                       },
                                       loop: game.images.length > 1,
                                       autoHeight: true,
                                   });
                               }
                               this.removeEventListener('touchstart', initMobileSwiper);
                           }, { once: true });
                       } else {
                           // Desktop: initialize immediately
                           new Swiper(`#swiper-${game.bggId}`, {
                               navigation: {
                                   nextEl: `#swiper-${game.bggId} .swiper-button-next`,
                                   prevEl: `#swiper-${game.bggId} .swiper-button-prev`,
                               },
                               pagination: {
                                   el: `#swiper-${game.bggId} .swiper-pagination`,
                                   clickable: true,
                               },
                               loop: game.images.length > 1,
                               autoHeight: true,
                           });
                       }
                   }
               }
           });

           const container = document.getElementById('game-grid');
           container.querySelectorAll('.details-toggle').forEach(btn => {
               btn.addEventListener('click', (e) => {
                   const content = e.target.nextElementSibling;
                   content.classList.toggle('show');
                   const icon = e.target.querySelector('.toggle-icon');
                   icon.textContent = content.classList.contains('show') ? '▼' : '▶';
               });
           });
       }
   }

   forceImageLoading() {
       // Force image loading on desktop by triggering load events
       if (window.innerWidth > 768) {
           const images = document.querySelectorAll('.game-card img');
           images.forEach(img => {
               if (!img.complete) {
                   const newSrc = img.src;
                   img.src = '';
                   img.src = newSrc;
               }
           });
       }
   }

   renderGameCard(game) {
       const playerRange = game.players ? `${game.players.min}-${game.players.max}` : 'Unknown';
       const playtimeText = game.playtime ? `${game.playtime.min}${game.playtime.min !== game.playtime.max ? `-${game.playtime.max}` : ''} min` : 'Unknown';
       
       const allVisibleFields = [...new Set([...this.cardVisibleFields, ...this.dynamicCardFields])];
       
       const imagesHtml = game.images && game.images.length > 0 ? `
           <div class="swiper" id="swiper-${game.bggId}">
               <div class="swiper-wrapper">
${game.images.map((img, index) => `
<div class="swiper-slide">
<img src="${img}" alt="${game.name}" ${window.innerWidth <= 768 ? 'loading="lazy" style="opacity: 0; transition: opacity 0.3s ease;" onload="this.style.opacity = 1;" decoding="async"' : ''} onerror="this.style.display = 'none';">
                       </div>
                   `).join('')}
               </div>
               ${game.images.length > 1 ? `
                   <div class="swiper-button-next" onclick="event.stopPropagation();"></div>
                   <div class="swiper-button-prev" onclick="event.stopPropagation();"></div>
                   <div class="swiper-pagination"></div>
               ` : ''}
           </div>
       ` : `
           <div style="height: 200px; background: #f0f0f0; display: flex; align-items: center; justify-content: center; color: #999;">
               No Image
           </div>
       `;

       const metaItems = [];
       
if (allVisibleFields.includes('year') && game.year) {
           metaItems.push(`<div class="meta-item"><span class="meta-label">Year:</span><span>${game.year}</span></div>`);
       }
if (allVisibleFields.includes('dateAcquired') && game.dateAcquired && !this.isSharedView) {
           const dateParts = game.dateAcquired.split('-');
           const acquiredDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
           const formattedDate = acquiredDate.toLocaleDateString('en-US');
           metaItems.push(`<div class="meta-item"><span class="meta-label">Acquired:</span><span>${formattedDate}</span></div>`);
       }
       if (allVisibleFields.includes('players')) {
           metaItems.push(`<div class="meta-item"><span class="meta-label">Players:</span><span>${playerRange}</span></div>`);
       }
       if (allVisibleFields.includes('playtime')) {
           metaItems.push(`<div class="meta-item"><span class="meta-label">Time:</span><span>${playtimeText}</span></div>`);
       }
if (allVisibleFields.includes('weight') && game.weight) {
const weightColor = game.weightColor || '#008000';
metaItems.push(`<div class="meta-item"><span class="meta-label">Complexity:</span><span style="color: ${weightColor === '#cfa200' ? '#cfa200' : weightColor};">${game.weight.toFixed(1)}</span><span class="complexity-tooltip"><i class="fa-solid fa-circle-info"></i><span class="tooltiptext"><span style="color: #008000;">Green means easy, ok for non-gamers/kids</span><br><span style="color: #cfa200;">Yellow means too much for above, but normal for most people</span><br><span style="color: #ff0000;">Red means gamers only, higher strategy, full weight</span></span></span></div>`);
       }
       if (allVisibleFields.includes('publishers') && game.publishers?.length > 0) {
           metaItems.push(`<div class="meta-item"><span class="meta-label">Publisher:</span><span>${game.publishers[0]}</span></div>`);
       }
       if (allVisibleFields.includes('bestPlayerCount') && game.bestPlayerCount?.length > 0) {
           metaItems.push(`<div class="meta-item"><span class="meta-label">Best:</span><span>${game.bestPlayerCount.join(', ')}</span></div>`);
       }

const preference = this.gamePreferences.get(game.bggId);
const thumbsHtml = `
    <div class="thumb-buttons">
        <button class="thumb-btn thumb-up ${preference === 'up' ? 'active' : ''}" 
                onclick="event.stopPropagation(); boardGameApp.setGamePreference('${game.bggId}', 'up')">
            <i class="fa-solid fa-thumbtack"></i>
        </button>
        <button class="thumb-btn thumb-down ${preference === 'down' ? 'active' : ''}" 
                onclick="event.stopPropagation(); boardGameApp.setGamePreference('${game.bggId}', 'down')">
            <i class="fa-solid fa-eye-slash"></i>
        </button>
    </div>
`;

return `
    <div class="game-card" data-game-id="${game.bggId}" onclick="boardGameApp.openGameModal('${game.bggId}')" style="cursor: pointer;">
        <div class="image-carousel">
            ${imagesHtml}
        </div>
        <div class="game-info">
            <h3 class="game-title">${game.name}</h3>
            ${metaItems.length > 0 ? `
                <div class="game-meta">
                    ${metaItems.join('')}
                </div>
            ` : ''}
        </div>
        ${thumbsHtml}
    </div>
`;
   }

   renderEditGameCard(game) {
       const addImageButton = (index) => `
           <div class="edit-image-item">
               <input type="text" value="${game.images && game.images[index] ? game.images[index] : ''}" placeholder="Image URL">
               <button onclick="this.parentElement.remove()">×</button>
           </div>
       `;

       const imagesHtml = `
           <div class="edit-images">
               ${game.images && game.images.length > 0 ? 
                   game.images.map((img, index) => addImageButton(index)).join('') :
                   addImageButton(0)
               }
               <button class="add-image-btn" onclick="boardGameApp.addImageToGame(this)">Add Image</button>
           </div>
       `;

       return `
           <div class="game-card edit-mode" data-game-id="${game.bggId}">
               <div class="edit-expanded">


<div class="edit-section">
    <h4>Basic Information</h4>
    <div class="edit-row">
        <div class="edit-group">
            <label>Game Name</label>
            <input type="text" class="edit-field" data-field="name" value="${game.name || ''}">
        </div>
    </div>
<div class="edit-row">
    <div class="edit-group">
        <label>Notes</label>
        <textarea class="edit-field" data-field="notes" rows="3" placeholder="Your thoughts about this game...">${game.notes || ''}</textarea>
    </div>
</div>
<div class="edit-row">
    <div class="edit-group">
        <label>Description</label>
        <textarea class="edit-field" data-field="description" rows="4" placeholder="Game description...">${game.description || ''}</textarea>
    </div>
</div>
<div class="edit-row">
    <div class="edit-group">
        <label>Category</label>
<input type="text" class="edit-field" data-field="category" value="${Array.isArray(game.category) ? game.category.join('; ') : (game.category || '')}" placeholder="Strategy; Family; Party; etc.">
    </div>
    <div class="edit-group">
        <label>Mechanisms</label>
        <input type="text" class="edit-field" data-field="mechanisms" value="${Array.isArray(game.mechanisms) ? game.mechanisms.join('; ') : (game.mechanisms || '')}" placeholder="Dice Rolling; Worker Placement; etc.">
    </div>
</div>
                       <div class="edit-row">
<div class="edit-group">
                               <label>Year Published</label>
                               <input type="number" class="edit-field" data-field="year" value="${game.year || ''}" min="1900" max="2030">
                           </div>
<div class="edit-group">
                               <label>Date Acquired</label>
                               <input type="date" class="edit-field" data-field="dateAcquired" value="${game.dateAcquired || '1991-11-19'}">
                           </div>
                       </div>
                       <div class="edit-row">
                           <div class="edit-group">
                               <label>Min Players</label>
                               <input type="number" class="edit-field" data-field="players.min" value="${game.players?.min || 1}" min="1">
                           </div>
                           <div class="edit-group">
                               <label>Max Players</label>
                               <input type="number" class="edit-field" data-field="players.max" value="${game.players?.max || 1}" min="1">
                           </div>
                           <div class="edit-group">
                               <label>Min Playtime</label>
                               <input type="number" class="edit-field" data-field="playtime.min" value="${game.playtime?.min || 0}" min="0">
                           </div>
                           <div class="edit-group">
                               <label>Max Playtime</label>
                               <input type="number" class="edit-field" data-field="playtime.max" value="${game.playtime?.max || 0}" min="0">
                           </div>
                       </div>
                       <div class="edit-row">
                           <div class="edit-group">
                               <label>Complexity (1-5)</label>
                               <div style="display: flex; gap: 0.5rem;">
                                   <input type="number" class="edit-field" data-field="weight" value="${game.weight || ''}" min="0" max="5" step="0.1" style="flex: 1;">
<select class="edit-field" data-field="weightColor" style="width: 100px;">
<option value="#008000" ${(game.weightColor || '#008000') === '#008000' ? 'selected' : ''}>Green</option>
<option value="#cfa200" ${(game.weightColor || '#008000') === '#cfa200' ? 'selected' : ''}>Yellow</option>
<option value="#ff0000" ${(game.weightColor || '#008000') === '#ff0000' ? 'selected' : ''}>Red</option>
</select>
                               </div>
                           </div>
                           <div class="edit-group">
                               <label>Best Player Count</label>
                               <input type="text" class="edit-field" data-field="bestPlayerCount" value="${game.bestPlayerCount ? game.bestPlayerCount.join(', ') : ''}" placeholder="2,3,4">
                           </div>
                       </div>
                   </div>
                   
                   <div class="edit-section">
                       <h4>People</h4>
                       <div class="edit-row">
                           <div class="edit-group">
                               <label>Designers</label>
<input type="text" class="edit-field" data-field="designers" value="${game.designers ? game.designers.join('; ') : ''}" placeholder="Semicolon separated">
                           </div>
                           <div class="edit-group">
                               <label>Artists</label>
                               <input type="text" class="edit-field" data-field="artists" value="${game.artists ? game.artists.join('; ') : ''}" placeholder="Semicolon separated">
                           </div>
                           <div class="edit-group">
                               <label>Publishers</label>
                               <input type="text" class="edit-field" data-field="publishers" value="${game.publishers ? game.publishers.join('; ') : ''}" placeholder="Semicolon separated">
                           </div>
<div class="edit-group">
                               <label>Designer Nationality</label>
                               <input type="text" class="edit-field" data-field="designerNationality" value="${Array.isArray(game.designerNationality) ? game.designerNationality.join('; ') : (game.designerNationality || '')}" placeholder="Semicolon separated">
                           </div>
                           <div class="edit-group">
                               <label>Publisher Country</label>
                               <input type="text" class="edit-field" data-field="publisherCountry" value="${Array.isArray(game.publisherCountry) ? game.publisherCountry.join('; ') : (game.publisherCountry || '')}" placeholder="Semicolon separated">
                           </div>
        <div class="edit-group">
            <label>BoardGameGeek URL</label>
            <input type="url" class="edit-field" data-field="bggUrl" value="${game.bggUrl || ''}" placeholder="https://boardgamegeek.com/boardgame/...">
        </div>
                       </div>
                   </div>


<div class="edit-section">
                       <h4>Images</h4>
                       ${imagesHtml}
                   </div>

                   <button class="delete-game-btn" onclick="boardGameApp.deleteGameInEditMode('${game.bggId}')">Delete Game</button>
               </div>
           </div>
       `;
   }

   openGameModal(gameId) {
       if (this.isEditMode) return;
       
       const game = this.games.get(gameId);
       if (!game) return;
       
       const modal = document.getElementById('game-modal');
       const content = document.getElementById('modal-game-content');
       
       content.innerHTML = this.renderGameModalContent(game);
history.pushState(null, '', window.location.href);
       modal.style.display = 'block';
       
       if (game.images && game.images.length > 0) {
           new Swiper('#modal-swiper', {
               navigation: {
                   nextEl: '#modal-swiper .swiper-button-next',
                   prevEl: '#modal-swiper .swiper-button-prev',
               },
               pagination: {
                   el: '#modal-swiper .swiper-pagination',
                   clickable: true,
               },
               loop: game.images.length > 1,
           });
           
           document.querySelectorAll('#modal-swiper .swiper-slide img').forEach(img => {
               img.addEventListener('click', () => {
                   this.openLightbox(game);
               });
           });
       }
   }

   renderGameModalContent(game) {
       const playerRange = game.players ? `${game.players.min}-${game.players.max}` : 'Unknown';
       const playtimeText = game.playtime ? `${game.playtime.min}${game.playtime.min !== game.playtime.max ? `-${game.playtime.max}` : ''} min` : 'Unknown';
       
       const imagesHtml = game.images && game.images.length > 0 ? `
           <div class="swiper" id="modal-swiper" style="height: 300px; margin-bottom: 2rem;">
               <div class="swiper-wrapper">
                   ${game.images.map(img => `
                       <div class="swiper-slide">
                           <img src="${img}" alt="${game.name}" style="width: 100%; height: 100%; object-fit: contain; cursor: pointer;">
                       </div>
                   `).join('')}
               </div>
               ${game.images.length > 1 ? `
                   <div class="swiper-button-next"></div>
                   <div class="swiper-button-prev"></div>
                   <div class="swiper-pagination"></div>
               ` : ''}
           </div>
       ` : '';

const preference = this.gamePreferences.get(game.bggId);
const modalThumbsHtml = `
    <div class="modal-thumbs">
        <button class="thumb-btn thumb-up ${preference === 'up' ? 'active' : ''}" 
                onclick="boardGameApp.setGamePreference('${game.bggId}', 'up')">
            <i class="fa-solid fa-thumbtack"></i>
        </button>
        <button class="thumb-btn thumb-down ${preference === 'down' ? 'active' : ''}" 
                onclick="boardGameApp.setGamePreference('${game.bggId}', 'down')">
            <i class="fa-solid fa-eye-slash"></i>
        </button>
        <button class="thumb-btn" style="background: #667eea; margin-left: 5px;" 
                onclick="boardGameApp.editGameFromModal('${game.bggId}')" title="Edit Game">
            <i class="fa-solid fa-pen-to-square"></i>
        </button>
    </div>
`;

return `
    ${modalThumbsHtml}
    <h2>${game.name}</h2>
    ${imagesHtml}
           

<div style="display: flex; flex-wrap: wrap; gap: 2rem; margin-bottom: 2rem; align-items: center;">
               <div><strong>Year Published:</strong> ${game.year || 'Unknown'}</div>
               <div><strong>Players:</strong> ${playerRange}</div>
               <div><strong>Playtime:</strong> ${playtimeText}</div>
<div><strong>Complexity:</strong> ${game.weight ? `<span style="color: ${(game.weightColor || '#008000') === '#cfa200' ? '#cfa200' : (game.weightColor || '#008000')};">${game.weight.toFixed(1)}</span><span class="complexity-tooltip"><i class="fa-solid fa-circle-info"></i><span class="tooltiptext"><span style="color: #008000;">Green means easy, ok for non-gamers/kids</span><br><span style="color: #cfa200;">Yellow means too much for above, but normal for most people</span><br><span style="color: #ff0000;">Red means gamers only, higher strategy, full weight</span></span></span>` : 'N/A'}</div>
               ${game.bestPlayerCount && game.bestPlayerCount.length > 0 ? `<div><strong>Best with:</strong> ${game.bestPlayerCount.join(', ')} players</div>` : ''}
               ${game.bggUrl ? `<div><strong>BoardGameGeek:</strong> <a href="${game.bggUrl}" target="_blank" style="color: #667eea;">View on BGG</a></div>` : ''}
           </div>
           
<div style="display: grid; grid-template-columns: ${this.isSharedView ? '1fr' : '1fr 1fr'}; gap: 2rem; margin-bottom: 2rem;">
${!this.isSharedView ? `<div class="modal-left-column">
${game.dateAcquired ? `
                       <div style="margin-bottom: 1rem;">
                           <strong>Date Acquired:</strong> ${(() => {
                               const dateParts = game.dateAcquired.split('-');
                               const date = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
                               return date.toLocaleDateString('en-US');
                           })()}
                       </div>
                   ` : ''}
                   ${game.notes ? `
                       <div>
                           <strong>Notes:</strong>
                           <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-top: 0.5rem;">
                               ${game.notes.replace(/\n/g, '<br>').replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" style="color: #667eea;">$1</a>')}
                           </div>
                       </div>
                   ` : ''}
               </div>` : ''}
               
<div class="modal-right-column">
${game.description ? `
    <div style="margin-bottom: 1rem;">
        <strong>Description:</strong> 
        <span id="desc-short">${game.description.length > 100 ? game.description.substring(0, 100) + '...' : game.description}</span>
        ${game.description.length > 100 ? `
            <span style="color: #667eea; cursor: pointer; margin-left: 5px;" onclick="
                const shortDesc = document.getElementById('desc-short');
                const fullDesc = document.getElementById('desc-full');
                const isShowing = fullDesc.style.display !== 'none';
                if (isShowing) {
                    fullDesc.style.display = 'none';
                    shortDesc.style.display = 'inline';
                    this.textContent = 'More';
                } else {
                    fullDesc.style.display = 'inline';
                    shortDesc.style.display = 'none';
                    this.textContent = 'Less';
                }
            ">More</span>
            <span id="desc-full" style="display: none;">${game.description}</span>
        ` : ''}
    </div>
` : ''}

${game.category && game.category.length > 0 ? `
   <div style="margin-bottom: 1rem;">
       <strong>Category:</strong> 
       <span id="category-short">${game.category.slice(0, 3).join(', ')}${game.category.length > 3 ? '...' : ''}</span>
       ${game.category.length > 3 ? `
           <span style="color: #667eea; cursor: pointer; margin-left: 5px;" onclick="
               const shortCategory = document.getElementById('category-short');
               const fullCategory = document.getElementById('category-full');
               const isShowing = fullCategory.style.display !== 'none';
               if (isShowing) {
                   fullCategory.style.display = 'none';
                   shortCategory.style.display = 'inline';
                   this.textContent = 'More';
               } else {
                   fullCategory.style.display = 'inline';
                   shortCategory.style.display = 'none';
                   this.textContent = 'Less';
               }
           ">More</span>
           <span id="category-full" style="display: none;">${game.category.join(', ')}</span>
       ` : ''}
   </div>
` : ''}

${game.mechanisms && game.mechanisms.length > 0 ? `
   <div style="margin-bottom: 1rem;">
       <strong>Mechanisms:</strong> 
       <span id="mechanisms-short">${game.mechanisms.slice(0, 3).join(', ')}${game.mechanisms.length > 3 ? '...' : ''}</span>
       ${game.mechanisms.length > 3 ? `
           <span style="color: #667eea; cursor: pointer; margin-left: 5px;" onclick="
               const shortMechanisms = document.getElementById('mechanisms-short');
               const fullMechanisms = document.getElementById('mechanisms-full');
               const isShowing = fullMechanisms.style.display !== 'none';
               if (isShowing) {
                   fullMechanisms.style.display = 'none';
                   shortMechanisms.style.display = 'inline';
                   this.textContent = 'More';
               } else {
                   fullMechanisms.style.display = 'inline';
                   shortMechanisms.style.display = 'none';
                   this.textContent = 'Less';
               }
           ">More</span>
           <span id="mechanisms-full" style="display: none;">${game.mechanisms.join(', ')}</span>
       ` : ''}
   </div>
` : ''}

${game.designers && game.designers.length > 0 ? `
   <div style="margin-bottom: 1rem;">
       <strong>Designers:</strong> ${game.designers.join(', ')}
   </div>
` : ''}

                   
${game.designerNationality && game.designerNationality.length > 0 ? `
                       <div style="margin-bottom: 1rem;">
                           <strong>Designer Nationality:</strong> ${Array.isArray(game.designerNationality) ? game.designerNationality.join(', ') : game.designerNationality}
                       </div>
                   ` : ''}
                   
                   ${game.artists && game.artists.length > 0 ? `
                       <div style="margin-bottom: 1rem;">
                           <strong>Artists:</strong> ${game.artists.join(', ')}
                       </div>
                   ` : ''}
                   
${game.publishers && game.publishers.length > 0 ? `
                       <div style="margin-bottom: 1rem;">
                           <strong>Publishers:</strong> ${game.publishers.join(', ')}
                       </div>
                   ` : ''}
                   
${game.publisherCountry && game.publisherCountry.length > 0 ? `
                       <div style="margin-bottom: 1rem;">
                           <strong>Publisher Country:</strong> ${Array.isArray(game.publisherCountry) ? game.publisherCountry.join(', ') : game.publisherCountry}
                       </div>
                   ` : ''}
               </div>
           </div>
       `;
   }

   openLightbox(game) {
       const lightbox = document.getElementById('lightbox-modal');
       const container = document.getElementById('lightbox-swiper');
       
       container.innerHTML = `
           <div class="swiper" style="width: 90vw; height: 90vh;">
               <div class="swiper-wrapper">
                   ${game.images.map(img => `
                       <div class="swiper-slide" style="display: flex; align-items: center; justify-content: center;">
                           <img src="${img}" alt="${game.name}" style="max-width: 100%; max-height: 100%; object-fit: contain;">
                       </div>
                   `).join('')}
               </div>
               ${game.images.length > 1 ? `
                   <div class="swiper-button-next"></div>
                   <div class="swiper-button-prev"></div>
                   <div class="swiper-pagination"></div>
               ` : ''}
           </div>
       `;
       
       lightbox.style.display = 'block';
       
       new Swiper('#lightbox-swiper .swiper', {
           navigation: {
               nextEl: '#lightbox-swiper .swiper-button-next',
               prevEl: '#lightbox-swiper .swiper-button-prev',
           },
           pagination: {
               el: '#lightbox-swiper .swiper-pagination',
               clickable: true,
           },
           loop: game.images.length > 1,
           keyboard: true,
       });
   }

   closeModal() {
       // Destroy any active swipers to prevent memory leaks
       const modalSwiper = document.querySelector('#modal-swiper .swiper');
       if (modalSwiper && modalSwiper.swiper) {
           modalSwiper.swiper.destroy(true, true);
       }
       document.getElementById('game-modal').style.display = 'none';
   }

closeLightbox() {
       // Destroy any active swipers to prevent memory leaks
       const lightboxSwiper = document.querySelector('#lightbox-swiper .swiper');
       if (lightboxSwiper && lightboxSwiper.swiper) {
           lightboxSwiper.swiper.destroy(true, true);
       }
       document.getElementById('lightbox-modal').style.display = 'none';
   }

editGameFromModal(gameId) {
       this.closeModal();
       if (!this.isEditMode) {
           this.toggleEditMode();
       }
// Wait for render to complete, then scroll to the game
       const scrollDelay = window.innerWidth <= 768 ? 800 : 300;
       setTimeout(() => {
           const gameCard = document.querySelector(`[data-game-id="${gameId}"]`);
           if (gameCard) {
               gameCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
           }
       }, scrollDelay);
   }


async shareCollection() {
    if (!this.githubReady || !this.isSignedIn || !this.GITHUB_TOKEN) {
        alert('You must be connected to GitHub to share your collection.');
        return;
    }

const allGames = Array.from(this.games.values()).map(game => {
        const sharedGame = { ...game };
        delete sharedGame.notes;
        delete sharedGame.dateAcquired;
        return sharedGame;
    });
// Get current filter and sort values from UI
this.updateFilters();

const config = {
    filters: this.currentFilters,
    visibleFields: this.visibleFields,
    games: allGames,
    viewMode: 'gallery',
    sortField: document.getElementById('sort-field').value,
    sortOrder: document.getElementById('sort-order').value,
    columns: this.currentColumns,
    preferences: Object.fromEntries(this.gamePreferences),
    sharedAt: new Date().toISOString()
};

    try {
        // Create GitHub Gist
        const gistData = {
            description: `Board Game Collection - ${this.filteredGames.length} games curated`,
            public: true,
            files: {
                "board-game-collection.json": {
                    content: JSON.stringify(config, null, 2)
                }
            }
        };

console.log('Creating Gist with data:', gistData);
        console.log('Using token:', this.GITHUB_TOKEN ? `Token present (${this.GITHUB_TOKEN.substring(0, 8)}...)` : 'No token');
        
        // Test token validity first
        const testResponse = await fetch('https://api.github.com/user', {
            headers: {
                'Authorization': `Bearer ${this.GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github+json'
            }
        });
        console.log('Token test response:', testResponse.status);
        if (!testResponse.ok) {
            const testError = await testResponse.text();
            console.log('Token test error:', testError);
            throw new Error('Invalid GitHub token. Please reconnect to GitHub.');
        }
        
        const response = await fetch('https://api.github.com/gists', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${this.GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github+json',
                'Content-Type': 'application/json',
                'X-GitHub-Api-Version': '2022-11-28'
            },
            body: JSON.stringify(gistData)
        });

        console.log('Response status:', response.status);
        console.log('Response headers:', response.headers);
        
        if (!response.ok) {
            const errorText = await response.text();
            console.log('Error response:', errorText);
            throw new Error(`GitHub API error: ${response.status} ${response.statusText} - ${errorText}`);
        }

        const gist = await response.json();
        const shareUrl = `${window.location.origin}${window.location.pathname}?gist=${gist.id}`;
        
// Copy to clipboard and show native share dialog
        await navigator.clipboard.writeText(shareUrl);
        
        if (navigator.share) {
            // Use native share API if available
            try {
                await navigator.share({
                    title: 'Board Game Collection',
                    text: `Check out this curated board game collection (${this.filteredGames.length} games)`,
                    url: shareUrl
                });
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Error sharing:', error);
                    alert(`Share URL copied to clipboard!\n\nThis will show ${this.filteredGames.length} games with your current filters and sorting applied.`);
                }
            }
        } else {
            // Fallback for browsers without native share
            alert(`Share URL copied to clipboard!\n\nThis will show ${this.filteredGames.length} games with your current filters and sorting applied.`);
        }

    } catch (error) {
        console.error('Error creating share link:', error);
        alert('Failed to create share link. Please check your GitHub connection and try again.');
    }
}

   exportData() {
       const data = {
           games: Object.fromEntries(this.games),
           exported: new Date().toISOString(),
           version: '1.0'
       };

       const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
       const url = URL.createObjectURL(blob);
       const a = document.createElement('a');
       a.href = url;
       a.download = `boardgame-collection-${new Date().toISOString().split('T')[0]}.json`;
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
   }

async importData(file) {
       if (!file) return;

       try {
           const text = await file.text();
           const data = JSON.parse(text);

           if (data.games) {
               const shouldClear = confirm('Clear existing collection before importing?');
               if (shouldClear) {
                   this.games.clear();
               }

               Object.entries(data.games).forEach(([id, game]) => {
                   this.games.set(id, game);
               });

this.saveToStorage();
this.updateDesignerFilter();
this.updatePublisherFilter();
this.updateDesignerNationalityFilter();
this.updateArtistFilter();
this.updateCategoryFilter();
this.updateMechanismsFilter();
this.applyFilters();
alert(`Imported ${Object.keys(data.games).length} games successfully!`);
           }
       } catch (error) {
           alert('Error importing file: ' + error.message);
       }
   }

   setGamePreference(gameId, preference) {
       const currentPreference = this.gamePreferences.get(gameId);
       
       if (currentPreference === preference) {
           // If clicking the same preference, toggle it off
           this.gamePreferences.delete(gameId);
       } else {
           // Set new preference
           this.gamePreferences.set(gameId, preference);
       }
       
       this.updateClearThumbsVisibility();
       this.saveToStorage();
       this.applyFilters();
   }

clearThumbs() {
       if (this.isSharedView) {
           // Reset to original shared preferences
           this.gamePreferences.clear();
           this.originalSharedPreferences.forEach((pref, gameId) => {
               this.gamePreferences.set(gameId, pref);
           });
       } else {
           // In own collection, clear all thumbs
           this.gamePreferences.clear();
       }
       
       this.updateClearThumbsVisibility();
       this.saveToStorage();
       this.applyFilters();
   }

updateClearThumbsVisibility() {
       let hasUserThumbs = false;
       
       if (this.isSharedView) {
           // Show clear button if user has made any changes from the original shared preferences
           hasUserThumbs = Array.from(this.gamePreferences.entries()).some(([gameId, pref]) => {
               return this.originalSharedPreferences.get(gameId) !== pref;
           });
       } else {
           // Show clear button if user has any thumbs in their own collection
           hasUserThumbs = this.gamePreferences.size > 0;
       }
       
       const clearBtn = document.getElementById('clear-thumbs-btn');
       const mobileClearBtn = document.getElementById('mobile-clear-thumbs-btn');
       const mobileControls = document.getElementById('mobile-controls');
       
       if (clearBtn) clearBtn.style.display = hasUserThumbs ? 'inline-block' : 'none';
       if (mobileClearBtn) mobileClearBtn.style.display = hasUserThumbs ? 'inline-block' : 'none';
       
       // Update mobile layout based on clear button visibility
       if (mobileControls) {
           if (hasUserThumbs) {
               mobileControls.classList.add('clear-visible');
           } else {
               mobileControls.classList.remove('clear-visible');
           }
       }
   }

setupClearSearch(inputId, clearId) {
       const input = document.getElementById(inputId);
       const clearIcon = document.getElementById(clearId);
       
       if (!input || !clearIcon) return;

       const updateClearVisibility = () => {
           clearIcon.style.display = input.value.trim() ? 'block' : 'none';
       };

       input.addEventListener('input', updateClearVisibility);
       
       clearIcon.addEventListener('click', () => {
           input.value = '';
           clearIcon.style.display = 'none';
           
           if (this.isSharedView && this.originalSharedFilters) {
               // Revert to original shared search
               this.currentFilters.search = this.originalSharedFilters.search || '';
               const otherSearchInput = inputId === 'search' ? 
                   document.getElementById('mobile-search') : 
                   document.getElementById('search');
               if (otherSearchInput) otherSearchInput.value = this.currentFilters.search;
           } else {
               this.currentFilters.search = '';
               const otherSearchInput = inputId === 'search' ? 
                   document.getElementById('mobile-search') : 
                   document.getElementById('search');
               if (otherSearchInput) otherSearchInput.value = '';
           }
           
           this.updateDynamicCardFields();
           this.applyFilters();
       });
   }

   getMultiselectValues(filterId) {
       const checkboxes = document.querySelectorAll(`#${filterId}-options input[type="checkbox"]:checked`);
       return Array.from(checkboxes).map(cb => cb.value);
   }

   updateMultiselectOptions(filterId, sortedItems, defaultText) {
       const dropdown = document.getElementById(`${filterId}-dropdown`);
       const optionsContainer = document.getElementById(`${filterId}-options`);
       const selectedDiv = dropdown.querySelector('.multiselect-selected');
       
       if (!optionsContainer) return;

       const currentSelected = this.getMultiselectValues(filterId);
       
       optionsContainer.innerHTML = '';
       
       sortedItems.forEach(([item, count]) => {
           const optionDiv = document.createElement('div');
           optionDiv.className = 'multiselect-option';
optionDiv.innerHTML = `
               <input type="checkbox" value="${item}" ${currentSelected.includes(item) ? 'checked' : ''}>
               <span class="multiselect-option-text">${item} (${count})</span>
           `;
           
           const checkbox = optionDiv.querySelector('input');
           const textSpan = optionDiv.querySelector('.multiselect-option-text');
           
           const changeHandler = () => {
               this.updateMultiselectDisplay(filterId, defaultText);
               this.updateFilters();
               this.updateDynamicCardFields();
               this.applyFilters();
           };
           
           checkbox.addEventListener('change', changeHandler);
           textSpan.addEventListener('click', () => {
               checkbox.checked = !checkbox.checked;
               changeHandler();
           });
           
           optionsContainer.appendChild(optionDiv);
       });

       // Add click handler for dropdown
       selectedDiv.onclick = (e) => {
           e.stopPropagation();
           optionsContainer.classList.toggle('show');
       };

       // Close dropdown when clicking outside
       document.addEventListener('click', (e) => {
           if (!dropdown.contains(e.target)) {
               optionsContainer.classList.remove('show');
           }
       });

       this.updateMultiselectDisplay(filterId, defaultText);
   }

   updateMultiselectDisplay(filterId, defaultText) {
       const selectedDiv = document.querySelector(`#${filterId}-dropdown .multiselect-selected`);
       const selected = this.getMultiselectValues(filterId);
       
       if (selected.length === 0) {
           selectedDiv.textContent = defaultText;
       } else if (selected.length === 1) {
           selectedDiv.textContent = selected[0];
       } else {
           selectedDiv.textContent = `${selected.length} selected`;
       }
   }
}


let boardGameApp;

document.addEventListener('DOMContentLoaded', async () => {
   console.log('Initializing app...');
   try {
       boardGameApp = new BoardGameCollection();
       await boardGameApp.init();
       console.log('App initialized successfully');
   } catch (error) {
       console.error('Failed to initialize app:', error);
   }
});

</script>
<div id="game-modal" class="modal" style="display: none;">
   <div class="modal-content">
       <span class="close-modal" onclick="boardGameApp.closeModal()">&times;</span>
       <div id="modal-game-content"></div>
   </div>
</div>

<!-- General loading overlay -->
<div id="loading-overlay" class="loading-overlay">
    <div class="loading-spinner"></div>
    <div class="loading-text">Loading...</div>
</div>

<!-- Cache loading overlay -->
<div id="cache-loading" class="cache-loading">    <div class="cache-content">
        <div class="cache-progress">
            <div class="cache-progress-bar">
                <div class="cache-progress-fill" id="cache-progress-fill"></div>
            </div>
        </div>
        <div id="cache-status">Loading collection...</div>
        <div id="cache-help-text">First time loading may take a minute</div>
    </div>
</div>

<div id="lightbox-modal" class="lightbox" style="display: none;">
   <div class="lightbox-content">
       <span class="close-lightbox" onclick="boardGameApp.closeLightbox()">&times;</span>
       <div id="lightbox-swiper"></div>
   </div>
</div>
</body>
</html>
