<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Board Game Collection Manager</title>
    <link rel="icon" href="https://wallpapers.com/images/hd/red-d20-dice-icon-4xdi6uhmnfam2pvj.jpg" type="image/jpeg">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.4.5/swiper-bundle.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f7fa;
            color: #333;
            line-height: 1.6;
            transition: background-color 0.3s ease;
        }

        body.edit-mode {
            background: #ffffff;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            margin-bottom: 1rem;
            text-align: center;
        }

        .controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }

        .hamburger {
            display: none;
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
        }

        .mobile-menu {
            position: fixed;
            top: 0;
            left: -100%;
            width: 250px;
            height: 100vh;
            background: rgba(102, 126, 234, 0.95);
            backdrop-filter: blur(10px);
            transition: left 0.3s ease;
            z-index: 1000;
            padding: 2rem 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .mobile-menu.show {
            left: 0;
        }

        .mobile-menu .btn {
            width: 100%;
            justify-content: center;
        }

.search-box {
            flex: 1;
            min-width: 200px;
            max-width: 400px;
            position: relative;
        }

        .controls .search-box {
            max-width: 300px;
        }

        .clear-thumbs-btn {
            background: #af834c !important;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .clear-thumbs-btn:hover {
            background: #9a7043 !important;
        }

        .search-box input {
            width: 100%;
            padding: 0.75rem;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            outline: none;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 25px;
            background: rgba(255,255,255,0.2);
            color: white;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }

        .btn-primary {
            background: #4CAF50;
        }

        .btn-primary:hover {
            background: #45a049;
        }

        .columns-btn {
            background: rgba(255,255,255,0.8);
            color: #333;
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .columns-btn:hover {
            background: rgba(255,255,255,0.9);
            transform: translateY(-2px);
        }

        .edit-mode-controls {
            display: none;
            gap: 1rem;
        }

        .edit-mode-controls.show {
            display: flex;
        }

        .btn-save {
            background: #4CAF50;
        }

        .btn-discard {
            background: #e74c3c;
        }

        .filters {
            background: white;
            padding: 1rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 1rem;
            display: none;
        }

        .filters.show {
            display: block;
        }

        .filter-row {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .filter-group label {
            font-weight: 600;
            color: #555;
            font-size: 0.9rem;
        }

        .filter-group input, .filter-group select {
            padding: 0.5rem;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 0.9rem;
            min-width: 120px;
        }

        .filter-group .btn {
            background: #667eea;
            color: white;
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
        }

button#clear-filters {
    background: #667eea;
    color: white;
    padding: 0.5rem 1rem;
    font-size: 0.8rem;
}

        .sort-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .container {
            max-width: 98%;
            margin: 0 auto;
            padding: 1rem;
        }

        .game-grid {
            display: grid;
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .game-grid.cols-1 { grid-template-columns: 1fr; }
        .game-grid.cols-2 { grid-template-columns: repeat(2, 1fr); }
        .game-grid.cols-3 { grid-template-columns: repeat(3, 1fr); }
        .game-grid.cols-4 { grid-template-columns: repeat(4, 1fr); }
        .game-grid.cols-5 { grid-template-columns: repeat(5, 1fr); }

        .game-card {
            background: white;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            overflow: hidden;
            transition: all 0.3s ease;
            position: relative;
        }

        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.15);
        }

        .game-card.edit-mode {
            background: #fff3cd;
            border: 2px solid #ffc107;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.3);
        }

        .image-carousel {
            position: relative;
            height: 200px;
            overflow: hidden;
        }

        .swiper {
            width: 100%;
            height: 100%;
        }

        .swiper-slide {
            display: flex;
            justify-content: center;
            align-items: center;
            background: #f8f9fa;
        }

        .swiper-slide img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .swiper-button-next,
        .swiper-button-prev {
            color: white;
            background: rgba(0,0,0,0.5);
            width: 35px;
            height: 35px;
            margin-top: -17px;
            border-radius: 50%;
            z-index: 10;
        }

        .swiper-button-next:after,
        .swiper-button-prev:after {
            font-size: 14px;
        }

        .swiper-pagination-bullet {
            background: white;
            opacity: 0.7;
        }

        .swiper-pagination-bullet-active {
            opacity: 1;
        }

        .game-info {
            padding: 1.5rem;
        }

        .game-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 0.5rem;
            line-height: 1.3;
        }

        .game-meta {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #666;
        }

        .meta-label {
            font-weight: 600;
            min-width: 60px;
        }

.thumb-buttons {
    position: absolute;
    bottom: 10px;
    left: 10px;
    right: 10px;
    display: flex;
    justify-content: space-between;
    pointer-events: none;
}

.thumb-btn {
    width: 24px;
    height: 24px;
    border: none;
    border-radius: 50%;
    font-size: 12px;
    cursor: pointer;
    pointer-events: auto;
    opacity: 0.7;
    transition: opacity 0.3s ease;
    z-index: 5;
}

.thumb-btn:hover {
    opacity: 1;
}

.thumb-up {
    background: #144d16b0;
    color: white;
}

.thumb-down {
    background: #ac1900e6;
    color: white;
}

.thumb-btn.active {
    opacity: 1;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

.modal-thumbs {
    position: absolute;
    top: 10px;
    left: 10px;
    display: flex;
    gap: 10px;
    z-index: 10;
}

.game-card {
    position: relative;
}

        .edit-field {
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            font-size: 0.9rem;
            width: 100%;
            margin: 0.25rem 0;
        }

        .edit-field:focus {
            border-color: #667eea;
            outline: none;
        }

        .edit-images {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin: 0.5rem 0;
        }

        .edit-image-item {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .edit-image-item input {
            flex: 1;
        }

        .edit-image-item button {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
        }

        .add-image-btn {
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            margin-top: 0.5rem;
        }

        .delete-game-btn {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            margin-top: 1rem;
            width: 100%;
            font-weight: 600;
        }

        .delete-game-btn:hover {
            background: #c0392b;
        }

        .edit-expanded {
            padding: 1.5rem;
        }

        .edit-section {
            margin-bottom: 1.5rem;
        }

        .edit-section h4 {
            color: #2c3e50;
            margin-bottom: 0.75rem;
            font-size: 1rem;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.25rem;
        }

        .edit-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .edit-group {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .edit-group label {
            font-weight: 600;
            color: #555;
            font-size: 0.85rem;
        }

        .details-toggle {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-weight: 600;
            padding: 0.5rem 0;
            width: 100%;
            text-align: left;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .details-content {
            display: none;
            padding-top: 1rem;
            border-top: 1px solid #eee;
            margin-top: 1rem;
        }

        .details-content.show {
            display: block;
        }

        .detail-section {
            margin-bottom: 1rem;
        }

        .detail-section h4 {
            color: #2c3e50;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .detail-section p {
            color: #666;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .notes {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            font-style: italic;
        }

        .add-game-form {
            display: none;
            background: white;
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            margin-bottom: 2rem;
            position: relative;
        }

        .add-game-form.show {
            display: block;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-group label {
            font-weight: 600;
            color: #2c3e50;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            padding: 0.75rem;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .form-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
        }

        .close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #999;
        }

        .empty-state {
            text-align: center;
            padding: 3rem;
            color: #666;
        }

        .empty-state h3 {
            margin-bottom: 1rem;
            color: #2c3e50;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #667eea;
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .success {
            background: #efe;
            color: #363;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .modal {
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background-color: white;
            margin: 2% auto;
            padding: 2rem;
            border-radius: 15px;
            width: 95%;
            max-width: 1200px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }

        .close-modal {
            position: absolute;
            top: 1rem;
            right: 1.5rem;
            font-size: 2rem;
            cursor: pointer;
            color: #999;
        }

        .lightbox {
            position: fixed;
            z-index: 3000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
        }

        .lightbox-content {
            position: relative;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-lightbox {
            position: absolute;
            top: 2rem;
            right: 2rem;
            font-size: 3rem;
            cursor: pointer;
            color: white;
            z-index: 3001;
        }

        /* Mobile Controls Layout */
        .mobile-controls {
            display: none;
        }

/* Responsive Design */
        @media (max-width: 768px) {
    .modal-content div[style*="grid-template-columns: 1fr 1fr"] {
        grid-template-columns: 1fr !important;
    }
    
    .modal-content div[style*="display: flex"] {
        flex-direction: column !important;
        align-items: flex-start !important;
    }

            .game-meta {
                grid-template-columns: 1fr;
            }

            .form-row {
                grid-template-columns: 1fr;
            }

            .filter-row {
                flex-direction: column;
                gap: 1rem;
            }

            .sort-controls {
                width: 100%;
                justify-content: center;
            }

            .hamburger {
                display: block;
            }
            
            .controls {
                display: none;
            }

            .github-controls {
                display: none !important;
            }

.mobile-controls {
                display: flex;
                gap: 0.5rem;
                align-items: center;
                margin-top: 0.5rem;
            }

            .mobile-controls .search-box {
                flex: 1;
                min-width: 150px;
                max-width: 200px;
            }
            
            .header h1 {
                font-size: 1.2rem;
                margin-bottom: 0.5rem;
                display: flex;
                align-items: center;
                justify-content: space-between;
            }
            
            .header {
                padding: 0.5rem 1rem;
            }

            .modal-content {
                margin: 1% auto;
                width: 98%;
                max-height: 95vh;
            }
        }

        /* Share mode styles */
        .share-mode .header {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
        }

        .share-mode .btn {
            display: none;
        }

        .share-mode .filters {
            display: none !important;
        }

        /* Custom filter delete confirmation */
        .custom-filter-delete {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            font-size: 0.8rem;
        }

.complexity-tooltip {
    position: relative;
    display: inline-block;
    cursor: help;
    margin-left: 0.25rem;
}

.complexity-tooltip .tooltiptext {
    visibility: hidden;
    width: 200px;
    background-color: rgba(0,0,0,0.9);
    color: #fff;
    text-align: left;
    border-radius: 6px;
    padding: 8px;
    position: absolute;
    z-index: 1;
    bottom: 125%;
    left: 50%;
    margin-left: -100px;
    opacity: 0;
    transition: opacity 0.3s;
    font-size: 0.8rem;
    line-height: 1.4;
}

.complexity-tooltip:hover .tooltiptext {
    visibility: visible;
    opacity: 1;
}

    </style>
</head>
<body>
    <div class="header">
        <h1 id="page-title">
            Board Game Collection Manager
            <button class="hamburger" id="hamburger-btn" style="display: none;">☰</button>
        </h1>
        
 <div class="controls">
            <div class="search-box">
                <input type="text" id="search" placeholder="Search games...">
            </div>
            <button class="btn clear-thumbs-btn" id="clear-thumbs-btn" style="display: none;">Clear Thumbs</button>
            <button class="btn" id="toggle-filters">Filters</button>
            <button class="btn btn-primary" id="add-game-btn">Add Game</button>
            <button class="btn" id="edit-mode-btn">Edit Mode</button>
            <div class="edit-mode-controls" id="edit-mode-controls">
                <button class="btn btn-discard" id="discard-changes-btn">Discard Changes</button>
                <button class="btn btn-save" id="save-changes-btn">Save Changes</button>
            </div>
            <button class="btn" id="share-btn">Share Collection</button>
            <button class="btn" id="export-btn">Export Data</button>
            <button class="btn" id="import-btn">Import Data</button>
            <button class="columns-btn" id="columns-btn">5 Columns</button>
        </div>

        <div class="github-controls" style="position: absolute; top: 1rem; right: 1rem; display: flex; align-items: center; gap: 1rem;">
            <span id="google-drive-status" style="font-size: 0.9rem;">Loading GitHub...</span>
            <button class="btn" id="google-drive-signin" style="display: none;">Connect GitHub</button>
            <button class="btn" id="google-drive-signout" style="display: none;">Disconnect GitHub</button>
        </div>

<div class="mobile-controls">
            <div class="search-box">
                <input type="text" id="mobile-search" placeholder="Search games...">
            </div>
            <button class="btn clear-thumbs-btn" id="mobile-clear-thumbs-btn" style="display: none;">Clear Thumbs</button>
            <button class="btn" id="mobile-toggle-filters">Filters</button>
        </div>

<div class="mobile-menu" id="mobile-menu">
            <button class="btn" id="mobile-filters-btn">Filters</button>
            <button class="btn btn-primary" id="mobile-add-game-btn">Add Game</button>
            <button class="btn" id="mobile-edit-mode-btn">Edit Mode</button>
            <button class="btn" id="mobile-share-btn">Share Collection</button>
            <button class="btn" id="mobile-export-btn">Export Data</button>
            <button class="btn" id="mobile-import-btn">Import Data</button>
            <button class="columns-btn" id="mobile-columns-btn">2 Columns</button>
            <button class="btn" id="mobile-google-drive-signin" style="display: none;">Connect GitHub</button>
            <button class="btn" id="mobile-google-drive-signout" style="display: none;">Disconnect GitHub</button>
            <div id="mobile-google-drive-status" style="font-size: 0.9rem; padding: 0.5rem; text-align: center;">Loading GitHub...</div>
        </div>
    </div>

    <div class="filters" id="filters">
        <div class="filter-row">
            <div class="sort-controls">
                <label>Sort by:</label>
                <select id="sort-field">
                    <option value="name">Name</option>
                    <option value="year">Year</option>
                    <option value="players.min">Min Players</option>
                    <option value="players.max">Max Players</option>
                    <option value="playtime.min">Playtime</option>
                    <option value="weight">Complexity</option>
                </select>
                <select id="sort-order">
                    <option value="asc">Ascending</option>
                    <option value="desc">Descending</option>
                </select>
            </div>
            <button class="btn" id="clear-filters">Clear All</button>
        </div>
        <div class="filter-row">
<div class="filter-group">
    <label>Best Player Count</label>
    <input type="text" id="best-player-count-filter" placeholder="2,3,4 (comma separated)">
</div>
            <div class="filter-group">
                <label>Min Players</label>
                <div style="display: flex; gap: 0.5rem;">
                    <select id="min-players-type">
                        <option value="greater">Greater than</option>
                        <option value="exact">Exactly</option>
                        <option value="less">Less than</option>
                    </select>
                    <input type="number" id="min-players" min="1" placeholder="1">
                </div>
            </div>
            <div class="filter-group">
                <label>Max Players</label>
                <div style="display: flex; gap: 0.5rem;">
                    <select id="max-players-type">
                        <option value="less">Less than</option>
                        <option value="exact">Exactly</option>
                        <option value="greater">Greater than</option>
                    </select>
                    <input type="number" id="max-players" min="1" placeholder="10">
                </div>
            </div>
            <div class="filter-group">
                <label>Min Playtime</label>
                <div style="display: flex; gap: 0.5rem;">
                    <select id="min-playtime-type">
                        <option value="greater">Greater than</option>
                        <option value="exact">Exactly</option>
                        <option value="less">Less than</option>
                    </select>
                    <input type="number" id="min-playtime" min="0" placeholder="30">
                </div>
            </div>
            <div class="filter-group">
                <label>Max Playtime</label>
                <div style="display: flex; gap: 0.5rem;">
                    <select id="max-playtime-type">
                        <option value="less">Less than</option>
                        <option value="exact">Exactly</option>
                        <option value="greater">Greater than</option>
                    </select>
                    <input type="number" id="max-playtime" min="0" placeholder="120">
                </div>
            </div>
            <div class="filter-group">
                <label>Year</label>
                <div style="display: flex; gap: 0.5rem;">
                    <select id="year-filter-type">
                        <option value="exact">Exactly</option>
                        <option value="greater">After</option>
                        <option value="less">Before</option>
                    </select>
                    <input type="number" id="year-filter" min="1900" max="2030" placeholder="2020">
                </div>
            </div>
            <div class="filter-group">
                <label>Weight Range</label>
                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                    <div style="display: flex; gap: 0.25rem; align-items: center;">
                        <span style="font-size: 0.8rem;">Min:</span>
                        <select id="min-weight-type" style="width: auto;">
                            <option value="greater">></option>
                            <option value="exact">=</option>
                        </select>
                        <input type="number" id="min-weight" min="1" max="5" step="0.1" placeholder="1.0" style="width: 70px;">
                    </div>
                    <div style="display: flex; gap: 0.25rem; align-items: center;">
                        <span style="font-size: 0.8rem;">Max:</span>
                        <select id="max-weight-type" style="width: auto;">
                            <option value="less"><</option>
                            <option value="exact">=</option>
                        </select>
                        <input type="number" id="max-weight" min="1" max="5" step="0.1" placeholder="5.0" style="width: 70px;">
                    </div>
                </div>
            </div>
<div class="filter-group">
    <label>Designer</label>
    <select id="designer-filter">
        <option value="">All Designers</option>
    </select>
</div>
<div class="filter-group">
    <label>Publisher</label>
    <select id="publisher-dropdown-filter">
        <option value="">All Publishers</option>
    </select>
</div>
            <div class="filter-group">
                <label>Publisher</label>
                <div style="display: flex; gap: 0.5rem;">
                    <select id="publisher-filter-type">
                        <option value="contains">Contains</option>
                        <option value="exact">Exact</option>
                        <option value="not-contains">Does not contain</option>
                    </select>
                    <input type="text" id="publisher-filter" placeholder="Publisher name">
                </div>
            </div>
<div class="filter-group">
    <label>Notes</label>
    <div style="display: flex; gap: 0.5rem;">
        <select id="notes-filter-type">
            <option value="contains">Contains</option>
            <option value="exact">Exact</option>
            <option value="not-contains">Does not contain</option>
        </select>
        <input type="text" id="notes-filter" placeholder="Search notes">
    </div>
</div>

        </div>
       <div class="filter-row">
           <div class="filter-group">
               <label>Custom Filters</label>
               <button class="btn" id="add-custom-filter">Add Custom Filter</button>
           </div>
           <div id="custom-filters-container"></div>
       </div>
   </div>

   <div class="container">
       <div class="add-game-form" id="add-game-form">
           <button class="close-btn" id="close-form">&times;</button>
           <h2>Add New Game</h2>
           
           <div class="form-row">
               <div class="form-group">
                   <label>BoardGameGeek URL</label>
                   <input type="url" id="bgg-url" placeholder="https://boardgamegeek.com/boardgame/...">
                   <button class="btn btn-primary" id="fetch-bgg-data">Fetch Game Data</button>
               </div>
           </div>

           <div id="loading-indicator" class="loading" style="display: none;">
               Fetching game data from BoardGameGeek...
           </div>

           <div id="error-message" class="error" style="display: none;"></div>

           <div class="form-row">
               <div class="form-group">
                   <label>Game Name</label>
                   <input type="text" id="game-name" required>
               </div>
               <div class="form-group">
                   <label>Year Published</label>
                   <input type="number" id="game-year" min="1900" max="2030">
               </div>
           </div>

           <div class="form-row">
               <div class="form-group">
                   <label>Min Players</label>
                   <input type="number" id="game-min-players" min="1" max="20">
               </div>
               <div class="form-group">
                   <label>Max Players</label>
                   <input type="number" id="game-max-players" min="1" max="20">
               </div>
               <div class="form-group">
                   <label>Playtime (minutes)</label>
                   <input type="number" id="game-playtime" min="0" max="600">
               </div>
<div class="form-group">
                   <label>Complexity (1-5)</label>
                   <div style="display: flex; gap: 0.5rem;">
                       <input type="number" id="game-weight" step="0.1" min="0" max="5" style="flex: 1;">
                       <select id="game-weight-color" style="width: 100px;">
                           <option value="green">Green</option>
                           <option value="yellow">Yellow</option>
                           <option value="red">Red</option>
                       </select>
                   </div>
               </div>
           </div>

           <div class="form-row">
               <div class="form-group">
                   <label>Best Player Count</label>
                   <input type="text" id="game-best-players" placeholder="2,3,4 (comma separated)">
               </div>
               <div class="form-group">
                   <label>Designers</label>
                   <input type="text" id="game-designers" placeholder="Comma separated">
               </div>
               <div class="form-group">
                   <label>Artists</label>
                   <input type="text" id="game-artists" placeholder="Comma separated">
               </div>
               <div class="form-group">
                   <label>Publishers</label>
                   <input type="text" id="game-publishers" placeholder="Comma separated">
               </div>
           </div>

           <div class="form-row">
               <div class="form-group">
                   <label>Images (URLs, one per line)</label>
<textarea id="game-images" placeholder="https://image1.jpg&#10;https://image2.jpg"></textarea>
              </div>
              <div class="form-group">
                  <label>Notes</label>
                  <textarea id="game-notes" placeholder="Your thoughts about this game..."></textarea>
              </div>
          </div>

          <div class="form-actions">
              <button class="btn" id="cancel-add">Cancel</button>
              <button class="btn btn-primary" id="save-game">Save Game</button>
          </div>
      </div>

      <div id="game-container">
          <div id="results-info" style="margin-bottom: 1rem; color: #666; font-size: 0.9rem;"></div>
          <div class="game-grid" id="game-grid"></div>
          <div class="empty-state" id="empty-state" style="display: none;">
              <h3>No games in your collection yet</h3>
              <p>Click "Add Game" to get started, or import an existing collection.</p>
          </div>
      </div>
  </div>

  <input type="file" id="import-file" accept=".json" style="display: none;">

  <!-- Load new Google Identity Services library -->
  <script src="https://accounts.google.com/gsi/client"></script>
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.4.5/swiper-bundle.min.js"></script>
  <script>
console.log('JavaScript is loading...');
document.addEventListener('DOMContentLoaded', () => {
   console.log('DOM loaded, buttons should work now');
});

class BoardGameCollection {
   constructor() {
       this.games = new Map();
       this.filteredGames = [];
       this.currentFilters = {};
       this.customFilters = [];
       this.isSharedView = false;
       this.isEditMode = false;
       this.gameBackups = new Map();
       this.visibleFields = ['name', 'year', 'players', 'playtime', 'weight', 'images', 'notes'];
       this.cardVisibleFields = ['name', 'players'];
       this.dynamicCardFields = [];
this.currentColumns = 5; // Always start with 5 on desktop
this.mobileColumns = 2; // Always start with 2 on mobile
this.gamePreferences = new Map(); // stores thumbs up/down: 'up', 'down', or null
this.originalSharedPreferences = new Map(); // for shared collections
this.initGoogleDrive();
   }

async init() {
    console.log('Initializing app...');
    
    // Check for shared view FIRST, before loading any storage
    const isSharedCollection = this.checkForSharedView();
    console.log('Is shared collection:', isSharedCollection);
    
    // Only load from storage if it's NOT a shared collection
    if (!isSharedCollection) {
        console.log('Loading from storage...');
        await this.loadFromStorage();
    } else {
        console.log('Skipping storage load for shared collection');
    }
    
    this.bindEvents();
    const isMobile = window.innerWidth <= 768;
    this.setColumns(isMobile ? this.mobileColumns : this.currentColumns);
    
    console.log('About to render...');
    this.render();
    
    this.updateDesignerFilter();
    this.updatePublisherFilter();
    this.updateClearThumbsVisibility();
    
    console.log('About to apply filters...');
    this.applyFilters();
    
    console.log('App initialization complete');
}

// Initialize GitHub file storage
initGoogleDrive() {
    // GitHub storage configuration - replace with your repository details
    this.GITHUB_OWNER = 'jt1919191919'; // Your GitHub username
    this.GITHUB_REPO = 'board-game-tool'; // Your repository name
    this.GITHUB_BRANCH = 'main'; // Usually 'main' or 'master'
    this.GITHUB_FILE_PATH = 'games-data.json'; // File to store your collection
    this.GITHUB_TOKEN = null; // Personal Access Token (user will set this)
    
    this.githubReady = false;
    this.isSignedIn = false;
    
    this.loadGitHubSettings();
}

loadGitHubSettings() {
    try {
        const stored = localStorage.getItem('github-token');
        if (stored) {
            this.GITHUB_TOKEN = stored;
            this.isSignedIn = true;
            this.githubReady = true;
        }
        this.updateGoogleDriveUI();
    } catch (error) {
        console.error('Error loading GitHub settings:', error);
        document.getElementById('google-drive-status').textContent = 'GitHub storage failed - using local storage';
        document.getElementById('google-drive-status').style.color = 'red';
    }





}

async signInToGoogleDrive() {
    const token = prompt('Enter your GitHub Personal Access Token:\n\nTo create one:\n1. Go to GitHub.com → Settings → Developer settings → Personal access tokens\n2. Generate new token (classic)\n3. Select "repo" scope\n4. Copy the token here');
    
    if (token && token.trim()) {
        this.GITHUB_TOKEN = token.trim();
        localStorage.setItem('github-token', this.GITHUB_TOKEN);
        this.isSignedIn = true;
        this.githubReady = true;
        this.updateGoogleDriveUI();
        this.loadFromGitHub();
    }
}

async signOutFromGoogleDrive() {
    try {
        localStorage.removeItem('github-token');
        this.GITHUB_TOKEN = null;
        this.isSignedIn = false;
        this.githubReady = false;
        this.updateGoogleDriveUI();
    } catch (error) {
        console.error('GitHub sign out failed:', error);
    }
}

   handleCredentialResponse(response) {
       // This is for ID tokens, we need OAuth2 tokens for Drive API
       console.log('Credential response received');
   }

updateGoogleDriveUI() {
    const signInBtn = document.getElementById('google-drive-signin');
    const signOutBtn = document.getElementById('google-drive-signout');
    const status = document.getElementById('google-drive-status');
    const mobileSignInBtn = document.getElementById('mobile-google-drive-signin');
    const mobileSignOutBtn = document.getElementById('mobile-google-drive-signout');
    const mobileStatus = document.getElementById('mobile-google-drive-status');
    
    const statusText = this.isSignedIn ? 'Connected to GitHub Storage' : 'Not connected to GitHub Storage';
    const statusColor = this.isSignedIn ? 'white' : 'red';
    
    if (signInBtn && signOutBtn && status) {
        if (this.isSignedIn) {
            signInBtn.style.display = 'none';
            signOutBtn.style.display = 'inline-block';
        } else {
            signInBtn.style.display = 'inline-block';
            signOutBtn.style.display = 'none';
        }
        signInBtn.textContent = 'Connect GitHub';
        signOutBtn.textContent = 'Disconnect GitHub';
        status.textContent = statusText;
        status.style.color = statusColor;
    }
    
    if (mobileSignInBtn && mobileSignOutBtn && mobileStatus) {
        if (this.isSignedIn) {
            mobileSignInBtn.style.display = 'none';
            mobileSignOutBtn.style.display = 'block';
        } else {
            mobileSignInBtn.style.display = 'block';
            mobileSignOutBtn.style.display = 'none';
        }
        mobileSignInBtn.textContent = 'Connect GitHub';
        mobileSignOutBtn.textContent = 'Disconnect GitHub';
        mobileStatus.textContent = statusText;
        mobileStatus.style.color = statusColor;
    }
}

async saveToGitHub() {
    if (!this.githubReady || !this.isSignedIn || !this.GITHUB_TOKEN) {
        console.log('GitHub not ready, saving to localStorage');
        this.saveToLocalStorage();
        return;
    }

    try {
const data = {
    games: Object.fromEntries(this.games),
    preferences: Object.fromEntries(this.gamePreferences),
    lastModified: new Date().toISOString(),
    version: '1.0'
};

        const content = JSON.stringify(data, null, 2);
        const encodedContent = btoa(unescape(encodeURIComponent(content)));
        
        // Check if file exists
        let sha = null;
        try {
            const getResponse = await fetch(`https://api.github.com/repos/${this.GITHUB_OWNER}/${this.GITHUB_REPO}/contents/${this.GITHUB_FILE_PATH}`, {
                headers: {
                    'Authorization': `token ${this.GITHUB_TOKEN}`,
                    'Accept': 'application/vnd.github.v3+json'
                }
            });
            
            if (getResponse.ok) {
                const fileData = await getResponse.json();
                sha = fileData.sha;
            }
        } catch (error) {
            console.log('File does not exist yet, will create new file');
        }

        // Create or update file
        const updateData = {
            message: `Update board game collection - ${new Date().toLocaleString()}`,
            content: encodedContent,
            branch: this.GITHUB_BRANCH
        };
        
        if (sha) {
            updateData.sha = sha;
        }

        const response = await fetch(`https://api.github.com/repos/${this.GITHUB_OWNER}/${this.GITHUB_REPO}/contents/${this.GITHUB_FILE_PATH}`, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${this.GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(updateData)
        });

        if (!response.ok) {
            throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
        }

        console.log('Saved to GitHub successfully');
        
    } catch (error) {
        console.error('Error saving to GitHub:', error);
        alert('Failed to save to GitHub. Check your token and repository settings. Saving locally instead.');
        this.saveToLocalStorage();
    }
}

async loadFromGitHub() {
    // Don't load from GitHub if we're in shared view
    if (this.isSharedView) {
        console.log('Skipping GitHub load - in shared view');
        return;
    }
    
    if (!this.githubReady || !this.isSignedIn || !this.GITHUB_TOKEN) {
        this.loadFromLocalStorage();
        return;
    }

    try {
        const response = await fetch(`https://api.github.com/repos/${this.GITHUB_OWNER}/${this.GITHUB_REPO}/contents/${this.GITHUB_FILE_PATH}`, {
            headers: {
                'Authorization': `token ${this.GITHUB_TOKEN}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });

        if (response.ok) {
            const fileData = await response.json();
            const content = decodeURIComponent(escape(atob(fileData.content)));
            const data = JSON.parse(content);
            
            if (data.games) {
                this.games.clear();
                Object.entries(data.games).forEach(([id, game]) => {
                    this.games.set(id, game);
                });
                
                if (data.preferences) {
                    this.gamePreferences.clear();
                    Object.entries(data.preferences).forEach(([id, pref]) => {
                        this.gamePreferences.set(id, pref);
                    });
                }
                console.log('Loaded collection from GitHub');
            }
        } else {
            console.log('No collection file found in GitHub repository');
            this.loadFromLocalStorage();
        }
        
    } catch (error) {
        console.error('Error loading from GitHub:', error);
        this.loadFromLocalStorage();
    }
}

   saveToLocalStorage() {
       try {
           const data = Object.fromEntries(this.games);
           localStorage.setItem('boardgame-collection', JSON.stringify(data, null, 2));
           console.log('Saved to localStorage');
       } catch (e) {
           console.warn('Could not save to localStorage:', e);
       }
   }

loadFromLocalStorage() {
    // Don't load local storage if we're in shared view
    if (this.isSharedView) {
        console.log('Skipping localStorage load - in shared view');
        return;
    }
    
    try {
        const stored = localStorage.getItem('boardgame-collection');
        if (stored) {
            const data = JSON.parse(stored);
            if (data.games) {
                Object.entries(data.games).forEach(([id, game]) => {
                    this.games.set(id, game);
                });
                
                if (data.preferences) {
                    Object.entries(data.preferences).forEach(([id, pref]) => {
                        this.gamePreferences.set(id, pref);
                    });
                }
            } else {
                // Legacy format - data is directly the games object
                Object.entries(data).forEach(([id, game]) => {
                    this.games.set(id, game);
                });
            }
            console.log('Loaded collection from localStorage');
        }
    } catch (e) {
        console.warn('Could not load from localStorage:', e);
    }
    
    // Only load sample data if we have no games AND we're not in shared view
    if (this.games.size === 0 && !this.isSharedView) {
        console.log('Loading sample data...');
        this.loadSampleData();
    }
}

async saveToStorage() {
    if (!this.isSharedView) {
        if (this.githubReady && this.isSignedIn) {
            await this.saveToGitHub();
        } else {
            this.saveToLocalStorage();
        }
    }
}

async loadFromStorage() {
    // Don't load from storage if we're in shared view
    if (this.isSharedView) {
        console.log('Skipping storage load - in shared view');
        return;
    }
    
    if (this.githubReady && this.isSignedIn) {
        await this.loadFromGitHub();
    } else {
        this.loadFromLocalStorage();
    }
}

   loadSampleData() {
       const sampleGames = [
           {
               bggId: '161936',
               bggUrl: 'https://boardgamegeek.com/boardgame/161936/pandemic-legacy-season-1',
               name: 'Pandemic Legacy: Season 1',
               year: 2015,
               players: { min: 2, max: 4 },
               playtime: { min: 60, max: 60 },
               weight: 2.83,
               bestPlayerCount: [3, 4],
               designers: ['Rob Daviau', 'Matt Leacock'],
               artists: ['Chris Quilliams'],
               publishers: ['Z-Man Games'],
               images: [
                   'https://cf.geekdo-images.com/S3ybV1LAp-8SnHIXLLjVHg__itemrep/img/EdBzaOvIMm_O0-2T9lFpiRnYNhI=/fit-in/246x300/filters:strip_icc()/pic2452831.png'
               ],
               notes: 'Incredible campaign game that evolves as you play. Best with 4 players for maximum discussion.',
               customFields: { owned: true, condition: 'Like New' }
           },
           {
               bggId: '167791',
               bggUrl: 'https://boardgamegeek.com/boardgame/167791/terraforming-mars',
               name: 'Terraforming Mars',
               year: 2016,
               players: { min: 1, max: 5 },
               playtime: { min: 90, max: 120 },
               weight: 3.25,
               bestPlayerCount: [3, 4],
               designers: ['Jacob Fryxelius'],
               artists: ['Isaac Fryxelius'],
               publishers: ['FryxGames'],
               images: [
                   'https://cf.geekdo-images.com/wg9oOLcsKvDesSUdZQ4rxw__itemrep/img/BTkTHO7-8nYRb-DbkY5xNrfI5fI=/fit-in/246x300/filters:strip_icc()/pic3536616.jpg'
               ],
               notes: 'Great engine building game with excellent theme. Takes a while to learn but very rewarding.',
               customFields: { owned: true, condition: 'Very Good' }
           }
       ];

       sampleGames.forEach(game => {
           this.games.set(game.bggId, game);
       });
   }

checkForSharedView() {
    console.log('Checking for shared view...');
    const urlParams = new URLSearchParams(window.location.search);
    const sharedData = urlParams.get('share');
    console.log('Shared data parameter:', sharedData ? 'Found' : 'Not found');
    
    if (sharedData) {
        try {
            console.log('Attempting to decode shared data...');
            // Fix for non-Latin characters - decode properly
            const decodedData = decodeURIComponent(escape(atob(sharedData)));
            console.log('Decoded data length:', decodedData.length);
            
            const config = JSON.parse(decodedData);
            console.log('Parsed config:', config);
            
            if (config.games && config.games.length > 0) {
                console.log(`Loading ${config.games.length} shared games...`);
                
                // Clear existing games and load shared ones
                this.games.clear();
                this.gamePreferences.clear();
                
                config.games.forEach((game, index) => {
                    const gameId = game.bggId || `shared-${index}`;
                    this.games.set(gameId, game);
                    console.log(`Added shared game: ${game.name}`);
                });
                
                // Apply shared configuration
                if (config.filters) {
                    this.currentFilters = config.filters;
                    console.log('Applied shared filters:', config.filters);
                }
                if (config.columns) {
                    this.currentColumns = config.columns;
                }
                if (config.preferences) {
                    Object.entries(config.preferences).forEach(([gameId, pref]) => {
                        this.gamePreferences.set(gameId, pref);
                        this.originalSharedPreferences.set(gameId, pref);
                    });
                    console.log('Applied shared preferences:', config.preferences);
                }
                
                // Set shared view mode
                this.isSharedView = true;
                document.body.classList.add('share-mode');
                
                // Update page title to indicate shared view
                const pageTitle = document.getElementById('page-title');
                if (pageTitle) {
                    pageTitle.textContent = 'Shared Board Game Collection';
                }
                
                console.log(`Successfully loaded shared collection with ${config.games.length} games`);
                return true;
            } else {
                console.log('No games found in shared config');
            }
        } catch (error) {
            console.error('Error loading shared collection:', error);
            console.error('Error details:', error.message);
        }
    }
    return false;
}

   bindEvents() {
       // Search functionality
       document.getElementById('search').addEventListener('input', (e) => {
           this.currentFilters.search = e.target.value;
           document.getElementById('mobile-search').value = e.target.value;
           this.updateDynamicCardFields();
           this.applyFilters();
       });

       document.getElementById('mobile-search').addEventListener('input', (e) => {
           this.currentFilters.search = e.target.value;
           document.getElementById('search').value = e.target.value;
           this.updateDynamicCardFields();
           this.applyFilters();
       });

       // Mobile menu
       document.getElementById('hamburger-btn').addEventListener('click', () => {
           document.getElementById('mobile-menu').classList.toggle('show');
       });

       document.addEventListener('click', (e) => {
           const menu = document.getElementById('mobile-menu');
           const hamburger = document.getElementById('hamburger-btn');
           if (!menu.contains(e.target) && !hamburger.contains(e.target)) {
               menu.classList.remove('show');
           }
       });

       // Filter controls
       document.getElementById('toggle-filters').addEventListener('click', () => {
           document.getElementById('filters').classList.toggle('show');
       });

       document.getElementById('mobile-toggle-filters').addEventListener('click', () => {
           document.getElementById('filters').classList.toggle('show');
       });

       document.getElementById('mobile-filters-btn').addEventListener('click', () => {
           document.getElementById('filters').classList.toggle('show');
           document.getElementById('mobile-menu').classList.remove('show');
       });

       // Filter inputs
       const filterInputs = [
           'min-players', 'max-players', 'min-playtime', 'max-playtime', 
           'year-filter', 'publisher-filter', 'min-weight', 'max-weight', 'best-player-count-filter', 'notes-filter'
       ];
       
       filterInputs.forEach(id => {
           document.getElementById(id).addEventListener('input', () => {
               this.updateFilters();
               this.updateDynamicCardFields();
               this.applyFilters();
           });
           
           const typeSelect = document.getElementById(id + '-type');
           if (typeSelect) {
               typeSelect.addEventListener('change', () => {
                   this.updateFilters();
                   this.applyFilters();
               });
           }
       });

// Auto-update weight color when weight changes in add game form
       const gameWeightInput = document.getElementById('game-weight');
       const gameWeightColorSelect = document.getElementById('game-weight-color');
       if (gameWeightInput && gameWeightColorSelect) {
           gameWeightInput.addEventListener('input', () => {
               const weight = parseFloat(gameWeightInput.value);
               if (!isNaN(weight)) {
                   let defaultColor = 'green';
                   if (weight >= 2.5) {
                       defaultColor = 'red';
                   } else if (weight >= 1.9) {
                       defaultColor = 'yellow';
                   }
                   gameWeightColorSelect.value = defaultColor;
               }
           });
       }

       document.getElementById('designer-filter').addEventListener('change', () => {
           this.updateFilters();
           this.applyFilters();
       });

       document.getElementById('publisher-dropdown-filter').addEventListener('change', () => {
           this.updateFilters();
           this.applyFilters();
       });

       // Sort controls
       document.getElementById('sort-field').addEventListener('change', () => this.applyFilters());
       document.getElementById('sort-order').addEventListener('change', () => this.applyFilters());

       // Clear filters
       document.getElementById('clear-filters').addEventListener('click', () => {
           this.clearFilters();
       });

// Clear thumbs
document.getElementById('clear-thumbs-btn').addEventListener('click', () => {
    this.clearThumbs();
});

document.getElementById('mobile-clear-thumbs-btn').addEventListener('click', () => {
    this.clearThumbs();
});

       // Custom filters
       document.getElementById('add-custom-filter').addEventListener('click', () => {
           this.addCustomFilter();
       });

       // Edit mode
       document.getElementById('edit-mode-btn').addEventListener('click', () => {
           this.toggleEditMode();
       });

       document.getElementById('mobile-edit-mode-btn').addEventListener('click', () => {
           this.toggleEditMode();
           document.getElementById('mobile-menu').classList.remove('show');
       });

       document.getElementById('save-changes-btn').addEventListener('click', () => {
           this.saveAllChanges();
       });

       document.getElementById('discard-changes-btn').addEventListener('click', () => {
           this.discardAllChanges();
       });

       // Column controls
       document.getElementById('columns-btn').addEventListener('click', () => {
           this.cycleColumns();
       });

       document.getElementById('mobile-columns-btn').addEventListener('click', () => {
           this.cycleColumns();
       });

       // Add game form
       document.getElementById('add-game-btn').addEventListener('click', () => {
           document.getElementById('add-game-form').classList.add('show');
       });

       document.getElementById('mobile-add-game-btn').addEventListener('click', () => {
           document.getElementById('add-game-form').classList.add('show');
           document.getElementById('mobile-menu').classList.remove('show');
       });

       document.getElementById('close-form').addEventListener('click', () => {
           this.closeForm();
       });

       document.getElementById('cancel-add').addEventListener('click', () => {
           this.closeForm();
       });

       document.getElementById('fetch-bgg-data').addEventListener('click', () => {
           this.fetchBGGData();
       });

       document.getElementById('save-game').addEventListener('click', () => {
           this.saveGame();
       });

       // Share and export
       document.getElementById('share-btn').addEventListener('click', () => {
           this.shareCollection();
       });

       document.getElementById('mobile-share-btn').addEventListener('click', () => {
           this.shareCollection();
           document.getElementById('mobile-menu').classList.remove('show');
       });

       document.getElementById('export-btn').addEventListener('click', () => {
           this.exportData();
       });

       document.getElementById('mobile-export-btn').addEventListener('click', () => {
           this.exportData();
           document.getElementById('mobile-menu').classList.remove('show');
       });

       document.getElementById('import-btn').addEventListener('click', () => {
           document.getElementById('import-file').click();
       });

       document.getElementById('mobile-import-btn').addEventListener('click', () => {
           document.getElementById('import-file').click();
           document.getElementById('mobile-menu').classList.remove('show');
       });

       document.getElementById('import-file').addEventListener('change', (e) => {
           this.importData(e.target.files[0]);
       });

// Google Drive controls
       document.getElementById('google-drive-signin').addEventListener('click', () => {
           this.signInToGoogleDrive();
       });

       document.getElementById('google-drive-signout').addEventListener('click', () => {
           this.signOutFromGoogleDrive();
       });

       // Mobile Google Drive controls
       document.getElementById('mobile-google-drive-signin').addEventListener('click', () => {
           this.signInToGoogleDrive();
           document.getElementById('mobile-menu').classList.remove('show');
       });

       document.getElementById('mobile-google-drive-signout').addEventListener('click', () => {
           this.signOutFromGoogleDrive();
           document.getElementById('mobile-menu').classList.remove('show');
       });

       // Modal events
       document.addEventListener('click', (e) => {
           if (e.target.id === 'game-modal') {
               this.closeModal();
           }
           if (e.target.id === 'lightbox-modal') {
               this.closeLightbox();
           }
       });

       // Responsive handling
       window.addEventListener('resize', () => {
           if (window.innerWidth <= 768) {
               document.getElementById('hamburger-btn').style.display = 'block';
           } else {
               document.getElementById('hamburger-btn').style.display = 'none';
               document.getElementById('mobile-menu').classList.remove('show');
           }
       });


if (window.innerWidth <= 768) {
           document.getElementById('hamburger-btn').style.display = 'block';
       }
   }

   updateFilters() {
       const minPlayers = parseInt(document.getElementById('min-players').value) || null;
       const maxPlayers = parseInt(document.getElementById('max-players').value) || null;
       const minPlaytime = parseInt(document.getElementById('min-playtime').value) || null;
       const maxPlaytime = parseInt(document.getElementById('max-playtime').value) || null;
       const year = parseInt(document.getElementById('year-filter').value) || null;
       const minWeight = parseFloat(document.getElementById('min-weight').value) || null;
       const maxWeight = parseFloat(document.getElementById('max-weight').value) || null;
       const bestPlayerCount = document.getElementById('best-player-count-filter').value;

       this.currentFilters = {
           search: document.getElementById('search').value,
           minPlayers, maxPlayers, minPlaytime, maxPlaytime, year, minWeight, maxWeight,
           publisher: document.getElementById('publisher-filter').value,
           bestPlayerCount,
           minPlayersType: document.getElementById('min-players-type').value,
           maxPlayersType: document.getElementById('max-players-type').value,
           minPlaytimeType: document.getElementById('min-playtime-type').value,
           maxPlaytimeType: document.getElementById('max-playtime-type').value,
           yearType: document.getElementById('year-filter-type').value,
           minWeightType: document.getElementById('min-weight-type').value,
           maxWeightType: document.getElementById('max-weight-type').value,
           designer: document.getElementById('designer-filter').value,
           publisherDropdown: document.getElementById('publisher-dropdown-filter').value,
           notes: document.getElementById('notes-filter').value,
           notesType: document.getElementById('notes-filter-type').value,
           publisherType: document.getElementById('publisher-filter-type').value
       };

       this.customFilters = [];
       document.querySelectorAll('#custom-filters-container .filter-group').forEach(filterGroup => {
           const field = filterGroup.querySelector('.custom-filter-field').value;
           const type = filterGroup.querySelector('.custom-filter-type').value;
           const value = filterGroup.querySelector('.custom-filter-value').value;
           if (value) {
               this.customFilters.push({ field, type, value });
           }
       });
   }

   updateDynamicCardFields() {
       this.dynamicCardFields = [];
       
       if (this.currentFilters.search) {
           this.dynamicCardFields.push('notes', 'designers', 'publishers');
       }
       if (this.currentFilters.year) this.dynamicCardFields.push('year');
       if (this.currentFilters.publisher) this.dynamicCardFields.push('publishers');
       if (this.currentFilters.minPlayers || this.currentFilters.maxPlayers) this.dynamicCardFields.push('players');
       if (this.currentFilters.minPlaytime || this.currentFilters.maxPlaytime) this.dynamicCardFields.push('playtime');
       if (this.currentFilters.minWeight || this.currentFilters.maxWeight) this.dynamicCardFields.push('weight');
       if (this.currentFilters.bestPlayerCount) this.dynamicCardFields.push('bestPlayerCount');
   }

   updateDesignerFilter() {
       const designerCounts = {};
       this.games.forEach(game => {
           if (game.designers) {
               game.designers.forEach(designer => {
                   designerCounts[designer] = (designerCounts[designer] || 0) + 1;
               });
           }
       });

       const sortedDesigners = Object.entries(designerCounts)
           .sort((a, b) => b[1] - a[1]);

       const select = document.getElementById('designer-filter');
       const currentValue = select.value;
       select.innerHTML = '<option value="">All Designers</option>';
       
       sortedDesigners.forEach(([designer, count]) => {
           const option = document.createElement('option');
           option.value = designer;
           option.textContent = `${designer} (${count})`;
           select.appendChild(option);
       });
       
       select.value = currentValue;
   }

   updatePublisherFilter() {
       const publisherCounts = {};
       this.games.forEach(game => {
           if (game.publishers) {
               game.publishers.forEach(publisher => {
                   publisherCounts[publisher] = (publisherCounts[publisher] || 0) + 1;
               });
           }
       });

       const sortedPublishers = Object.entries(publisherCounts)
           .sort((a, b) => b[1] - a[1]);

       const select = document.getElementById('publisher-dropdown-filter');
       const currentValue = select.value;
       select.innerHTML = '<option value="">All Publishers</option>';
       
       sortedPublishers.forEach(([publisher, count]) => {
           const option = document.createElement('option');
           option.value = publisher;
           option.textContent = `${publisher} (${count})`;
           select.appendChild(option);
       });
       
       select.value = currentValue;
   }

   addCustomFilter() {
       const container = document.getElementById('custom-filters-container');
       const filterId = 'custom-filter-' + Date.now();
       
       const filterHtml = `
           <div class="filter-group" id="${filterId}">
               <label>Custom Filter</label>
               <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                   <select class="custom-filter-field">
                       <option value="name">Name</option>
                       <option value="year">Year</option>
                       <option value="designers">Designers</option>
                       <option value="artists">Artists</option>
                       <option value="publishers">Publishers</option>
                       <option value="notes">Notes</option>
                       <option value="weight">Complexity</option>
                       <option value="players.min">Min Players</option>
                       <option value="players.max">Max Players</option>
                       <option value="playtime.min">Min Playtime</option>
                       <option value="playtime.max">Max Playtime</option>
                       <option value="bestPlayerCount">Best Player Count</option>
                   </select>
                   <select class="custom-filter-type">
                       <option value="contains">Contains</option>
                       <option value="exact">Exact</option>
                       <option value="not-contains">Does not contain</option>
                       <option value="greater">Greater than</option>
                       <option value="less">Less than</option>
                       <option value="greater-equal">Greater or equal</option>
                       <option value="less-equal">Less or equal</option>
                   </select>
                   <input type="text" class="custom-filter-value" placeholder="Value">
                   <button type="button" class="custom-filter-delete" onclick="boardGameApp.deleteCustomFilter('${filterId}')">×</button>
               </div>
           </div>
       `;
       
       container.insertAdjacentHTML('beforeend', filterHtml);
       
       const newFilter = document.getElementById(filterId);
       newFilter.querySelectorAll('select, input').forEach(input => {
           input.addEventListener('change', () => {
               this.updateFilters();
               this.applyFilters();
           });
       });
   }

   deleteCustomFilter(filterId) {
       if (confirm('Delete this custom filter?')) {
           document.getElementById(filterId).remove();
           this.updateFilters();
           this.applyFilters();
       }
   }

   toggleEditMode() {
       this.isEditMode = !this.isEditMode;
       const btn = document.getElementById('edit-mode-btn');
       const mobileBtn = document.getElementById('mobile-edit-mode-btn');
       const controls = document.getElementById('edit-mode-controls');
       
       if (this.isEditMode) {
           this.gameBackups.clear();
           this.games.forEach((game, id) => {
               this.gameBackups.set(id, JSON.parse(JSON.stringify(game)));
           });

           document.body.classList.add('edit-mode');
           btn.style.display = 'none';
           mobileBtn.style.display = 'none';
           controls.classList.add('show');
       } else {
           document.body.classList.remove('edit-mode');
           btn.style.display = 'block';
           mobileBtn.style.display = 'block';
           controls.classList.remove('show');
           this.gameBackups.clear();
       }
       
       this.render();
   }

   saveAllChanges() {
       document.querySelectorAll('.game-card.edit-mode').forEach(card => {
           const gameId = card.dataset.gameId;
           const game = this.games.get(gameId);
           if (!game) return;

           game.name = card.querySelector('[data-field="name"]').value;
           game.year = parseInt(card.querySelector('[data-field="year"]').value) || null;
           game.players.min = parseInt(card.querySelector('[data-field="players.min"]').value) || 1;
           game.players.max = parseInt(card.querySelector('[data-field="players.max"]').value) || 1;
           game.playtime.min = parseInt(card.querySelector('[data-field="playtime.min"]').value) || 0;
           game.playtime.max = parseInt(card.querySelector('[data-field="playtime.max"]').value) || 0;
           game.weight = parseFloat(card.querySelector('[data-field="weight"]').value) || 0;
           game.weightColor = card.querySelector('[data-field="weightColor"]').value || 'green';
           game.notes = card.querySelector('[data-field="notes"]').value;

           const designersField = card.querySelector('[data-field="designers"]');
           if (designersField) {
               game.designers = designersField.value.split(',').map(s => s.trim()).filter(s => s);
           }

           const artistsField = card.querySelector('[data-field="artists"]');
           if (artistsField) {
               game.artists = artistsField.value.split(',').map(s => s.trim()).filter(s => s);
           }

           const publishersField = card.querySelector('[data-field="publishers"]');
           if (publishersField) {
               game.publishers = publishersField.value.split(',').map(s => s.trim()).filter(s => s);
           }

           const bestPlayersField = card.querySelector('[data-field="bestPlayerCount"]');
           if (bestPlayersField) {
               game.bestPlayerCount = bestPlayersField.value.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
           }

           const imageInputs = card.querySelectorAll('.edit-image-item input');
           game.images = Array.from(imageInputs).map(input => input.value.trim()).filter(url => url);
       });

       this.saveToStorage();
       this.toggleEditMode();
       this.applyFilters();
       alert('All changes saved successfully!');
   }

   discardAllChanges() {
       if (confirm('Discard all changes? This cannot be undone.')) {
           this.games.clear();
           this.gameBackups.forEach((game, id) => {
               this.games.set(id, game);
           });
           
           this.toggleEditMode();
           this.applyFilters();
       }
   }

cycleColumns() {
       const isMobile = window.innerWidth <= 768;
       const columnOptions = isMobile ? [1, 2, 3] : [1, 2, 3, 4, 5];
       const currentColumns = isMobile ? this.mobileColumns : this.currentColumns;
       let currentIndex = columnOptions.indexOf(currentColumns);
       if (currentIndex === -1) currentIndex = isMobile ? 1 : 4; // Default to 2 mobile, 5 desktop
       const nextIndex = (currentIndex + 1) % columnOptions.length;
       const newColumns = columnOptions[nextIndex];
       
       if (isMobile) {
           this.mobileColumns = newColumns;
       } else {
           this.currentColumns = newColumns;
       }
       this.setColumns(newColumns);
   }

setColumns(cols) {
       const grid = document.getElementById('game-grid');
       grid.className = `game-grid cols-${cols}`;
       
       const colText = `${cols} Column${cols !== 1 ? 's' : ''}`;
       const desktopBtn = document.getElementById('columns-btn');
       const mobileBtn = document.getElementById('mobile-columns-btn');
       
       if (desktopBtn) desktopBtn.textContent = colText;
       if (mobileBtn) mobileBtn.textContent = colText;
   }

   deleteGameInEditMode(gameId) {
       if (confirm('Delete this game? This will be permanent when you save changes.')) {
           this.games.delete(gameId);
           this.render();
       }
   }

   addImageToGame(button) {
       const imageHtml = `
           <div class="edit-image-item">
               <input type="text" value="" placeholder="Image URL">
               <button onclick="this.parentElement.remove()">×</button>
           </div>
       `;
       button.parentElement.insertAdjacentHTML('beforeend', imageHtml);
   }

   clearFilters() {
       document.getElementById('search').value = '';
       document.getElementById('mobile-search').value = '';
       document.getElementById('min-players').value = '';
       document.getElementById('max-players').value = '';
       document.getElementById('min-playtime').value = '';
       document.getElementById('max-playtime').value = '';
       document.getElementById('year-filter').value = '';
       document.getElementById('publisher-filter').value = '';
       document.getElementById('min-weight').value = '';
       document.getElementById('max-weight').value = '';
       document.getElementById('best-player-count-filter').value = '';
       
       document.getElementById('custom-filters-container').innerHTML = '';
       
       this.currentFilters = {};
       this.customFilters = [];
       this.applyFilters();
   }

   applyFilters() {
       this.updateFilters();
       
       let filtered = Array.from(this.games.values());

       if (this.currentFilters.search) {
           const search = this.currentFilters.search.toLowerCase();
           filtered = filtered.filter(game => 
               game.name.toLowerCase().includes(search) ||
               (game.notes && game.notes.toLowerCase().includes(search)) ||
               (game.designers && game.designers.some(d => d.toLowerCase().includes(search))) ||
               (game.publishers && game.publishers.some(p => p.toLowerCase().includes(search)))
           );
       }

       if (this.currentFilters.minPlayers) {
           const type = this.currentFilters.minPlayersType;
           const value = this.currentFilters.minPlayers;
           filtered = filtered.filter(game => {
               if (!game.players) return false;
               if (type === 'exact') return game.players.min === value;
               if (type === 'greater') return game.players.max >= value;
               if (type === 'less') return game.players.min <= value;
               return true;
           });
       }

       if (this.currentFilters.maxPlayers) {
           const type = this.currentFilters.maxPlayersType;
           const value = this.currentFilters.maxPlayers;
           filtered = filtered.filter(game => {
               if (!game.players) return false;
               if (type === 'exact') return game.players.max === value;
               if (type === 'less') return game.players.min <= value;
               if (type === 'greater') return game.players.max >= value;
               return true;
           });
       }

       if (this.currentFilters.minPlaytime) {
           const type = this.currentFilters.minPlaytimeType;
           const value = this.currentFilters.minPlaytime;
           filtered = filtered.filter(game => {
               if (!game.playtime) return false;
               if (type === 'exact') return game.playtime.min === value;
               if (type === 'greater') return game.playtime.max >= value;
               if (type === 'less') return game.playtime.min <= value;
               return true;
           });
       }

       if (this.currentFilters.maxPlaytime) {
           const type = this.currentFilters.maxPlaytimeType;
           const value = this.currentFilters.maxPlaytime;
           filtered = filtered.filter(game => {
               if (!game.playtime) return false;
               if (type === 'exact') return game.playtime.max === value;
               if (type === 'less') return game.playtime.min <= value;
               if (type === 'greater') return game.playtime.max >= value;
               return true;
           });
       }

       if (this.currentFilters.year) {
           const type = this.currentFilters.yearType;
           const value = this.currentFilters.year;
           filtered = filtered.filter(game => {
               if (!game.year) return false;
               if (type === 'exact') return game.year === value;
               if (type === 'greater') return game.year > value;
               if (type === 'less') return game.year < value;
               return true;
           });
       }

       if (this.currentFilters.minWeight) {
           const type = this.currentFilters.minWeightType;
           const value = this.currentFilters.minWeight;
           filtered = filtered.filter(game => {
               if (game.weight === null || game.weight === undefined) return false;
               if (type === 'exact') return Math.abs(game.weight - value) < 0.1;
               if (type === 'greater') return game.weight > value;
               return true;
           });
       }

       if (this.currentFilters.maxWeight) {
           const type = this.currentFilters.maxWeightType;
           const value = this.currentFilters.maxWeight;
           filtered = filtered.filter(game => {
               if (game.weight === null || game.weight === undefined) return false;
               if (type === 'exact') return Math.abs(game.weight - value) < 0.1;
               if (type === 'less') return game.weight < value;
               return true;
           });
       }

       if (this.currentFilters.publisher) {
           const type = this.currentFilters.publisherType;
           const value = this.currentFilters.publisher.toLowerCase();
           filtered = filtered.filter(game => {
               if (!game.publishers) return false;
               const publisherText = game.publishers.join(' ').toLowerCase();
               if (type === 'contains') return publisherText.includes(value);
               if (type === 'exact') return game.publishers.some(p => p.toLowerCase() === value);
               if (type === 'not-contains') return !publisherText.includes(value);
               return true;
           });
       }

       if (this.currentFilters.designer) {
           filtered = filtered.filter(game => {
               if (!game.designers) return false;
               return game.designers.includes(this.currentFilters.designer);
           });
       }

       if (this.currentFilters.publisherDropdown) {
           filtered = filtered.filter(game => {
               if (!game.publishers) return false;
               return game.publishers.includes(this.currentFilters.publisherDropdown);
           });
       }

       if (this.currentFilters.notes) {
           const type = this.currentFilters.notesType;
           const value = this.currentFilters.notes.toLowerCase();
           filtered = filtered.filter(game => {
               if (!game.notes) return false;
               const notesText = game.notes.toLowerCase();
               if (type === 'contains') return notesText.includes(value);
               if (type === 'exact') return notesText === value;
               if (type === 'not-contains') return !notesText.includes(value);
               return true;
           });
       }

       if (this.currentFilters.bestPlayerCount) {
           const counts = this.currentFilters.bestPlayerCount.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
           if (counts.length > 0) {
               filtered = filtered.filter(game => {
                   if (!game.bestPlayerCount || game.bestPlayerCount.length === 0) return false;
                   return counts.some(count => game.bestPlayerCount.includes(count));
               });
           }
       }

       this.customFilters.forEach(filter => {
           filtered = filtered.filter(game => {
               let gameValue;
               
               if (filter.field.includes('.')) {
                   const [field, subField] = filter.field.split('.');
                   gameValue = game[field] ? game[field][subField] : null;
               } else {
                   gameValue = game[filter.field];
               }

               if (gameValue === null || gameValue === undefined) return false;

               const filterValue = filter.value.toLowerCase();
               
               if (Array.isArray(gameValue)) {
                   const arrayText = gameValue.join(' ').toLowerCase();
                   switch (filter.type) {
                       case 'contains': return arrayText.includes(filterValue);
                       case 'exact': return gameValue.some(v => v.toLowerCase() === filterValue);
                       case 'not-contains': return !arrayText.includes(filterValue);
                       default: return false;
                   }
               } else if (typeof gameValue === 'string') {
                   const stringValue = gameValue.toLowerCase();
                   switch (filter.type) {
                       case 'contains': return stringValue.includes(filterValue);
                       case 'exact': return stringValue === filterValue;
                       case 'not-contains': return !stringValue.includes(filterValue);
                       default: return false;
                   }
               } else if (typeof gameValue === 'number') {
                   const numValue = parseFloat(filter.value);
                   if (isNaN(numValue)) return false;
                   switch (filter.type) {
                       case 'exact': return gameValue === numValue;
                       case 'greater': return gameValue > numValue;
                       case 'less': return gameValue < numValue;
                       case 'greater-equal': return gameValue >= numValue;
                       case 'less-equal': return gameValue <= numValue;
                       case 'contains': return gameValue.toString().includes(filter.value);
                       default: return false;
                   }
               }
               
               return false;
           });
       });

// Always include thumbs up games, even if they don't match filters
const thumbsUpGames = Array.from(this.games.values()).filter(game => 
    this.gamePreferences.get(game.bggId) === 'up'
);

// Apply thumb preferences to filtered games (hide thumbs down)
filtered = filtered.filter(game => {
    const preference = this.gamePreferences.get(game.bggId);
    if (preference === 'down') return false; // Hide thumbs down
    return true; // Show everything else (neutral)
});

// Combine thumbs up games with filtered games, removing duplicates
const filteredIds = new Set(filtered.map(game => game.bggId));
const uniqueThumbsUp = thumbsUpGames.filter(game => !filteredIds.has(game.bggId));
filtered = [...thumbsUpGames.filter(game => filteredIds.has(game.bggId)), ...uniqueThumbsUp, ...filtered.filter(game => this.gamePreferences.get(game.bggId) !== 'up')];

const sortField = document.getElementById('sort-field').value;
       const sortOrder = document.getElementById('sort-order').value;

       filtered.sort((a, b) => {
           let aVal, bVal;

           if (sortField.includes('.')) {
               const [field, subField] = sortField.split('.');
               aVal = a[field] ? a[field][subField] : 0;
               bVal = b[field] ? b[field][subField] : 0;
           } else {
               aVal = a[sortField];
               bVal = b[sortField];
           }

           if (typeof aVal === 'string') {
               aVal = aVal.toLowerCase();
               bVal = bVal.toLowerCase();
               // Remove "The " from beginning for sorting
               if (sortField === 'name') {
                   aVal = aVal.replace(/^the\s+/, '');
                   bVal = bVal.replace(/^the\s+/, '');
               }
           }

           if (aVal < bVal) return sortOrder === 'asc' ? -1 : 1;
           if (aVal > bVal) return sortOrder === 'asc' ? 1 : -1;
           return 0;
       });

       this.filteredGames = filtered;
       this.render();
   }

   async fetchBGGData() {
       const url = document.getElementById('bgg-url').value;
       if (!url) return;

       const loadingEl = document.getElementById('loading-indicator');
       const errorEl = document.getElementById('error-message');
       
       loadingEl.style.display = 'block';
       errorEl.style.display = 'none';

       try {
           const bggIdMatch = url.match(/\/boardgame\/(\d+)/);
           if (!bggIdMatch) {
               throw new Error('Invalid BoardGameGeek URL');
           }

           const bggId = bggIdMatch[1];
           
           const controller = new AbortController();
           const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout
           
           const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(`https://boardgamegeek.com/xmlapi2/thing?id=${bggId}&stats=1`)}`, {
               signal: controller.signal
           });
           
           clearTimeout(timeoutId);
           const data = await response.json();
           
           if (!response.ok) {
               throw new Error('Failed to fetch from BoardGameGeek');
           }

           const parser = new DOMParser();
           const xmlDoc = parser.parseFromString(data.contents, 'text/xml');
           const item = xmlDoc.querySelector('item');

           if (!item) {
               throw new Error('Game not found on BoardGameGeek');
           }

           const name = item.querySelector('name[type="primary"]')?.getAttribute('value') || '';
           const year = parseInt(item.querySelector('yearpublished')?.getAttribute('value')) || '';
           const minPlayers = parseInt(item.querySelector('minplayers')?.getAttribute('value')) || 1;
           const maxPlayers = parseInt(item.querySelector('maxplayers')?.getAttribute('value')) || 1;
           const playtime = parseInt(item.querySelector('playingtime')?.getAttribute('value')) || 0;
           const weight = parseFloat(item.querySelector('statistics averageweight')?.getAttribute('value')) || 0;

           const bestPlayerCount = [];
           const polls = item.querySelectorAll('poll[name="suggested_numplayers"] results');
           polls.forEach(result => {
               const numPlayers = result.getAttribute('numplayers');
               const best = result.querySelector('result[value="Best"]');
               const numVotes = best ? parseInt(best.getAttribute('numvotes')) : 0;
               if (numVotes > 0 && numPlayers !== '+') {
                   bestPlayerCount.push(parseInt(numPlayers));
               }
           });

           const designers = Array.from(item.querySelectorAll('link[type="boardgamedesigner"]')).map(el => el.getAttribute('value'));
           const artists = Array.from(item.querySelectorAll('link[type="boardgameartist"]')).map(el => el.getAttribute('value'));
           const publishers = Array.from(item.querySelectorAll('link[type="boardgamepublisher"]')).map(el => el.getAttribute('value'));
           const primaryImage = item.querySelector('image')?.textContent || '';
           const thumbnail = item.querySelector('thumbnail')?.textContent || '';
           const images = [primaryImage, thumbnail].filter(img => img && img !== primaryImage || img === primaryImage);

// Set default weight color based on complexity
           let defaultWeightColor = 'green';
           if (weight >= 2.5) {
               defaultWeightColor = 'red';
           } else if (weight >= 1.9) {
               defaultWeightColor = 'yellow';
           }

           document.getElementById('game-name').value = name;
           document.getElementById('game-year').value = year;
           document.getElementById('game-min-players').value = minPlayers;
           document.getElementById('game-max-players').value = maxPlayers;
           document.getElementById('game-playtime').value = playtime;
           document.getElementById('game-weight').value = weight.toFixed(1);
           document.getElementById('game-best-players').value = bestPlayerCount.join(', ');
           document.getElementById('game-designers').value = designers.join(', ');
           document.getElementById('game-artists').value = artists.join(', ');
           document.getElementById('game-publishers').value = publishers.join(', ');
           document.getElementById('game-images').value = images.join('\n');
           
           // Set the weight color dropdown if it exists
           const weightColorSelect = document.getElementById('game-weight-color');
           if (weightColorSelect) {
               weightColorSelect.value = defaultWeightColor;
           }

       } catch (error) {
           if (error.name === 'AbortError') {
               errorEl.textContent = 'Request timed out. BGG might be slow, please try again.';
           } else {
               errorEl.textContent = error.message;
           }
           errorEl.style.display = 'block';
       } finally {
           loadingEl.style.display = 'none';
       }
   }

   saveGame() {
       const formData = {
           bggId: Date.now().toString(),
           bggUrl: document.getElementById('bgg-url').value,
           name: document.getElementById('game-name').value,
           year: parseInt(document.getElementById('game-year').value) || null,
           players: {
               min: parseInt(document.getElementById('game-min-players').value) || 1,
               max: parseInt(document.getElementById('game-max-players').value) || 1
           },
           playtime: {
               min: parseInt(document.getElementById('game-playtime').value) || 0,
               max: parseInt(document.getElementById('game-playtime').value) || 0
           },
weight: parseFloat(document.getElementById('game-weight').value) || 0,
           weightColor: document.getElementById('game-weight-color').value || 'green',
           bestPlayerCount: document.getElementById('game-best-players').value.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n)),
           designers: document.getElementById('game-designers').value.split(',').map(s => s.trim()).filter(s => s),
           artists: document.getElementById('game-artists').value.split(',').map(s => s.trim()).filter(s => s),
           publishers: document.getElementById('game-publishers').value.split(',').map(s => s.trim()).filter(s => s),
           images: document.getElementById('game-images').value.split('\n').map(s => s.trim()).filter(s => s),
           notes: document.getElementById('game-notes').value,
           customFields: {}
       };

       if (!formData.name) {
           alert('Game name is required');
           return;
       }

       this.games.set(formData.bggId, formData);
       this.saveToStorage();
       this.closeForm();
       this.applyFilters();
   }

closeForm() {
       document.getElementById('add-game-form').classList.remove('show');
       document.getElementById('add-game-form').querySelectorAll('input, textarea').forEach(input => {
           input.value = '';
       });
       document.getElementById('add-game-form').querySelectorAll('select').forEach(select => {
           select.selectedIndex = 0;
       });
       document.getElementById('error-message').style.display = 'none';
   }

   render() {
       const container = document.getElementById('game-grid');
       const emptyState = document.getElementById('empty-state');
       const resultsInfo = document.getElementById('results-info');

       if (this.filteredGames.length === 0) {
           container.innerHTML = '';
           emptyState.style.display = 'block';
           resultsInfo.textContent = '';
           return;
       }

       emptyState.style.display = 'none';
       resultsInfo.textContent = `Showing ${this.filteredGames.length} of ${this.games.size} games`;

       container.innerHTML = this.filteredGames.map(game => {
           return this.isEditMode ? this.renderEditGameCard(game) : this.renderGameCard(game);
       }).join('');
       
       if (!this.isEditMode) {
           this.filteredGames.forEach((game, index) => {
               if (game.images && game.images.length > 0) {
                   new Swiper(`#swiper-${game.bggId}`, {
                       navigation: {
                           nextEl: `#swiper-${game.bggId} .swiper-button-next`,
                           prevEl: `#swiper-${game.bggId} .swiper-button-prev`,
                       },

pagination: {
                           el: `#swiper-${game.bggId} .swiper-pagination`,
                           clickable: true,
                       },
                       loop: game.images.length > 1,
                       autoHeight: true,
                   });
               }
           });

           container.querySelectorAll('.details-toggle').forEach(btn => {
               btn.addEventListener('click', (e) => {
                   const content = e.target.nextElementSibling;
                   content.classList.toggle('show');
                   const icon = e.target.querySelector('.toggle-icon');
                   icon.textContent = content.classList.contains('show') ? '▼' : '▶';
               });
           });
       }
   }

   renderGameCard(game) {
       const playerRange = game.players ? `${game.players.min}-${game.players.max}` : 'Unknown';
       const playtimeText = game.playtime ? `${game.playtime.min}${game.playtime.min !== game.playtime.max ? `-${game.playtime.max}` : ''} min` : 'Unknown';
       
       const allVisibleFields = [...new Set([...this.cardVisibleFields, ...this.dynamicCardFields])];
       
       const imagesHtml = game.images && game.images.length > 0 ? `
           <div class="swiper" id="swiper-${game.bggId}">
               <div class="swiper-wrapper">
                   ${game.images.map(img => `
                       <div class="swiper-slide">
                           <img src="${img}" alt="${game.name}" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjBmMGYwIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPk5vIEltYWdlPC90ZXh0Pjwvc3ZnPg=='">
                       </div>
                   `).join('')}
               </div>
               ${game.images.length > 1 ? `
                   <div class="swiper-button-next" onclick="event.stopPropagation();"></div>
                   <div class="swiper-button-prev" onclick="event.stopPropagation();"></div>
                   <div class="swiper-pagination"></div>
               ` : ''}
           </div>
       ` : `
           <div style="height: 200px; background: #f0f0f0; display: flex; align-items: center; justify-content: center; color: #999;">
               No Image
           </div>
       `;

       const metaItems = [];
       
       if (allVisibleFields.includes('year') && game.year) {
           metaItems.push(`<div class="meta-item"><span class="meta-label">Year:</span><span>${game.year}</span></div>`);
       }
       if (allVisibleFields.includes('players')) {
           metaItems.push(`<div class="meta-item"><span class="meta-label">Players:</span><span>${playerRange}</span></div>`);
       }
       if (allVisibleFields.includes('playtime')) {
           metaItems.push(`<div class="meta-item"><span class="meta-label">Time:</span><span>${playtimeText}</span></div>`);
       }
       if (allVisibleFields.includes('weight') && game.weight) {
           const weightColor = game.weightColor || 'green';
metaItems.push(`<div class="meta-item"><span class="meta-label">Weight:</span><span style="color: ${weightColor};">${game.weight.toFixed(1)}</span><span class="complexity-tooltip"ℹ️<span class="tooltiptext"><span style="color: green;">Green means easy, ok for RJ/Jeff/non-gamers/kids</span><br><span style="color: yellow;">Yellow means too much for above, but normal for most people</span><br><span style="color: red;">Red means gamers only, Luc/Jeremiah would enjoy, Kim would not, higher strategy, full weight</span></span></span></div>`);
       }
       if (allVisibleFields.includes('publishers') && game.publishers?.length > 0) {
           metaItems.push(`<div class="meta-item"><span class="meta-label">Publisher:</span><span>${game.publishers[0]}</span></div>`);
       }
       if (allVisibleFields.includes('bestPlayerCount') && game.bestPlayerCount?.length > 0) {
           metaItems.push(`<div class="meta-item"><span class="meta-label">Best:</span><span>${game.bestPlayerCount.join(', ')}</span></div>`);
       }

const preference = this.gamePreferences.get(game.bggId);
const thumbsHtml = `
    <div class="thumb-buttons">
        <button class="thumb-btn thumb-up ${preference === 'up' ? 'active' : ''}" 
                onclick="event.stopPropagation(); boardGameApp.setGamePreference('${game.bggId}', 'up')">
            👍
        </button>
        <button class="thumb-btn thumb-down ${preference === 'down' ? 'active' : ''}" 
                onclick="event.stopPropagation(); boardGameApp.setGamePreference('${game.bggId}', 'down')">
            👎
        </button>
    </div>
`;

return `
    <div class="game-card" data-game-id="${game.bggId}" onclick="boardGameApp.openGameModal('${game.bggId}')" style="cursor: pointer;">
        <div class="image-carousel">
            ${imagesHtml}
        </div>
        <div class="game-info">
            <h3 class="game-title">${game.name}</h3>
            ${metaItems.length > 0 ? `
                <div class="game-meta">
                    ${metaItems.join('')}
                </div>
            ` : ''}
        </div>
        ${thumbsHtml}
    </div>
`;
   }

   renderEditGameCard(game) {
       const addImageButton = (index) => `
           <div class="edit-image-item">
               <input type="text" value="${game.images && game.images[index] ? game.images[index] : ''}" placeholder="Image URL">
               <button onclick="this.parentElement.remove()">×</button>
           </div>
       `;

       const imagesHtml = `
           <div class="edit-images">
               ${game.images && game.images.length > 0 ? 
                   game.images.map((img, index) => addImageButton(index)).join('') :
                   addImageButton(0)
               }
               <button class="add-image-btn" onclick="boardGameApp.addImageToGame(this)">Add Image</button>
           </div>
       `;

       return `
           <div class="game-card edit-mode" data-game-id="${game.bggId}">
               <div class="edit-expanded">
                   <div class="edit-section">
                       <h4>Basic Information</h4>
                       <div class="edit-row">
                           <div class="edit-group">
                               <label>Game Name</label>
                               <input type="text" class="edit-field" data-field="name" value="${game.name || ''}">
                           </div>
                           <div class="edit-group">
                               <label>Year</label>
                               <input type="number" class="edit-field" data-field="year" value="${game.year || ''}" min="1900" max="2030">
                           </div>
                       </div>
                       <div class="edit-row">
                           <div class="edit-group">
                               <label>Min Players</label>
                               <input type="number" class="edit-field" data-field="players.min" value="${game.players?.min || 1}" min="1">
                           </div>
                           <div class="edit-group">
                               <label>Max Players</label>
                               <input type="number" class="edit-field" data-field="players.max" value="${game.players?.max || 1}" min="1">
                           </div>
                           <div class="edit-group">
                               <label>Min Playtime</label>
                               <input type="number" class="edit-field" data-field="playtime.min" value="${game.playtime?.min || 0}" min="0">
                           </div>
                           <div class="edit-group">
                               <label>Max Playtime</label>
                               <input type="number" class="edit-field" data-field="playtime.max" value="${game.playtime?.max || 0}" min="0">
                           </div>
                       </div>
                       <div class="edit-row">
                           <div class="edit-group">
                               <label>Complexity (1-5)</label>
                               <div style="display: flex; gap: 0.5rem;">
                                   <input type="number" class="edit-field" data-field="weight" value="${game.weight || ''}" min="0" max="5" step="0.1" style="flex: 1;">
                                   <select class="edit-field" data-field="weightColor" style="width: 100px;">
                                       <option value="green" ${(game.weightColor || 'green') === 'green' ? 'selected' : ''}>Green</option>
                                       <option value="yellow" ${(game.weightColor || 'green') === 'yellow' ? 'selected' : ''}>Yellow</option>
                                       <option value="red" ${(game.weightColor || 'green') === 'red' ? 'selected' : ''}>Red</option>
                                   </select>
                               </div>
                           </div>
                           <div class="edit-group">
                               <label>Best Player Count</label>
                               <input type="text" class="edit-field" data-field="bestPlayerCount" value="${game.bestPlayerCount ? game.bestPlayerCount.join(', ') : ''}" placeholder="2,3,4">
                           </div>
                       </div>
                   </div>
                   
                   <div class="edit-section">
                       <h4>People</h4>
                       <div class="edit-row">
                           <div class="edit-group">
                               <label>Designers</label>
                               <input type="text" class="edit-field" data-field="designers" value="${game.designers ? game.designers.join(', ') : ''}" placeholder="Comma separated">
                           </div>
                           <div class="edit-group">
                               <label>Artists</label>
                               <input type="text" class="edit-field" data-field="artists" value="${game.artists ? game.artists.join(', ') : ''}" placeholder="Comma separated">
                           </div>
                           <div class="edit-group">
                               <label>Publishers</label>
                               <input type="text" class="edit-field" data-field="publishers" value="${game.publishers ? game.publishers.join(', ') : ''}" placeholder="Comma separated">
                           </div>
                       </div>
                   </div>

                   <div class="edit-section">
                       <h4>Images</h4>
                       ${imagesHtml}
                   </div>

                   <div class="edit-section">
                       <h4>Notes</h4>
                       <textarea class="edit-field" data-field="notes" rows="3" placeholder="Your thoughts about this game...">${game.notes || ''}</textarea>
                   </div>

                   <button class="delete-game-btn" onclick="boardGameApp.deleteGameInEditMode('${game.bggId}')">Delete Game</button>
               </div>
           </div>
       `;
   }

   openGameModal(gameId) {
       if (this.isEditMode) return;
       
       const game = this.games.get(gameId);
       if (!game) return;
       
       const modal = document.getElementById('game-modal');
       const content = document.getElementById('modal-game-content');
       
       content.innerHTML = this.renderGameModalContent(game);
       modal.style.display = 'block';
       
       if (game.images && game.images.length > 0) {
           new Swiper('#modal-swiper', {
               navigation: {
                   nextEl: '#modal-swiper .swiper-button-next',
                   prevEl: '#modal-swiper .swiper-button-prev',
               },
               pagination: {
                   el: '#modal-swiper .swiper-pagination',
                   clickable: true,
               },
               loop: game.images.length > 1,
           });
           
           document.querySelectorAll('#modal-swiper .swiper-slide img').forEach(img => {
               img.addEventListener('click', () => {
                   this.openLightbox(game);
               });
           });
       }
   }

   renderGameModalContent(game) {
       const playerRange = game.players ? `${game.players.min}-${game.players.max}` : 'Unknown';
       const playtimeText = game.playtime ? `${game.playtime.min}${game.playtime.min !== game.playtime.max ? `-${game.playtime.max}` : ''} min` : 'Unknown';
       
       const imagesHtml = game.images && game.images.length > 0 ? `
           <div class="swiper" id="modal-swiper" style="height: 300px; margin-bottom: 2rem;">
               <div class="swiper-wrapper">
                   ${game.images.map(img => `
                       <div class="swiper-slide">
                           <img src="${img}" alt="${game.name}" style="width: 100%; height: 100%; object-fit: contain; cursor: pointer;">
                       </div>
                   `).join('')}
               </div>
               ${game.images.length > 1 ? `
                   <div class="swiper-button-next"></div>
                   <div class="swiper-button-prev"></div>
                   <div class="swiper-pagination"></div>
               ` : ''}
           </div>
       ` : '';

const preference = this.gamePreferences.get(game.bggId);
const modalThumbsHtml = `
    <div class="modal-thumbs">
        <button class="thumb-btn thumb-up ${preference === 'up' ? 'active' : ''}" 
                onclick="boardGameApp.setGamePreference('${game.bggId}', 'up')">
            👍
        </button>
        <button class="thumb-btn thumb-down ${preference === 'down' ? 'active' : ''}" 
                onclick="boardGameApp.setGamePreference('${game.bggId}', 'down')">
            👎
        </button>
    </div>
`;

return `
    ${modalThumbsHtml}
    <h2>${game.name}</h2>
    ${imagesHtml}
           
           <div style="display: flex; flex-wrap: wrap; gap: 2rem; margin-bottom: 2rem; align-items: center;">
               <div><strong>Year:</strong> ${game.year || 'Unknown'}</div>
               <div><strong>Players:</strong> ${playerRange}</div>
               <div><strong>Playtime:</strong> ${playtimeText}</div>
               <div><strong>Complexity:</strong> ${game.weight ? `<span style="color: ${game.weightColor || 'green'};">${game.weight.toFixed(1)}</span><span class="complexity-tooltip">ℹ️<span class="tooltiptext"><span style="color: green;">Green means easy</span><br><span style="color: yellow;">Yellow means difficult</span><br><span style="color: red;">Red means gamers only</span></span></span>` : 'N/A'}</div>
               ${game.bestPlayerCount && game.bestPlayerCount.length > 0 ? `<div><strong>Best with:</strong> ${game.bestPlayerCount.join(', ')} players</div>` : ''}
               ${game.bggUrl ? `<div><strong>BoardGameGeek:</strong> <a href="${game.bggUrl}" target="_blank" style="color: #667eea;">View on BGG</a></div>` : ''}
           </div>
           
           <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 2rem;">
               <div class="modal-left-column">
                   ${game.notes ? `
                       <div>
                           <strong>Notes:</strong>
                           <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-top: 0.5rem;">
                               ${game.notes.replace(/\n/g, '<br>').replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" style="color: #667eea;">$1</a>')}
                           </div>
                       </div>
                   ` : ''}
               </div>
               
               <div class="modal-right-column">
                   ${game.designers && game.designers.length > 0 ? `
                       <div style="margin-bottom: 1rem;">
                           <strong>Designers:</strong> ${game.designers.join(', ')}
                       </div>
                   ` : ''}
                   
                   ${game.artists && game.artists.length > 0 ? `
                       <div style="margin-bottom: 1rem;">
                           <strong>Artists:</strong> ${game.artists.join(', ')}
                       </div>
                   ` : ''}
                   
                   ${game.publishers && game.publishers.length > 0 ? `
                       <div style="margin-bottom: 1rem;">
                           <strong>Publishers:</strong> ${game.publishers.join(', ')}
                       </div>
                   ` : ''}
               </div>
           </div>
       `;
   }

   openLightbox(game) {
       const lightbox = document.getElementById('lightbox-modal');
       const container = document.getElementById('lightbox-swiper');
       
       container.innerHTML = `
           <div class="swiper" style="width: 90vw; height: 90vh;">
               <div class="swiper-wrapper">
                   ${game.images.map(img => `
                       <div class="swiper-slide" style="display: flex; align-items: center; justify-content: center;">
                           <img src="${img}" alt="${game.name}" style="max-width: 100%; max-height: 100%; object-fit: contain;">
                       </div>
                   `).join('')}
               </div>
               ${game.images.length > 1 ? `
                   <div class="swiper-button-next"></div>
                   <div class="swiper-button-prev"></div>
                   <div class="swiper-pagination"></div>
               ` : ''}
           </div>
       `;
       
       lightbox.style.display = 'block';
       
       new Swiper('#lightbox-swiper .swiper', {
           navigation: {
               nextEl: '#lightbox-swiper .swiper-button-next',
               prevEl: '#lightbox-swiper .swiper-button-prev',
           },
           pagination: {
               el: '#lightbox-swiper .swiper-pagination',
               clickable: true,
           },
           loop: game.images.length > 1,
           keyboard: true,
       });
   }

   closeModal() {
       // Destroy any active swipers to prevent memory leaks
       const modalSwiper = document.querySelector('#modal-swiper .swiper');
       if (modalSwiper && modalSwiper.swiper) {
           modalSwiper.swiper.destroy(true, true);
       }
       document.getElementById('game-modal').style.display = 'none';
   }

   closeLightbox() {
       // Destroy any active swipers to prevent memory leaks
       const lightboxSwiper = document.querySelector('#lightbox-swiper .swiper');
       if (lightboxSwiper && lightboxSwiper.swiper) {
           lightboxSwiper.swiper.destroy(true, true);
       }
       document.getElementById('lightbox-modal').style.display = 'none';
   }

shareCollection() {
    const allGames = Array.from(this.games.values());
const config = {
    filters: this.currentFilters,
    visibleFields: this.visibleFields,
    games: allGames,
    viewMode: 'gallery',
    sortField: document.getElementById('sort-field').value,
    sortOrder: document.getElementById('sort-order').value,
    columns: this.currentColumns,
    preferences: Object.fromEntries(this.gamePreferences)
};

    // Fix for non-Latin characters - encode to base64 properly
    const jsonString = JSON.stringify(config);
    const encodedData = btoa(unescape(encodeURIComponent(jsonString)));
    const shareUrl = `${window.location.origin}${window.location.pathname}?share=${encodedData}`;
    
    const shareText = `Check out this curated board game collection (${filtered.length} games)`;
    
// Always copy to clipboard and open TinyURL
navigator.clipboard.writeText(shareUrl).then(() => {
    window.open('https://tinyurl.com/', '_blank');
    alert(`Share URL copied to clipboard!\n\nTinyURL opened in new tab - paste to shorten.\n\nThis will show ${filtered.length} games with your current filters and sorting applied.`);
}).catch(() => {
    window.open('https://tinyurl.com/', '_blank');
    prompt('Copy this URL to share your collection (TinyURL opened in new tab):', shareUrl);
});
}

   exportData() {
       const data = {
           games: Object.fromEntries(this.games),
           exported: new Date().toISOString(),
           version: '1.0'
       };

       const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
       const url = URL.createObjectURL(blob);
       const a = document.createElement('a');
       a.href = url;
       a.download = `boardgame-collection-${new Date().toISOString().split('T')[0]}.json`;
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
   }

async importData(file) {
       if (!file) return;

       try {
           const text = await file.text();
           const data = JSON.parse(text);

           if (data.games) {
               const shouldClear = confirm('Clear existing collection before importing?');
               if (shouldClear) {
                   this.games.clear();
               }

               Object.entries(data.games).forEach(([id, game]) => {
                   this.games.set(id, game);
               });

               this.saveToStorage();
               this.applyFilters();
               alert(`Imported ${Object.keys(data.games).length} games successfully!`);
           }
       } catch (error) {
           alert('Error importing file: ' + error.message);
       }
   }

   setGamePreference(gameId, preference) {
       const currentPreference = this.gamePreferences.get(gameId);
       
       if (currentPreference === preference) {
           // If clicking the same preference, toggle it off
           this.gamePreferences.delete(gameId);
       } else {
           // Set new preference
           this.gamePreferences.set(gameId, preference);
       }
       
       this.updateClearThumbsVisibility();
       this.saveToStorage();
       this.applyFilters();
   }

clearThumbs() {
       if (this.isSharedView) {
           // In shared view, only clear user's own thumbs, keep original shared thumbs
           const newPreferences = new Map();
           this.originalSharedPreferences.forEach((pref, gameId) => {
               newPreferences.set(gameId, pref);
           });
           this.gamePreferences = newPreferences;
       } else {
           // In own collection, clear all thumbs
           this.gamePreferences.clear();
       }
       
       this.updateClearThumbsVisibility();
       this.saveToStorage();
       this.applyFilters();
   }

 updateClearThumbsVisibility() {
       let hasUserThumbs = false;
       
       if (this.isSharedView) {
           // Show clear button if user has made any changes from the original shared preferences
           hasUserThumbs = Array.from(this.gamePreferences.entries()).some(([gameId, pref]) => {
               return this.originalSharedPreferences.get(gameId) !== pref;
           });
       } else {
           // Show clear button if user has any thumbs in their own collection
           hasUserThumbs = this.gamePreferences.size > 0;
       }
       
       const clearBtn = document.getElementById('clear-thumbs-btn');
       const mobileClearBtn = document.getElementById('mobile-clear-thumbs-btn');
       
       if (clearBtn) clearBtn.style.display = hasUserThumbs ? 'inline-block' : 'none';
       if (mobileClearBtn) mobileClearBtn.style.display = hasUserThumbs ? 'inline-block' : 'none';
   }
}


let boardGameApp;

document.addEventListener('DOMContentLoaded', async () => {
   console.log('Initializing app...');
   try {
       boardGameApp = new BoardGameCollection();
       await boardGameApp.init();
       console.log('App initialized successfully');
   } catch (error) {
       console.error('Failed to initialize app:', error);
   }
});

</script>
<div id="game-modal" class="modal" style="display: none;">
   <div class="modal-content">
       <span class="close-modal" onclick="boardGameApp.closeModal()">&times;</span>
       <div id="modal-game-content"></div>
   </div>
</div>

<div id="lightbox-modal" class="lightbox" style="display: none;">
   <div class="lightbox-content">
       <span class="close-lightbox" onclick="boardGameApp.closeLightbox()">&times;</span>
       <div id="lightbox-swiper"></div>
   </div>
</div>
</body>
</html>
